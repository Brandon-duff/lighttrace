(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object') exports['$'] = factory();
  else root['$'] = factory();
})(window, function () {
  return /******/ (function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {}; // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {},
        /******/
      }); // Execute the module function
      /******/
      /******/ /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      ); // Flag the module as loaded
      /******/
      /******/ /******/ module.l = true; // Return the exports of the module
      /******/
      /******/ /******/ return module.exports;
      /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules; // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function (exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter,
        });
        /******/
      }
      /******/
    }; // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function (exports) {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module',
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function (
      value,
      mode
    ) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === 'object' &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value,
      });
      /******/ if (mode & 2 && typeof value != 'string')
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function (key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    }; // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function (module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module['default'];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, 'a', getter);
      /******/ return getter;
      /******/
    }; // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }; // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = ''; // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
      (__webpack_require__.s = './src/index.tsx')
    );
    /******/
  })(
    /************************************************************************/
    /******/ {
      /***/ './node_modules/@apollo/client/cache/core/cache.js':
        /*!*********************************************************!*\
  !*** ./node_modules/@apollo/client/cache/core/cache.js ***!
  \*********************************************************/
        /*! exports provided: ApolloCache */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloCache',
            function () {
              return ApolloCache;
            }
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          var ApolloCache = (function () {
            function ApolloCache() {
              this.getFragmentDoc = Object(
                optimism__WEBPACK_IMPORTED_MODULE_0__['wrap']
              )(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__[
                  'getFragmentQueryDocument'
                ]
              );
            }
            ApolloCache.prototype.recordOptimisticTransaction = function (
              transaction,
              optimisticId
            ) {
              this.performTransaction(transaction, optimisticId);
            };
            ApolloCache.prototype.transformDocument = function (document) {
              return document;
            };
            ApolloCache.prototype.identify = function (object) {
              return;
            };
            ApolloCache.prototype.gc = function () {
              return [];
            };
            ApolloCache.prototype.modify = function (options) {
              return false;
            };
            ApolloCache.prototype.transformForLink = function (document) {
              return document;
            };
            ApolloCache.prototype.readQuery = function (options, optimistic) {
              if (optimistic === void 0) {
                optimistic = false;
              }
              return this.read({
                rootId: options.id || 'ROOT_QUERY',
                query: options.query,
                variables: options.variables,
                optimistic: optimistic,
              });
            };
            ApolloCache.prototype.readFragment = function (
              options,
              optimistic
            ) {
              if (optimistic === void 0) {
                optimistic = false;
              }
              return this.read({
                query: this.getFragmentDoc(
                  options.fragment,
                  options.fragmentName
                ),
                variables: options.variables,
                rootId: options.id,
                optimistic: optimistic,
              });
            };
            ApolloCache.prototype.writeQuery = function (options) {
              return this.write({
                dataId: options.id || 'ROOT_QUERY',
                result: options.data,
                query: options.query,
                variables: options.variables,
                broadcast: options.broadcast,
              });
            };
            ApolloCache.prototype.writeFragment = function (options) {
              return this.write({
                dataId: options.id,
                result: options.data,
                variables: options.variables,
                query: this.getFragmentDoc(
                  options.fragment,
                  options.fragmentName
                ),
                broadcast: options.broadcast,
              });
            };
            return ApolloCache;
          })();

          //# sourceMappingURL=cache.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/core/types/Cache.js':
        /*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/core/types/Cache.js ***!
  \***************************************************************/
        /*! exports provided: Cache */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Cache',
            function () {
              return Cache;
            }
          );
          var Cache;
          (function (Cache) {})(Cache || (Cache = {}));
          //# sourceMappingURL=Cache.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/core/types/common.js':
        /*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/core/types/common.js ***!
  \****************************************************************/
        /*! exports provided: MissingFieldError */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'MissingFieldError',
            function () {
              return MissingFieldError;
            }
          );
          var MissingFieldError = (function () {
            function MissingFieldError(message, path, query, variables) {
              this.message = message;
              this.path = path;
              this.query = query;
              this.variables = variables;
            }
            return MissingFieldError;
          })();

          //# sourceMappingURL=common.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/index.js':
        /*!****************************************************!*\
  !*** ./node_modules/@apollo/client/cache/index.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _core_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./core/cache.js */ './node_modules/@apollo/client/cache/core/cache.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloCache',
            function () {
              return _core_cache_js__WEBPACK_IMPORTED_MODULE_0__['ApolloCache'];
            }
          );

          /* harmony import */ var _core_types_Cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./core/types/Cache.js */ './node_modules/@apollo/client/cache/core/types/Cache.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Cache',
            function () {
              return _core_types_Cache_js__WEBPACK_IMPORTED_MODULE_1__['Cache'];
            }
          );

          /* harmony import */ var _core_types_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./core/types/common.js */ './node_modules/@apollo/client/cache/core/types/common.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'MissingFieldError',
            function () {
              return _core_types_common_js__WEBPACK_IMPORTED_MODULE_2__[
                'MissingFieldError'
              ];
            }
          );

          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isReference',
            function () {
              return _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                'isReference'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'makeReference',
            function () {
              return _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                'makeReference'
              ];
            }
          );

          /* harmony import */ var _inmemory_inMemoryCache_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./inmemory/inMemoryCache.js */ './node_modules/@apollo/client/cache/inmemory/inMemoryCache.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'InMemoryCache',
            function () {
              return _inmemory_inMemoryCache_js__WEBPACK_IMPORTED_MODULE_4__[
                'InMemoryCache'
              ];
            }
          );

          /* harmony import */ var _inmemory_reactiveVars_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./inmemory/reactiveVars.js */ './node_modules/@apollo/client/cache/inmemory/reactiveVars.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'makeVar',
            function () {
              return _inmemory_reactiveVars_js__WEBPACK_IMPORTED_MODULE_5__[
                'makeVar'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'cacheSlot',
            function () {
              return _inmemory_reactiveVars_js__WEBPACK_IMPORTED_MODULE_5__[
                'cacheSlot'
              ];
            }
          );

          /* harmony import */ var _inmemory_policies_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./inmemory/policies.js */ './node_modules/@apollo/client/cache/inmemory/policies.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'defaultDataIdFromObject',
            function () {
              return _inmemory_policies_js__WEBPACK_IMPORTED_MODULE_6__[
                'defaultDataIdFromObject'
              ];
            }
          );

          /* harmony import */ var _inmemory_types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./inmemory/types.js */ './node_modules/@apollo/client/cache/inmemory/types.js'
          );
          /* harmony import */ var _inmemory_types_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __webpack_require__.n(
            _inmemory_types_js__WEBPACK_IMPORTED_MODULE_7__
          );
          /* harmony reexport (unknown) */ for (var __WEBPACK_IMPORT_KEY__ in _inmemory_types_js__WEBPACK_IMPORTED_MODULE_7__)
            if (
              [
                'default',
                'ApolloCache',
                'Cache',
                'MissingFieldError',
                'isReference',
                'makeReference',
                'InMemoryCache',
                'makeVar',
                'cacheSlot',
                'defaultDataIdFromObject',
              ].indexOf(__WEBPACK_IMPORT_KEY__) < 0
            )
              (function (key) {
                __webpack_require__.d(__webpack_exports__, key, function () {
                  return _inmemory_types_js__WEBPACK_IMPORTED_MODULE_7__[key];
                });
              })(__WEBPACK_IMPORT_KEY__);

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/entityStore.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/entityStore.js ***!
  \*******************************************************************/
        /*! exports provided: EntityStore, supportsResultCaching */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'EntityStore',
            function () {
              return EntityStore;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'supportsResultCaching',
            function () {
              return supportsResultCaching;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );
          /* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! @wry/equality */ './node_modules/@wry/equality/lib/equality.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./helpers.js */ './node_modules/@apollo/client/cache/inmemory/helpers.js'
          );

          var DELETE = Object.create(null);
          var delModifier = function () {
            return DELETE;
          };
          var EntityStore = (function () {
            function EntityStore(policies, group) {
              var _this = this;
              this.policies = policies;
              this.group = group;
              this.data = Object.create(null);
              this.rootIds = Object.create(null);
              this.refs = Object.create(null);
              this.getFieldValue = function (
                objectOrReference,
                storeFieldName
              ) {
                return Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'maybeDeepFreeze'
                  ]
                )(
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'isReference'
                    ]
                  )(objectOrReference)
                    ? _this.get(objectOrReference.__ref, storeFieldName)
                    : objectOrReference && objectOrReference[storeFieldName]
                );
              };
              this.canRead = function (objOrRef) {
                return Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'isReference'
                  ]
                )(objOrRef)
                  ? _this.has(objOrRef.__ref)
                  : typeof objOrRef === 'object';
              };
              this.toReference = function (objOrIdOrRef, mergeIntoStore) {
                if (typeof objOrIdOrRef === 'string') {
                  return Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'makeReference'
                    ]
                  )(objOrIdOrRef);
                }
                if (
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'isReference'
                    ]
                  )(objOrIdOrRef)
                ) {
                  return objOrIdOrRef;
                }
                var id = _this.policies.identify(objOrIdOrRef)[0];
                if (id) {
                  var ref = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'makeReference'
                    ]
                  )(id);
                  if (mergeIntoStore) {
                    _this.merge(id, objOrIdOrRef);
                  }
                  return ref;
                }
              };
            }
            EntityStore.prototype.toObject = function () {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                {},
                this.data
              );
            };
            EntityStore.prototype.has = function (dataId) {
              return this.lookup(dataId, true) !== void 0;
            };
            EntityStore.prototype.get = function (dataId, fieldName) {
              this.group.depend(dataId, fieldName);
              if (
                _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                  this.data,
                  dataId
                )
              ) {
                var storeObject = this.data[dataId];
                if (
                  storeObject &&
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                    storeObject,
                    fieldName
                  )
                ) {
                  return storeObject[fieldName];
                }
              }
              if (
                fieldName === '__typename' &&
                _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                  this.policies.rootTypenamesById,
                  dataId
                )
              ) {
                return this.policies.rootTypenamesById[dataId];
              }
              if (this instanceof Layer) {
                return this.parent.get(dataId, fieldName);
              }
            };
            EntityStore.prototype.lookup = function (
              dataId,
              dependOnExistence
            ) {
              if (dependOnExistence) this.group.depend(dataId, '__exists');
              return _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                this.data,
                dataId
              )
                ? this.data[dataId]
                : this instanceof Layer
                ? this.parent.lookup(dataId, dependOnExistence)
                : void 0;
            };
            EntityStore.prototype.merge = function (dataId, incoming) {
              var _this = this;
              var existing = this.lookup(dataId);
              var merged = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                'DeepMerger'
              ](storeObjectReconciler).merge(existing, incoming);
              this.data[dataId] = merged;
              if (merged !== existing) {
                delete this.refs[dataId];
                if (this.group.caching) {
                  var fieldsToDirty_1 = Object.create(null);
                  if (!existing) fieldsToDirty_1.__exists = 1;
                  Object.keys(incoming).forEach(function (storeFieldName) {
                    if (
                      !existing ||
                      existing[storeFieldName] !== merged[storeFieldName]
                    ) {
                      fieldsToDirty_1[
                        Object(
                          _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                            'fieldNameFromStoreName'
                          ]
                        )(storeFieldName)
                      ] = 1;
                      if (
                        merged[storeFieldName] === void 0 &&
                        !(_this instanceof Layer)
                      ) {
                        delete merged[storeFieldName];
                      }
                    }
                  });
                  Object.keys(fieldsToDirty_1).forEach(function (fieldName) {
                    return _this.group.dirty(dataId, fieldName);
                  });
                }
              }
            };
            EntityStore.prototype.modify = function (dataId, fields) {
              var _this = this;
              var storeObject = this.lookup(dataId);
              if (storeObject) {
                var changedFields_1 = Object.create(null);
                var needToMerge_1 = false;
                var allDeleted_1 = true;
                var readField_1 = function (fieldNameOrOptions, from) {
                  return _this.policies.readField(
                    typeof fieldNameOrOptions === 'string'
                      ? {
                          fieldName: fieldNameOrOptions,
                          from:
                            from ||
                            Object(
                              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                'makeReference'
                              ]
                            )(dataId),
                        }
                      : fieldNameOrOptions,
                    { store: _this }
                  );
                };
                Object.keys(storeObject).forEach(function (storeFieldName) {
                  var fieldName = Object(
                    _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                      'fieldNameFromStoreName'
                    ]
                  )(storeFieldName);
                  var fieldValue = storeObject[storeFieldName];
                  if (fieldValue === void 0) return;
                  var modify =
                    typeof fields === 'function'
                      ? fields
                      : fields[storeFieldName] || fields[fieldName];
                  if (modify) {
                    var newValue =
                      modify === delModifier
                        ? DELETE
                        : modify(
                            Object(
                              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                'maybeDeepFreeze'
                              ]
                            )(fieldValue),
                            {
                              DELETE: DELETE,
                              fieldName: fieldName,
                              storeFieldName: storeFieldName,
                              isReference:
                                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                  'isReference'
                                ],
                              toReference: _this.toReference,
                              canRead: _this.canRead,
                              readField: readField_1,
                            }
                          );
                    if (newValue === DELETE) newValue = void 0;
                    if (newValue !== fieldValue) {
                      changedFields_1[storeFieldName] = newValue;
                      needToMerge_1 = true;
                      fieldValue = newValue;
                    }
                  }
                  if (fieldValue !== void 0) {
                    allDeleted_1 = false;
                  }
                });
                if (needToMerge_1) {
                  this.merge(dataId, changedFields_1);
                  if (allDeleted_1) {
                    if (this instanceof Layer) {
                      this.data[dataId] = void 0;
                    } else {
                      delete this.data[dataId];
                    }
                    this.group.dirty(dataId, '__exists');
                  }
                  return true;
                }
              }
              return false;
            };
            EntityStore.prototype.delete = function (dataId, fieldName, args) {
              var _a;
              var storeObject = this.lookup(dataId);
              if (storeObject) {
                var typename = this.getFieldValue(storeObject, '__typename');
                var storeFieldName =
                  fieldName && args
                    ? this.policies.getStoreFieldName({
                        typename: typename,
                        fieldName: fieldName,
                        args: args,
                      })
                    : fieldName;
                return this.modify(
                  dataId,
                  storeFieldName
                    ? ((_a = {}), (_a[storeFieldName] = delModifier), _a)
                    : delModifier
                );
              }
              return false;
            };
            EntityStore.prototype.evict = function (options) {
              var evicted = false;
              if (options.id) {
                if (
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                    this.data,
                    options.id
                  )
                ) {
                  evicted = this.delete(
                    options.id,
                    options.fieldName,
                    options.args
                  );
                }
                if (this instanceof Layer) {
                  evicted = this.parent.evict(options) || evicted;
                }
                if (options.fieldName || evicted) {
                  this.group.dirty(options.id, options.fieldName || '__exists');
                }
              }
              return evicted;
            };
            EntityStore.prototype.clear = function () {
              this.replace(null);
            };
            EntityStore.prototype.replace = function (newData) {
              var _this = this;
              Object.keys(this.data).forEach(function (dataId) {
                if (
                  !(
                    newData &&
                    _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                      newData,
                      dataId
                    )
                  )
                ) {
                  _this.delete(dataId);
                }
              });
              if (newData) {
                Object.keys(newData).forEach(function (dataId) {
                  _this.merge(dataId, newData[dataId]);
                });
              }
            };
            EntityStore.prototype.retain = function (rootId) {
              return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);
            };
            EntityStore.prototype.release = function (rootId) {
              if (this.rootIds[rootId] > 0) {
                var count = --this.rootIds[rootId];
                if (!count) delete this.rootIds[rootId];
                return count;
              }
              return 0;
            };
            EntityStore.prototype.getRootIdSet = function (ids) {
              if (ids === void 0) {
                ids = new Set();
              }
              Object.keys(this.rootIds).forEach(ids.add, ids);
              if (this instanceof Layer) {
                this.parent.getRootIdSet(ids);
              }
              return ids;
            };
            EntityStore.prototype.gc = function () {
              var _this = this;
              var ids = this.getRootIdSet();
              var snapshot = this.toObject();
              ids.forEach(function (id) {
                if (
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                    snapshot,
                    id
                  )
                ) {
                  Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                  delete snapshot[id];
                }
              });
              var idsToRemove = Object.keys(snapshot);
              if (idsToRemove.length) {
                var root_1 = this;
                while (root_1 instanceof Layer) root_1 = root_1.parent;
                idsToRemove.forEach(function (id) {
                  return root_1.delete(id);
                });
              }
              return idsToRemove;
            };
            EntityStore.prototype.findChildRefIds = function (dataId) {
              if (
                !_helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                  this.refs,
                  dataId
                )
              ) {
                var found_1 = (this.refs[dataId] = Object.create(null));
                var workSet_1 = new Set([this.data[dataId]]);
                var canTraverse_1 = function (obj) {
                  return obj !== null && typeof obj === 'object';
                };
                workSet_1.forEach(function (obj) {
                  if (
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'isReference'
                      ]
                    )(obj)
                  ) {
                    found_1[obj.__ref] = true;
                  } else if (canTraverse_1(obj)) {
                    Object.values(obj)
                      .filter(canTraverse_1)
                      .forEach(workSet_1.add, workSet_1);
                  }
                });
              }
              return this.refs[dataId];
            };
            EntityStore.prototype.makeCacheKey = function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return this.group.keyMaker.lookupArray(args);
            };
            return EntityStore;
          })();

          var CacheGroup = (function () {
            function CacheGroup(caching) {
              this.caching = caching;
              this.d = null;
              this.keyMaker = new optimism__WEBPACK_IMPORTED_MODULE_1__[
                'KeyTrie'
              ](
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                  'canUseWeakMap'
                ]
              );
              this.d = caching
                ? Object(optimism__WEBPACK_IMPORTED_MODULE_1__['dep'])()
                : null;
            }
            CacheGroup.prototype.depend = function (dataId, storeFieldName) {
              if (this.d) {
                this.d(makeDepKey(dataId, storeFieldName));
              }
            };
            CacheGroup.prototype.dirty = function (dataId, storeFieldName) {
              if (this.d) {
                this.d.dirty(makeDepKey(dataId, storeFieldName));
              }
            };
            return CacheGroup;
          })();
          function makeDepKey(dataId, storeFieldName) {
            return (
              Object(
                _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                  'fieldNameFromStoreName'
                ]
              )(storeFieldName) +
              '#' +
              dataId
            );
          }
          (function (EntityStore) {
            var Root = (function (_super) {
              Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
                Root,
                _super
              );
              function Root(_a) {
                var policies = _a.policies,
                  _b = _a.resultCaching,
                  resultCaching = _b === void 0 ? true : _b,
                  seed = _a.seed;
                var _this =
                  _super.call(this, policies, new CacheGroup(resultCaching)) ||
                  this;
                _this.sharedLayerGroup = new CacheGroup(resultCaching);
                if (seed) _this.replace(seed);
                return _this;
              }
              Root.prototype.addLayer = function (layerId, replay) {
                return new Layer(layerId, this, replay, this.sharedLayerGroup);
              };
              Root.prototype.removeLayer = function () {
                return this;
              };
              return Root;
            })(EntityStore);
            EntityStore.Root = Root;
          })(EntityStore || (EntityStore = {}));
          var Layer = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              Layer,
              _super
            );
            function Layer(id, parent, replay, group) {
              var _this = _super.call(this, parent.policies, group) || this;
              _this.id = id;
              _this.parent = parent;
              _this.replay = replay;
              _this.group = group;
              replay(_this);
              return _this;
            }
            Layer.prototype.addLayer = function (layerId, replay) {
              return new Layer(layerId, this, replay, this.group);
            };
            Layer.prototype.removeLayer = function (layerId) {
              var _this = this;
              var parent = this.parent.removeLayer(layerId);
              if (layerId === this.id) {
                if (this.group.caching) {
                  Object.keys(this.data).forEach(function (dataId) {
                    if (_this.data[dataId] !== parent.lookup(dataId)) {
                      _this.delete(dataId);
                    }
                  });
                }
                return parent;
              }
              if (parent === this.parent) return this;
              return parent.addLayer(this.id, this.replay);
            };
            Layer.prototype.toObject = function () {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  this.parent.toObject()
                ),
                this.data
              );
            };
            Layer.prototype.findChildRefIds = function (dataId) {
              var fromParent = this.parent.findChildRefIds(dataId);
              return _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                this.data,
                dataId
              )
                ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      fromParent
                    ),
                    _super.prototype.findChildRefIds.call(this, dataId)
                  )
                : fromParent;
            };
            return Layer;
          })(EntityStore);
          function storeObjectReconciler(
            existingObject,
            incomingObject,
            property
          ) {
            var existingValue = existingObject[property];
            var incomingValue = incomingObject[property];
            return Object(_wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal'])(
              existingValue,
              incomingValue
            )
              ? existingValue
              : incomingValue;
          }
          function supportsResultCaching(store) {
            return !!(store instanceof EntityStore && store.group.caching);
          }
          //# sourceMappingURL=entityStore.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/fixPolyfills.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/fixPolyfills.js ***!
  \********************************************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          //# sourceMappingURL=fixPolyfills.js.map
          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/helpers.js':
        /*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/helpers.js ***!
  \***************************************************************/
        /*! exports provided: hasOwn, getTypenameFromStoreObject, fieldNameFromStoreName, storeValueIsStoreObject, isFieldValueToBeMerged, makeProcessedFieldsMerger */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hasOwn',
            function () {
              return hasOwn;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getTypenameFromStoreObject',
            function () {
              return getTypenameFromStoreObject;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'fieldNameFromStoreName',
            function () {
              return fieldNameFromStoreName;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'storeValueIsStoreObject',
            function () {
              return storeValueIsStoreObject;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isFieldValueToBeMerged',
            function () {
              return isFieldValueToBeMerged;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'makeProcessedFieldsMerger',
            function () {
              return makeProcessedFieldsMerger;
            }
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          var hasOwn = Object.prototype.hasOwnProperty;
          function getTypenameFromStoreObject(store, objectOrReference) {
            return Object(
              _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__['isReference']
            )(objectOrReference)
              ? store.get(objectOrReference.__ref, '__typename')
              : objectOrReference && objectOrReference.__typename;
          }
          var FieldNamePattern = /^[_A-Za-z0-9]+/;
          function fieldNameFromStoreName(storeFieldName) {
            var match = storeFieldName.match(FieldNamePattern);
            return match ? match[0] : storeFieldName;
          }
          function storeValueIsStoreObject(value) {
            return (
              value !== null &&
              typeof value === 'object' &&
              !Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__['isReference']
              )(value) &&
              !Array.isArray(value)
            );
          }
          function isFieldValueToBeMerged(value) {
            var field = value && value.__field;
            return (
              field &&
              Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__['isField']
              )(field)
            );
          }
          function makeProcessedFieldsMerger() {
            return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__[
              'DeepMerger'
            ](reconcileProcessedFields);
          }
          var reconcileProcessedFields = function (
            existingObject,
            incomingObject,
            property
          ) {
            var existing = existingObject[property];
            var incoming = incomingObject[property];
            if (isFieldValueToBeMerged(existing)) {
              existing.__value = this.merge(
                existing.__value,
                isFieldValueToBeMerged(incoming) ? incoming.__value : incoming
              );
              return existing;
            }
            if (isFieldValueToBeMerged(incoming)) {
              incoming.__value = this.merge(existing, incoming.__value);
              return incoming;
            }
            return this.merge(existing, incoming);
          };
          //# sourceMappingURL=helpers.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/inMemoryCache.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/inMemoryCache.js ***!
  \*********************************************************************/
        /*! exports provided: InMemoryCache */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'InMemoryCache',
            function () {
              return InMemoryCache;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _fixPolyfills_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./fixPolyfills.js */ './node_modules/@apollo/client/cache/inmemory/fixPolyfills.js'
          );
          /* harmony import */ var _fixPolyfills_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
            _fixPolyfills_js__WEBPACK_IMPORTED_MODULE_1__
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );
          /* harmony import */ var _core_cache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../core/cache.js */ './node_modules/@apollo/client/cache/core/cache.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _readFromStore_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./readFromStore.js */ './node_modules/@apollo/client/cache/inmemory/readFromStore.js'
          );
          /* harmony import */ var _writeToStore_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./writeToStore.js */ './node_modules/@apollo/client/cache/inmemory/writeToStore.js'
          );
          /* harmony import */ var _entityStore_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./entityStore.js */ './node_modules/@apollo/client/cache/inmemory/entityStore.js'
          );
          /* harmony import */ var _reactiveVars_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./reactiveVars.js */ './node_modules/@apollo/client/cache/inmemory/reactiveVars.js'
          );
          /* harmony import */ var _policies_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
            /*! ./policies.js */ './node_modules/@apollo/client/cache/inmemory/policies.js'
          );
          /* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
            /*! ./helpers.js */ './node_modules/@apollo/client/cache/inmemory/helpers.js'
          );

          var defaultConfig = {
            dataIdFromObject:
              _policies_js__WEBPACK_IMPORTED_MODULE_9__[
                'defaultDataIdFromObject'
              ],
            addTypename: true,
            resultCaching: true,
            typePolicies: {},
          };
          var InMemoryCache = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              InMemoryCache,
              _super
            );
            function InMemoryCache(config) {
              if (config === void 0) {
                config = {};
              }
              var _this = _super.call(this) || this;
              _this.watches = new Set();
              _this.typenameDocumentCache = new Map();
              _this.makeVar =
                _reactiveVars_js__WEBPACK_IMPORTED_MODULE_8__['makeVar'];
              _this.txCount = 0;
              _this.maybeBroadcastWatch = Object(
                optimism__WEBPACK_IMPORTED_MODULE_2__['wrap']
              )(
                function (c) {
                  return _this.broadcastWatch.call(_this, c);
                },
                {
                  makeCacheKey: function (c) {
                    var store = c.optimistic
                      ? _this.optimisticData
                      : _this.data;
                    if (
                      Object(
                        _entityStore_js__WEBPACK_IMPORTED_MODULE_7__[
                          'supportsResultCaching'
                        ]
                      )(store)
                    ) {
                      var optimistic = c.optimistic,
                        rootId = c.rootId,
                        variables = c.variables;
                      return store.makeCacheKey(
                        c.query,
                        c.callback,
                        JSON.stringify({
                          optimistic: optimistic,
                          rootId: rootId,
                          variables: variables,
                        })
                      );
                    }
                  },
                }
              );
              _this.watchDep = Object(
                optimism__WEBPACK_IMPORTED_MODULE_2__['dep']
              )();
              _this.config = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  defaultConfig
                ),
                config
              );
              _this.addTypename = !!_this.config.addTypename;
              _this.policies = new _policies_js__WEBPACK_IMPORTED_MODULE_9__[
                'Policies'
              ]({
                cache: _this,
                dataIdFromObject: _this.config.dataIdFromObject,
                possibleTypes: _this.config.possibleTypes,
                typePolicies: _this.config.typePolicies,
              });
              _this.data = new _entityStore_js__WEBPACK_IMPORTED_MODULE_7__[
                'EntityStore'
              ].Root({
                policies: _this.policies,
                resultCaching: _this.config.resultCaching,
              });
              _this.optimisticData = _this.data;
              _this.storeWriter = new _writeToStore_js__WEBPACK_IMPORTED_MODULE_6__[
                'StoreWriter'
              ](
                _this,
                (_this.storeReader = new _readFromStore_js__WEBPACK_IMPORTED_MODULE_5__[
                  'StoreReader'
                ]({
                  cache: _this,
                  addTypename: _this.addTypename,
                }))
              );
              return _this;
            }
            InMemoryCache.prototype.restore = function (data) {
              if (data) this.data.replace(data);
              return this;
            };
            InMemoryCache.prototype.extract = function (optimistic) {
              if (optimistic === void 0) {
                optimistic = false;
              }
              return (optimistic ? this.optimisticData : this.data).toObject();
            };
            InMemoryCache.prototype.read = function (options) {
              var store = options.optimistic ? this.optimisticData : this.data;
              if (
                typeof options.rootId === 'string' &&
                !store.has(options.rootId)
              ) {
                return null;
              }
              return (
                this.storeReader.readQueryFromStore({
                  store: store,
                  query: options.query,
                  variables: options.variables,
                  rootId: options.rootId,
                  config: this.config,
                }) || null
              );
            };
            InMemoryCache.prototype.write = function (options) {
              try {
                ++this.txCount;
                return this.storeWriter.writeToStore({
                  store: this.data,
                  query: options.query,
                  result: options.result,
                  dataId: options.dataId,
                  variables: options.variables,
                });
              } finally {
                if (!--this.txCount && options.broadcast !== false) {
                  this.broadcastWatches();
                }
              }
            };
            InMemoryCache.prototype.modify = function (options) {
              if (
                _helpers_js__WEBPACK_IMPORTED_MODULE_10__['hasOwn'].call(
                  options,
                  'id'
                ) &&
                !options.id
              ) {
                return false;
              }
              var store = options.optimistic ? this.optimisticData : this.data;
              try {
                ++this.txCount;
                return store.modify(options.id || 'ROOT_QUERY', options.fields);
              } finally {
                if (!--this.txCount && options.broadcast !== false) {
                  this.broadcastWatches();
                }
              }
            };
            InMemoryCache.prototype.diff = function (options) {
              return this.storeReader.diffQueryAgainstStore({
                store: options.optimistic ? this.optimisticData : this.data,
                rootId: options.id || 'ROOT_QUERY',
                query: options.query,
                variables: options.variables,
                returnPartialData: options.returnPartialData,
                config: this.config,
              });
            };
            InMemoryCache.prototype.watch = function (watch) {
              var _this = this;
              this.watches.add(watch);
              if (watch.immediate) {
                this.maybeBroadcastWatch(watch);
              }
              return function () {
                _this.watches.delete(watch);
              };
            };
            InMemoryCache.prototype.gc = function () {
              return this.optimisticData.gc();
            };
            InMemoryCache.prototype.retain = function (rootId, optimistic) {
              return (optimistic ? this.optimisticData : this.data).retain(
                rootId
              );
            };
            InMemoryCache.prototype.release = function (rootId, optimistic) {
              return (optimistic ? this.optimisticData : this.data).release(
                rootId
              );
            };
            InMemoryCache.prototype.identify = function (object) {
              return Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__['isReference']
              )(object)
                ? object.__ref
                : this.policies.identify(object)[0];
            };
            InMemoryCache.prototype.evict = function (options) {
              if (!options.id) {
                if (
                  _helpers_js__WEBPACK_IMPORTED_MODULE_10__['hasOwn'].call(
                    options,
                    'id'
                  )
                ) {
                  return false;
                }
                options = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    options
                  ),
                  { id: 'ROOT_QUERY' }
                );
              }
              try {
                ++this.txCount;
                return this.optimisticData.evict(options);
              } finally {
                if (!--this.txCount && options.broadcast !== false) {
                  this.broadcastWatches();
                }
              }
            };
            InMemoryCache.prototype.reset = function () {
              this.data.clear();
              this.optimisticData = this.data;
              this.broadcastWatches();
              return Promise.resolve();
            };
            InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
              var newOptimisticData = this.optimisticData.removeLayer(
                idToRemove
              );
              if (newOptimisticData !== this.optimisticData) {
                this.optimisticData = newOptimisticData;
                this.broadcastWatches();
              }
            };
            InMemoryCache.prototype.performTransaction = function (
              transaction,
              optimisticId
            ) {
              var _this = this;
              var perform = function (layer) {
                var _a = _this,
                  data = _a.data,
                  optimisticData = _a.optimisticData;
                ++_this.txCount;
                if (layer) {
                  _this.data = _this.optimisticData = layer;
                }
                try {
                  transaction(_this);
                } finally {
                  --_this.txCount;
                  _this.data = data;
                  _this.optimisticData = optimisticData;
                }
              };
              if (typeof optimisticId === 'string') {
                this.optimisticData = this.optimisticData.addLayer(
                  optimisticId,
                  perform
                );
              } else if (optimisticId === null) {
                perform(this.data);
              } else {
                perform();
              }
              this.broadcastWatches();
            };
            InMemoryCache.prototype.transformDocument = function (document) {
              if (this.addTypename) {
                var result = this.typenameDocumentCache.get(document);
                if (!result) {
                  result = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'addTypenameToDocument'
                    ]
                  )(document);
                  this.typenameDocumentCache.set(document, result);
                  this.typenameDocumentCache.set(result, result);
                }
                return result;
              }
              return document;
            };
            InMemoryCache.prototype.broadcastWatches = function () {
              var _this = this;
              if (!this.txCount) {
                this.watches.forEach(function (c) {
                  return _this.maybeBroadcastWatch(c);
                });
              }
            };
            InMemoryCache.prototype.broadcastWatch = function (c) {
              this.watchDep.dirty(c);
              this.watchDep(c);
              c.callback(
                this.diff({
                  query: c.query,
                  variables: c.variables,
                  optimistic: c.optimistic,
                })
              );
            };
            return InMemoryCache;
          })(_core_cache_js__WEBPACK_IMPORTED_MODULE_3__['ApolloCache']);

          //# sourceMappingURL=inMemoryCache.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/policies.js':
        /*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/policies.js ***!
  \****************************************************************/
        /*! exports provided: defaultDataIdFromObject, Policies */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defaultDataIdFromObject',
            function () {
              return defaultDataIdFromObject;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Policies',
            function () {
              return Policies;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./helpers.js */ './node_modules/@apollo/client/cache/inmemory/helpers.js'
          );
          /* harmony import */ var _reactiveVars_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./reactiveVars.js */ './node_modules/@apollo/client/cache/inmemory/reactiveVars.js'
          );

          function argsFromFieldSpecifier(spec) {
            return spec.args !== void 0
              ? spec.args
              : spec.field
              ? Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'argumentsObjectFromField'
                  ]
                )(spec.field, spec.variables)
              : null;
          }
          var defaultDataIdFromObject = function (_a, context) {
            var __typename = _a.__typename,
              id = _a.id,
              _id = _a._id;
            if (typeof __typename === 'string') {
              if (context) {
                context.keyObject =
                  id !== void 0
                    ? { id: id }
                    : _id !== void 0
                    ? { _id: _id }
                    : void 0;
              }
              if (id === void 0) id = _id;
              if (id !== void 0) {
                return (
                  __typename +
                  ':' +
                  (typeof id === 'number' || typeof id === 'string'
                    ? id
                    : JSON.stringify(id))
                );
              }
            }
          };
          var nullKeyFieldsFn = function () {
            return void 0;
          };
          var simpleKeyArgsFn = function (_args, context) {
            return context.fieldName;
          };
          var mergeTrueFn = function (existing, incoming, _a) {
            var mergeObjects = _a.mergeObjects;
            return mergeObjects(existing, incoming);
          };
          var mergeFalseFn = function (_, incoming) {
            return incoming;
          };
          var Policies = (function () {
            function Policies(config) {
              this.config = config;
              this.typePolicies = Object.create(null);
              this.rootIdsByTypename = Object.create(null);
              this.rootTypenamesById = Object.create(null);
              this.usingPossibleTypes = false;
              this.storageTrie = new optimism__WEBPACK_IMPORTED_MODULE_1__[
                'KeyTrie'
              ](true);
              this.config = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )({ dataIdFromObject: defaultDataIdFromObject }, config);
              this.cache = this.config.cache;
              this.setRootTypename('Query');
              this.setRootTypename('Mutation');
              this.setRootTypename('Subscription');
              if (config.possibleTypes) {
                this.addPossibleTypes(config.possibleTypes);
              }
              if (config.typePolicies) {
                this.addTypePolicies(config.typePolicies);
              }
            }
            Policies.prototype.identify = function (
              object,
              selectionSet,
              fragmentMap
            ) {
              var typename =
                selectionSet && fragmentMap
                  ? Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getTypenameFromResult'
                      ]
                    )(object, selectionSet, fragmentMap)
                  : object.__typename;
              if (typename) {
                var rootId = this.rootIdsByTypename[typename];
                if ('string' === typeof rootId) return [rootId];
              }
              var context = {
                typename: typename,
                selectionSet: selectionSet,
                fragmentMap: fragmentMap,
              };
              var id;
              var policy = this.getTypePolicy(typename, false);
              var keyFn =
                (policy && policy.keyFn) || this.config.dataIdFromObject;
              while (keyFn) {
                var specifierOrId = keyFn(object, context);
                if (Array.isArray(specifierOrId)) {
                  keyFn = keyFieldsFnFromSpecifier(specifierOrId);
                } else {
                  id = specifierOrId;
                  break;
                }
              }
              id = id && String(id);
              return context.keyObject ? [id, context.keyObject] : [id];
            };
            Policies.prototype.addTypePolicies = function (typePolicies) {
              var _this = this;
              Object.keys(typePolicies).forEach(function (typename) {
                var existing = _this.getTypePolicy(typename, true);
                var incoming = typePolicies[typename];
                var keyFields = incoming.keyFields,
                  fields = incoming.fields;
                if (incoming.queryType)
                  _this.setRootTypename('Query', typename);
                if (incoming.mutationType)
                  _this.setRootTypename('Mutation', typename);
                if (incoming.subscriptionType)
                  _this.setRootTypename('Subscription', typename);
                existing.keyFn =
                  keyFields === false
                    ? nullKeyFieldsFn
                    : Array.isArray(keyFields)
                    ? keyFieldsFnFromSpecifier(keyFields)
                    : typeof keyFields === 'function'
                    ? keyFields
                    : existing.keyFn;
                if (fields) {
                  Object.keys(fields).forEach(function (fieldName) {
                    var existing = _this.getFieldPolicy(
                      typename,
                      fieldName,
                      true
                    );
                    var incoming = fields[fieldName];
                    if (typeof incoming === 'function') {
                      existing.read = incoming;
                    } else {
                      var keyArgs = incoming.keyArgs,
                        read = incoming.read,
                        merge = incoming.merge;
                      existing.keyFn =
                        keyArgs === false
                          ? simpleKeyArgsFn
                          : Array.isArray(keyArgs)
                          ? keyArgsFnFromSpecifier(keyArgs)
                          : typeof keyArgs === 'function'
                          ? keyArgs
                          : existing.keyFn;
                      if (typeof read === 'function') existing.read = read;
                      existing.merge =
                        typeof merge === 'function'
                          ? merge
                          : merge === true
                          ? mergeTrueFn
                          : merge === false
                          ? mergeFalseFn
                          : existing.merge;
                    }
                    if (existing.read && existing.merge) {
                      existing.keyFn = existing.keyFn || simpleKeyArgsFn;
                    }
                  });
                }
              });
            };
            Policies.prototype.setRootTypename = function (which, typename) {
              if (typename === void 0) {
                typename = which;
              }
              var rootId = 'ROOT_' + which.toUpperCase();
              var old = this.rootTypenamesById[rootId];
              if (typename !== old) {
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                    )(
                      !old || old === which,
                      'Cannot change root ' +
                        which +
                        ' __typename more than once'
                    );
                if (old) delete this.rootIdsByTypename[old];
                this.rootIdsByTypename[typename] = rootId;
                this.rootTypenamesById[rootId] = typename;
              }
            };
            Policies.prototype.addPossibleTypes = function (possibleTypes) {
              var _this = this;
              this.usingPossibleTypes = true;
              Object.keys(possibleTypes).forEach(function (supertype) {
                var subtypeSet = _this.getSubtypeSet(supertype, true);
                possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);
              });
            };
            Policies.prototype.getTypePolicy = function (
              typename,
              createIfMissing
            ) {
              if (typename) {
                return (
                  this.typePolicies[typename] ||
                  (createIfMissing &&
                    (this.typePolicies[typename] = Object.create(null)))
                );
              }
            };
            Policies.prototype.getSubtypeSet = function (
              supertype,
              createIfMissing
            ) {
              var policy = this.getTypePolicy(supertype, createIfMissing);
              if (policy) {
                return (
                  policy.subtypes ||
                  (createIfMissing ? (policy.subtypes = new Set()) : void 0)
                );
              }
            };
            Policies.prototype.getFieldPolicy = function (
              typename,
              fieldName,
              createIfMissing
            ) {
              var typePolicy = this.getTypePolicy(typename, createIfMissing);
              if (typePolicy) {
                var fieldPolicies =
                  typePolicy.fields ||
                  (createIfMissing &&
                    (typePolicy.fields = Object.create(null)));
                if (fieldPolicies) {
                  return (
                    fieldPolicies[fieldName] ||
                    (createIfMissing &&
                      (fieldPolicies[fieldName] = Object.create(null)))
                  );
                }
              }
            };
            Policies.prototype.fragmentMatches = function (fragment, typename) {
              var _this = this;
              if (!fragment.typeCondition) return true;
              if (!typename) return false;
              var supertype = fragment.typeCondition.name.value;
              if (typename === supertype) return true;
              if (this.usingPossibleTypes) {
                var workQueue_1 = [this.getSubtypeSet(supertype, false)];
                for (var i = 0; i < workQueue_1.length; ++i) {
                  var subtypes = workQueue_1[i];
                  if (subtypes) {
                    if (subtypes.has(typename)) return true;
                    subtypes.forEach(function (subtype) {
                      var subsubtypes = _this.getSubtypeSet(subtype, false);
                      if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {
                        workQueue_1.push(subsubtypes);
                      }
                    });
                  }
                }
              }
              return false;
            };
            Policies.prototype.getStoreFieldName = function (fieldSpec) {
              var typename = fieldSpec.typename,
                fieldName = fieldSpec.fieldName;
              var policy = this.getFieldPolicy(typename, fieldName, false);
              var storeFieldName;
              var keyFn = policy && policy.keyFn;
              if (keyFn && typename) {
                var context = {
                  typename: typename,
                  fieldName: fieldName,
                  field: fieldSpec.field || null,
                  variables: fieldSpec.variables,
                };
                var args = argsFromFieldSpecifier(fieldSpec);
                while (keyFn) {
                  var specifierOrString = keyFn(args, context);
                  if (Array.isArray(specifierOrString)) {
                    keyFn = keyArgsFnFromSpecifier(specifierOrString);
                  } else {
                    storeFieldName = specifierOrString || fieldName;
                    break;
                  }
                }
              }
              if (storeFieldName === void 0) {
                storeFieldName = fieldSpec.field
                  ? Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'storeKeyNameFromField'
                      ]
                    )(fieldSpec.field, fieldSpec.variables)
                  : Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getStoreKeyName'
                      ]
                    )(fieldName, argsFromFieldSpecifier(fieldSpec));
              }
              return fieldName ===
                Object(
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                    'fieldNameFromStoreName'
                  ]
                )(storeFieldName)
                ? storeFieldName
                : fieldName + ':' + storeFieldName;
            };
            Policies.prototype.readField = function (options, context) {
              var objectOrReference = options.from;
              if (!objectOrReference) return;
              var nameOrField = options.field || options.fieldName;
              if (!nameOrField) return;
              if (options.typename === void 0) {
                var typename = context.store.getFieldValue(
                  objectOrReference,
                  '__typename'
                );
                if (typename) options.typename = typename;
              }
              var storeFieldName = this.getStoreFieldName(options);
              var fieldName = Object(
                _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                  'fieldNameFromStoreName'
                ]
              )(storeFieldName);
              var existing = context.store.getFieldValue(
                objectOrReference,
                storeFieldName
              );
              var policy = this.getFieldPolicy(
                options.typename,
                fieldName,
                false
              );
              var read = policy && policy.read;
              if (read) {
                var readOptions = makeFieldFunctionOptions(
                  this,
                  objectOrReference,
                  options,
                  context,
                  this.storageTrie.lookup(
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'isReference'
                      ]
                    )(objectOrReference)
                      ? objectOrReference.__ref
                      : objectOrReference,
                    storeFieldName
                  )
                );
                return _reactiveVars_js__WEBPACK_IMPORTED_MODULE_5__[
                  'cacheSlot'
                ].withValue(this.cache, read, [existing, readOptions]);
              }
              return existing;
            };
            Policies.prototype.hasMergeFunction = function (
              typename,
              fieldName
            ) {
              var policy = this.getFieldPolicy(typename, fieldName, false);
              return !!(policy && policy.merge);
            };
            Policies.prototype.applyMerges = function (
              existing,
              incoming,
              context,
              storageKeys
            ) {
              var _this = this;
              if (
                Object(
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                    'isFieldValueToBeMerged'
                  ]
                )(incoming)
              ) {
                var field = incoming.__field;
                var fieldName = field.name.value;
                var merge = this.getFieldPolicy(
                  incoming.__typename,
                  fieldName,
                  false
                ).merge;
                var storage = storageKeys
                  ? this.storageTrie.lookupArray(storageKeys)
                  : null;
                incoming = merge(
                  existing,
                  incoming.__value,
                  makeFieldFunctionOptions(
                    this,
                    void 0,
                    {
                      typename: incoming.__typename,
                      fieldName: fieldName,
                      field: field,
                      variables: context.variables,
                    },
                    context,
                    storage
                  )
                );
              }
              if (Array.isArray(incoming)) {
                return incoming.map(function (item) {
                  return _this.applyMerges(void 0, item, context);
                });
              }
              if (
                Object(
                  _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                    'storeValueIsStoreObject'
                  ]
                )(incoming)
              ) {
                var e_1 = existing;
                var i_1 = incoming;
                var firstStorageKey_1 = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'isReference'
                  ]
                )(e_1)
                  ? e_1.__ref
                  : typeof e_1 === 'object' && e_1;
                var newFields_1;
                Object.keys(i_1).forEach(function (storeFieldName) {
                  var incomingValue = i_1[storeFieldName];
                  var appliedValue = _this.applyMerges(
                    context.store.getFieldValue(e_1, storeFieldName),
                    incomingValue,
                    context,
                    firstStorageKey_1
                      ? [firstStorageKey_1, storeFieldName]
                      : void 0
                  );
                  if (appliedValue !== incomingValue) {
                    newFields_1 = newFields_1 || Object.create(null);
                    newFields_1[storeFieldName] = appliedValue;
                  }
                });
                if (newFields_1) {
                  return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      i_1
                    ),
                    newFields_1
                  );
                }
              }
              return incoming;
            };
            return Policies;
          })();

          function makeFieldFunctionOptions(
            policies,
            objectOrReference,
            fieldSpec,
            context,
            storage
          ) {
            var storeFieldName = policies.getStoreFieldName(fieldSpec);
            var fieldName = Object(
              _helpers_js__WEBPACK_IMPORTED_MODULE_4__['fieldNameFromStoreName']
            )(storeFieldName);
            var variables = fieldSpec.variables || context.variables;
            var _a = context.store,
              getFieldValue = _a.getFieldValue,
              toReference = _a.toReference,
              canRead = _a.canRead;
            return {
              args: argsFromFieldSpecifier(fieldSpec),
              field: fieldSpec.field || null,
              fieldName: fieldName,
              storeFieldName: storeFieldName,
              variables: variables,
              isReference:
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isReference'],
              toReference: toReference,
              storage: storage,
              cache: policies.cache,
              canRead: canRead,
              readField: function (fieldNameOrOptions, from) {
                var options =
                  typeof fieldNameOrOptions === 'string'
                    ? {
                        fieldName: fieldNameOrOptions,
                        from: from,
                      }
                    : Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        fieldNameOrOptions
                      );
                if (void 0 === options.from) {
                  options.from = objectOrReference;
                }
                if (void 0 === options.variables) {
                  options.variables = variables;
                }
                return policies.readField(options, context);
              },
              mergeObjects: function (existing, incoming) {
                if (Array.isArray(existing) || Array.isArray(incoming)) {
                  throw false
                    ? undefined
                    : new ts_invariant__WEBPACK_IMPORTED_MODULE_2__[
                        'InvariantError'
                      ]('Cannot automatically merge arrays');
                }
                if (
                  existing &&
                  typeof existing === 'object' &&
                  incoming &&
                  typeof incoming === 'object'
                ) {
                  var eType = getFieldValue(existing, '__typename');
                  var iType = getFieldValue(incoming, '__typename');
                  var typesDiffer = eType && iType && eType !== iType;
                  var applied = policies.applyMerges(
                    typesDiffer ? void 0 : existing,
                    incoming,
                    context
                  );
                  if (
                    typesDiffer ||
                    !Object(
                      _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                        'storeValueIsStoreObject'
                      ]
                    )(existing) ||
                    !Object(
                      _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                        'storeValueIsStoreObject'
                      ]
                    )(applied)
                  ) {
                    return applied;
                  }
                  return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      existing
                    ),
                    applied
                  );
                }
                return incoming;
              },
            };
          }
          function keyArgsFnFromSpecifier(specifier) {
            return function (args, context) {
              return args
                ? context.fieldName +
                    ':' +
                    JSON.stringify(computeKeyObject(args, specifier))
                : context.fieldName;
            };
          }
          function keyFieldsFnFromSpecifier(specifier) {
            var trie = new optimism__WEBPACK_IMPORTED_MODULE_1__['KeyTrie'](
              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['canUseWeakMap']
            );
            return function (object, context) {
              var aliasMap;
              if (context.selectionSet && context.fragmentMap) {
                var info = trie.lookupArray([
                  context.selectionSet,
                  context.fragmentMap,
                ]);
                aliasMap =
                  info.aliasMap ||
                  (info.aliasMap = makeAliasMap(
                    context.selectionSet,
                    context.fragmentMap
                  ));
              }
              var keyObject = (context.keyObject = computeKeyObject(
                object,
                specifier,
                aliasMap
              ));
              return context.typename + ':' + JSON.stringify(keyObject);
            };
          }
          function makeAliasMap(selectionSet, fragmentMap) {
            var map = Object.create(null);
            var workQueue = new Set([selectionSet]);
            workQueue.forEach(function (selectionSet) {
              selectionSet.selections.forEach(function (selection) {
                if (
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isField']
                  )(selection)
                ) {
                  if (selection.alias) {
                    var responseKey = selection.alias.value;
                    var storeKey = selection.name.value;
                    if (storeKey !== responseKey) {
                      var aliases =
                        map.aliases || (map.aliases = Object.create(null));
                      aliases[storeKey] = responseKey;
                    }
                  }
                  if (selection.selectionSet) {
                    var subsets =
                      map.subsets || (map.subsets = Object.create(null));
                    subsets[selection.name.value] = makeAliasMap(
                      selection.selectionSet,
                      fragmentMap
                    );
                  }
                } else {
                  var fragment = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'getFragmentFromSelection'
                    ]
                  )(selection, fragmentMap);
                  if (fragment) {
                    workQueue.add(fragment.selectionSet);
                  }
                }
              });
            });
            return map;
          }
          function computeKeyObject(response, specifier, aliasMap) {
            var keyObj = Object.create(null);
            var prevKey;
            specifier.forEach(function (s) {
              if (Array.isArray(s)) {
                if (typeof prevKey === 'string') {
                  var subsets = aliasMap && aliasMap.subsets;
                  var subset = subsets && subsets[prevKey];
                  keyObj[prevKey] = computeKeyObject(
                    response[prevKey],
                    s,
                    subset
                  );
                }
              } else {
                var aliases = aliasMap && aliasMap.aliases;
                var responseName = (aliases && aliases[s]) || s;
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                    )(
                      _helpers_js__WEBPACK_IMPORTED_MODULE_4__['hasOwn'].call(
                        response,
                        responseName
                      ),
                      "Missing field '" +
                        responseName +
                        "' while computing key fields"
                    );
                keyObj[(prevKey = s)] = response[responseName];
              }
            });
            return keyObj;
          }
          //# sourceMappingURL=policies.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/reactiveVars.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/reactiveVars.js ***!
  \********************************************************************/
        /*! exports provided: cacheSlot, makeVar */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'cacheSlot',
            function () {
              return cacheSlot;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'makeVar',
            function () {
              return makeVar;
            }
          );
          /* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! @wry/context */ './node_modules/@wry/context/lib/context.esm.js'
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );

          var varDep = Object(optimism__WEBPACK_IMPORTED_MODULE_1__['dep'])();
          var cacheSlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__[
            'Slot'
          ]();
          function makeVar(value) {
            var caches = new Set();
            return function rv(newValue) {
              if (arguments.length > 0) {
                if (value !== newValue) {
                  value = newValue;
                  varDep.dirty(rv);
                  caches.forEach(broadcast);
                }
              } else {
                var cache = cacheSlot.getValue();
                if (cache) caches.add(cache);
                varDep(rv);
              }
              return value;
            };
          }
          function broadcast(cache) {
            if (cache.broadcastWatches) {
              cache.broadcastWatches();
            }
          }
          //# sourceMappingURL=reactiveVars.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/readFromStore.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/readFromStore.js ***!
  \*********************************************************************/
        /*! exports provided: StoreReader */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'StoreReader',
            function () {
              return StoreReader;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! optimism */ './node_modules/optimism/lib/bundle.esm.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _entityStore_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./entityStore.js */ './node_modules/@apollo/client/cache/inmemory/entityStore.js'
          );
          /* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./helpers.js */ './node_modules/@apollo/client/cache/inmemory/helpers.js'
          );
          /* harmony import */ var _core_types_common_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ../core/types/common.js */ './node_modules/@apollo/client/cache/core/types/common.js'
          );

          function missingFromInvariant(err, context) {
            return new _core_types_common_js__WEBPACK_IMPORTED_MODULE_6__[
              'MissingFieldError'
            ](
              err.message,
              context.path.slice(),
              context.query,
              context.variables
            );
          }
          var StoreReader = (function () {
            function StoreReader(config) {
              var _this = this;
              this.config = config;
              this.executeSelectionSet = Object(
                optimism__WEBPACK_IMPORTED_MODULE_1__['wrap']
              )(
                function (options) {
                  return _this.execSelectionSetImpl(options);
                },
                {
                  keyArgs: function (options) {
                    return [
                      options.selectionSet,
                      options.objectOrReference,
                      options.context,
                    ];
                  },
                  makeCacheKey: function (selectionSet, parent, context) {
                    if (
                      Object(
                        _entityStore_js__WEBPACK_IMPORTED_MODULE_4__[
                          'supportsResultCaching'
                        ]
                      )(context.store)
                    ) {
                      return context.store.makeCacheKey(
                        selectionSet,
                        Object(
                          _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                            'isReference'
                          ]
                        )(parent)
                          ? parent.__ref
                          : parent,
                        context.varString
                      );
                    }
                  },
                }
              );
              this.knownResults = new WeakMap();
              this.executeSubSelectedArray = Object(
                optimism__WEBPACK_IMPORTED_MODULE_1__['wrap']
              )(
                function (options) {
                  return _this.execSubSelectedArrayImpl(options);
                },
                {
                  makeCacheKey: function (_a) {
                    var field = _a.field,
                      array = _a.array,
                      context = _a.context;
                    if (
                      Object(
                        _entityStore_js__WEBPACK_IMPORTED_MODULE_4__[
                          'supportsResultCaching'
                        ]
                      )(context.store)
                    ) {
                      return context.store.makeCacheKey(
                        field,
                        array,
                        context.varString
                      );
                    }
                  },
                }
              );
              this.config = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )({ addTypename: true }, config);
            }
            StoreReader.prototype.readQueryFromStore = function (options) {
              return this.diffQueryAgainstStore(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    options
                  ),
                  { returnPartialData: false }
                )
              ).result;
            };
            StoreReader.prototype.diffQueryAgainstStore = function (_a) {
              var store = _a.store,
                query = _a.query,
                _b = _a.rootId,
                rootId = _b === void 0 ? 'ROOT_QUERY' : _b,
                variables = _a.variables,
                _c = _a.returnPartialData,
                returnPartialData = _c === void 0 ? true : _c;
              var policies = this.config.cache.policies;
              variables = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'getDefaultValues'
                    ]
                  )(
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getQueryDefinition'
                      ]
                    )(query)
                  )
                ),
                variables
              );
              var execResult = this.executeSelectionSet({
                selectionSet: Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'getMainDefinition'
                  ]
                )(query).selectionSet,
                objectOrReference: Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'makeReference'
                  ]
                )(rootId),
                context: {
                  store: store,
                  query: query,
                  policies: policies,
                  variables: variables,
                  varString: JSON.stringify(variables),
                  fragmentMap: Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'createFragmentMap'
                    ]
                  )(
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getFragmentDefinitions'
                      ]
                    )(query)
                  ),
                  path: [],
                },
              });
              var hasMissingFields =
                execResult.missing && execResult.missing.length > 0;
              if (hasMissingFields && !returnPartialData) {
                throw execResult.missing[0];
              }
              return {
                result: execResult.result,
                missing: execResult.missing,
                complete: !hasMissingFields,
              };
            };
            StoreReader.prototype.isFresh = function (
              result,
              parent,
              selectionSet,
              context
            ) {
              if (
                Object(
                  _entityStore_js__WEBPACK_IMPORTED_MODULE_4__[
                    'supportsResultCaching'
                  ]
                )(context.store) &&
                this.knownResults.get(result) === selectionSet
              ) {
                var latest = this.executeSelectionSet.peek(
                  selectionSet,
                  parent,
                  context
                );
                if (latest && result === latest.result) {
                  return true;
                }
              }
              return false;
            };
            StoreReader.prototype.execSelectionSetImpl = function (_a) {
              var _this = this;
              var selectionSet = _a.selectionSet,
                objectOrReference = _a.objectOrReference,
                context = _a.context;
              if (
                Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'isReference'
                  ]
                )(objectOrReference) &&
                !context.policies.rootTypenamesById[objectOrReference.__ref] &&
                !context.store.has(objectOrReference.__ref)
              ) {
                return {
                  result: {},
                  missing: [
                    missingFromInvariant(
                      false
                        ? undefined
                        : new ts_invariant__WEBPACK_IMPORTED_MODULE_2__[
                            'InvariantError'
                          ](
                            'Dangling reference to missing ' +
                              objectOrReference.__ref +
                              ' object'
                          ),
                      context
                    ),
                  ],
                };
              }
              var fragmentMap = context.fragmentMap,
                variables = context.variables,
                policies = context.policies,
                store = context.store;
              var objectsToMerge = [];
              var finalResult = { result: null };
              var typename = store.getFieldValue(
                objectOrReference,
                '__typename'
              );
              if (
                this.config.addTypename &&
                typeof typename === 'string' &&
                !policies.rootIdsByTypename[typename]
              ) {
                objectsToMerge.push({ __typename: typename });
              }
              function getMissing() {
                return finalResult.missing || (finalResult.missing = []);
              }
              function handleMissing(result) {
                var _a;
                if (result.missing)
                  (_a = getMissing()).push.apply(_a, result.missing);
                return result.result;
              }
              var workSet = new Set(selectionSet.selections);
              workSet.forEach(function (selection) {
                var _a;
                if (
                  !Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'shouldInclude'
                    ]
                  )(selection, variables)
                )
                  return;
                if (
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isField']
                  )(selection)
                ) {
                  var fieldValue = policies.readField(
                    {
                      fieldName: selection.name.value,
                      field: selection,
                      variables: context.variables,
                      from: objectOrReference,
                    },
                    context
                  );
                  var resultName = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'resultKeyNameFromField'
                    ]
                  )(selection);
                  context.path.push(resultName);
                  if (fieldValue === void 0) {
                    if (
                      !_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'addTypenameToDocument'
                      ].added(selection)
                    ) {
                      getMissing().push(
                        missingFromInvariant(
                          false
                            ? undefined
                            : new ts_invariant__WEBPACK_IMPORTED_MODULE_2__[
                                'InvariantError'
                              ](
                                "Can't find field '" +
                                  selection.name.value +
                                  "' on " +
                                  (Object(
                                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                      'isReference'
                                    ]
                                  )(objectOrReference)
                                    ? objectOrReference.__ref + ' object'
                                    : 'object ' +
                                      JSON.stringify(
                                        objectOrReference,
                                        null,
                                        2
                                      ))
                              ),
                          context
                        )
                      );
                    }
                  } else if (Array.isArray(fieldValue)) {
                    fieldValue = handleMissing(
                      _this.executeSubSelectedArray({
                        field: selection,
                        array: fieldValue,
                        context: context,
                      })
                    );
                  } else if (!selection.selectionSet) {
                    if (true) {
                      assertSelectionSetForIdValue(
                        context.store,
                        selection,
                        fieldValue
                      );
                      Object(
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                          'maybeDeepFreeze'
                        ]
                      )(fieldValue);
                    }
                  } else if (fieldValue != null) {
                    fieldValue = handleMissing(
                      _this.executeSelectionSet({
                        selectionSet: selection.selectionSet,
                        objectOrReference: fieldValue,
                        context: context,
                      })
                    );
                  }
                  if (fieldValue !== void 0) {
                    objectsToMerge.push(
                      ((_a = {}), (_a[resultName] = fieldValue), _a)
                    );
                  }
                  Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                  )(context.path.pop() === resultName);
                } else {
                  var fragment = void 0;
                  if (
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'isInlineFragment'
                      ]
                    )(selection)
                  ) {
                    fragment = selection;
                  } else {
                    false
                      ? undefined
                      : Object(
                          ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                        )(
                          (fragment = fragmentMap[selection.name.value]),
                          'No fragment named ' + selection.name.value
                        );
                  }
                  if (policies.fragmentMatches(fragment, typename)) {
                    fragment.selectionSet.selections.forEach(
                      workSet.add,
                      workSet
                    );
                  }
                }
              });
              finalResult.result = Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mergeDeepArray'
                ]
              )(objectsToMerge);
              if (true) {
                Object.freeze(finalResult.result);
              }
              this.knownResults.set(finalResult.result, selectionSet);
              return finalResult;
            };
            StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {
              var _this = this;
              var field = _a.field,
                array = _a.array,
                context = _a.context;
              var missing;
              function handleMissing(childResult, i) {
                if (childResult.missing) {
                  missing = missing || [];
                  missing.push.apply(missing, childResult.missing);
                }
                Object(ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant'])(
                  context.path.pop() === i
                );
                return childResult.result;
              }
              if (field.selectionSet) {
                array = array.filter(context.store.canRead);
              }
              array = array.map(function (item, i) {
                if (item === null) {
                  return null;
                }
                context.path.push(i);
                if (Array.isArray(item)) {
                  return handleMissing(
                    _this.executeSubSelectedArray({
                      field: field,
                      array: item,
                      context: context,
                    }),
                    i
                  );
                }
                if (field.selectionSet) {
                  return handleMissing(
                    _this.executeSelectionSet({
                      selectionSet: field.selectionSet,
                      objectOrReference: item,
                      context: context,
                    }),
                    i
                  );
                }
                if (true) {
                  assertSelectionSetForIdValue(context.store, field, item);
                }
                Object(ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant'])(
                  context.path.pop() === i
                );
                return item;
              });
              if (true) {
                Object.freeze(array);
              }
              return { result: array, missing: missing };
            };
            return StoreReader;
          })();

          function assertSelectionSetForIdValue(store, field, fieldValue) {
            if (!field.selectionSet) {
              var workSet_1 = new Set([fieldValue]);
              workSet_1.forEach(function (value) {
                if (value && typeof value === 'object') {
                  false
                    ? undefined
                    : Object(
                        ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                      )(
                        !Object(
                          _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                            'isReference'
                          ]
                        )(value),
                        'Missing selection set for object of type ' +
                          Object(
                            _helpers_js__WEBPACK_IMPORTED_MODULE_5__[
                              'getTypenameFromStoreObject'
                            ]
                          )(store, value) +
                          ' returned for query field ' +
                          field.name.value
                      );
                  Object.values(value).forEach(workSet_1.add, workSet_1);
                }
              });
            }
          }
          //# sourceMappingURL=readFromStore.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/types.js':
        /*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/types.js ***!
  \*************************************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          //# sourceMappingURL=types.js.map
          /***/
        },

      /***/ './node_modules/@apollo/client/cache/inmemory/writeToStore.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/cache/inmemory/writeToStore.js ***!
  \********************************************************************/
        /*! exports provided: StoreWriter */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'StoreWriter',
            function () {
              return StoreWriter;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! @wry/equality */ './node_modules/@wry/equality/lib/equality.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./helpers.js */ './node_modules/@apollo/client/cache/inmemory/helpers.js'
          );

          var StoreWriter = (function () {
            function StoreWriter(cache, reader) {
              this.cache = cache;
              this.reader = reader;
            }
            StoreWriter.prototype.writeToStore = function (_a) {
              var query = _a.query,
                result = _a.result,
                dataId = _a.dataId,
                store = _a.store,
                variables = _a.variables;
              var operationDefinition = Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                  'getOperationDefinition'
                ]
              )(query);
              var merger = Object(
                _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                  'makeProcessedFieldsMerger'
                ]
              )();
              variables = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'getDefaultValues'
                    ]
                  )(operationDefinition)
                ),
                variables
              );
              var objOrRef = this.processSelectionSet({
                result: result || Object.create(null),
                dataId: dataId,
                selectionSet: operationDefinition.selectionSet,
                context: {
                  store: store,
                  written: Object.create(null),
                  merge: function (existing, incoming) {
                    return merger.merge(existing, incoming);
                  },
                  variables: variables,
                  varString: JSON.stringify(variables),
                  fragmentMap: Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'createFragmentMap'
                    ]
                  )(
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getFragmentDefinitions'
                      ]
                    )(query)
                  ),
                },
              });
              var ref = Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isReference']
              )(objOrRef)
                ? objOrRef
                : (dataId &&
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'makeReference'
                      ]
                    )(dataId)) ||
                  void 0;
              if (ref) {
                store.retain(ref.__ref);
              }
              return ref;
            };
            StoreWriter.prototype.processSelectionSet = function (_a) {
              var _this = this;
              var dataId = _a.dataId,
                result = _a.result,
                selectionSet = _a.selectionSet,
                context = _a.context,
                _b = _a.out,
                out =
                  _b === void 0
                    ? {
                        shouldApplyMerges: false,
                      }
                    : _b;
              var policies = this.cache.policies;
              var _c = policies.identify(
                  result,
                  selectionSet,
                  context.fragmentMap
                ),
                id = _c[0],
                keyObject = _c[1];
              dataId = dataId || id;
              if ('string' === typeof dataId) {
                var sets =
                  context.written[dataId] || (context.written[dataId] = []);
                var ref = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'makeReference'
                  ]
                )(dataId);
                if (sets.indexOf(selectionSet) >= 0) return ref;
                sets.push(selectionSet);
                if (
                  this.reader &&
                  this.reader.isFresh(result, ref, selectionSet, context)
                ) {
                  return ref;
                }
              }
              var mergedFields = Object.create(null);
              if (keyObject) {
                mergedFields = context.merge(mergedFields, keyObject);
              }
              var typename =
                (dataId && policies.rootTypenamesById[dataId]) ||
                Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'getTypenameFromResult'
                  ]
                )(result, selectionSet, context.fragmentMap) ||
                (dataId && context.store.get(dataId, '__typename'));
              if ('string' === typeof typename) {
                mergedFields.__typename = typename;
              }
              var workSet = new Set(selectionSet.selections);
              workSet.forEach(function (selection) {
                var _a;
                if (
                  !Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'shouldInclude'
                    ]
                  )(selection, context.variables)
                )
                  return;
                if (
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isField']
                  )(selection)
                ) {
                  var resultFieldKey = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'resultKeyNameFromField'
                    ]
                  )(selection);
                  var value = result[resultFieldKey];
                  if (typeof value !== 'undefined') {
                    var storeFieldName = policies.getStoreFieldName({
                      typename: typename,
                      fieldName: selection.name.value,
                      field: selection,
                      variables: context.variables,
                    });
                    var incomingValue = _this.processFieldValue(
                      value,
                      selection,
                      context,
                      out
                    );
                    if (
                      policies.hasMergeFunction(typename, selection.name.value)
                    ) {
                      incomingValue = {
                        __field: selection,
                        __typename: typename,
                        __value: incomingValue,
                      };
                      out.shouldApplyMerges = true;
                    }
                    mergedFields = context.merge(
                      mergedFields,
                      ((_a = {}), (_a[storeFieldName] = incomingValue), _a)
                    );
                  } else if (
                    policies.usingPossibleTypes &&
                    !Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'hasDirectives'
                      ]
                    )(['defer', 'client'], selection)
                  ) {
                    throw false
                      ? undefined
                      : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                          'InvariantError'
                        ](
                          "Missing field '" +
                            resultFieldKey +
                            "' in " +
                            JSON.stringify(result, null, 2).substring(0, 100)
                        );
                  }
                } else {
                  var fragment = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'getFragmentFromSelection'
                    ]
                  )(selection, context.fragmentMap);
                  if (
                    fragment &&
                    policies.fragmentMatches(fragment, typename)
                  ) {
                    fragment.selectionSet.selections.forEach(
                      workSet.add,
                      workSet
                    );
                  }
                }
              });
              if ('string' === typeof dataId) {
                var entityRef_1 = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'makeReference'
                  ]
                )(dataId);
                if (out.shouldApplyMerges) {
                  mergedFields = policies.applyMerges(
                    entityRef_1,
                    mergedFields,
                    context
                  );
                }
                if (true) {
                  Object.keys(mergedFields).forEach(function (storeFieldName) {
                    var fieldName = Object(
                      _helpers_js__WEBPACK_IMPORTED_MODULE_4__[
                        'fieldNameFromStoreName'
                      ]
                    )(storeFieldName);
                    if (!policies.hasMergeFunction(typename, fieldName)) {
                      warnAboutDataLoss(
                        entityRef_1,
                        mergedFields,
                        storeFieldName,
                        context.store
                      );
                    }
                  });
                }
                context.store.merge(dataId, mergedFields);
                return entityRef_1;
              }
              return mergedFields;
            };
            StoreWriter.prototype.processFieldValue = function (
              value,
              field,
              context,
              out
            ) {
              var _this = this;
              if (!field.selectionSet || value === null) {
                return false
                  ? undefined
                  : Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'cloneDeep'
                      ]
                    )(value);
              }
              if (Array.isArray(value)) {
                return value.map(function (item) {
                  return _this.processFieldValue(item, field, context, out);
                });
              }
              return this.processSelectionSet({
                result: value,
                selectionSet: field.selectionSet,
                context: context,
                out: out,
              });
            };
            return StoreWriter;
          })();

          var warnings = new Set();
          function warnAboutDataLoss(
            existingRef,
            incomingObj,
            storeFieldName,
            store
          ) {
            var getChild = function (objOrRef) {
              var child = store.getFieldValue(objOrRef, storeFieldName);
              return typeof child === 'object' && child;
            };
            var existing = getChild(existingRef);
            if (!existing) return;
            var incoming = getChild(incomingObj);
            if (!incoming) return;
            if (
              Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['isReference']
              )(existing)
            )
              return;
            if (
              Object(_wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal'])(
                existing,
                incoming
              )
            )
              return;
            if (
              Object.keys(existing).every(function (key) {
                return store.getFieldValue(incoming, key) !== void 0;
              })
            ) {
              return;
            }
            var parentType =
              store.getFieldValue(existingRef, '__typename') ||
              store.getFieldValue(incomingObj, '__typename');
            var fieldName = Object(
              _helpers_js__WEBPACK_IMPORTED_MODULE_4__['fieldNameFromStoreName']
            )(storeFieldName);
            var typeDotName = parentType + '.' + fieldName;
            if (warnings.has(typeDotName)) return;
            warnings.add(typeDotName);
            var childTypenames = [];
            if (!Array.isArray(existing) && !Array.isArray(incoming)) {
              [existing, incoming].forEach(function (child) {
                var typename = store.getFieldValue(child, '__typename');
                if (
                  typeof typename === 'string' &&
                  !childTypenames.includes(typename)
                ) {
                  childTypenames.push(typename);
                }
              });
            }
            false ||
              ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant'].warn(
                'Cache data may be lost when replacing the ' +
                  fieldName +
                  ' field of a ' +
                  parentType +
                  ' object.\n\nTo address this problem (which is not a bug in Apollo Client), ' +
                  (childTypenames.length
                    ? 'either ensure all objects of type ' +
                      childTypenames.join(' and ') +
                      ' have IDs, or '
                    : '') +
                  'define a custom merge function for the ' +
                  typeDotName +
                  ' field, so InMemoryCache can safely merge these objects:\n\n  existing: ' +
                  JSON.stringify(existing).slice(0, 1000) +
                  '\n  incoming: ' +
                  JSON.stringify(incoming).slice(0, 1000) +
                  '\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n'
              );
          }
          //# sourceMappingURL=writeToStore.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/ApolloClient.js':
        /*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/ApolloClient.js ***!
  \**********************************************************/
        /*! exports provided: ApolloClient */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloClient',
            function () {
              return ApolloClient;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../link/core/index.js */ './node_modules/@apollo/client/link/core/index.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../version.js */ './node_modules/@apollo/client/version.js'
          );
          /* harmony import */ var _link_http_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ../link/http/index.js */ './node_modules/@apollo/client/link/http/index.js'
          );
          /* harmony import */ var _QueryManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./QueryManager.js */ './node_modules/@apollo/client/core/QueryManager.js'
          );
          /* harmony import */ var _LocalState_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./LocalState.js */ './node_modules/@apollo/client/core/LocalState.js'
          );

          var hasSuggestedDevtools = false;
          var ApolloClient = (function () {
            function ApolloClient(options) {
              var _this = this;
              this.defaultOptions = {};
              this.resetStoreCallbacks = [];
              this.clearStoreCallbacks = [];
              var uri = options.uri,
                credentials = options.credentials,
                headers = options.headers,
                cache = options.cache,
                _a = options.ssrMode,
                ssrMode = _a === void 0 ? false : _a,
                _b = options.ssrForceFetchDelay,
                ssrForceFetchDelay = _b === void 0 ? 0 : _b,
                connectToDevTools = options.connectToDevTools,
                _c = options.queryDeduplication,
                queryDeduplication = _c === void 0 ? true : _c,
                defaultOptions = options.defaultOptions,
                _d = options.assumeImmutableResults,
                assumeImmutableResults = _d === void 0 ? false : _d,
                resolvers = options.resolvers,
                typeDefs = options.typeDefs,
                fragmentMatcher = options.fragmentMatcher,
                clientAwarenessName = options.name,
                clientAwarenessVersion = options.version;
              var link = options.link;
              if (!link) {
                link = uri
                  ? new _link_http_index_js__WEBPACK_IMPORTED_MODULE_5__[
                      'HttpLink'
                    ]({ uri: uri, credentials: credentials, headers: headers })
                  : _link_core_index_js__WEBPACK_IMPORTED_MODULE_2__[
                      'ApolloLink'
                    ].empty();
              }
              if (!cache) {
                throw false
                  ? undefined
                  : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                      'InvariantError'
                    ](
                      "To initialize Apollo Client, you must specify a 'cache' property " +
                        'in the options object. \n' +
                        'For more information, please visit: https://go.apollo.dev/c/docs'
                    );
              }
              this.link = link;
              this.cache = cache;
              this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
              this.queryDeduplication = queryDeduplication;
              this.defaultOptions = defaultOptions || {};
              this.typeDefs = typeDefs;
              if (ssrForceFetchDelay) {
                setTimeout(function () {
                  return (_this.disableNetworkFetches = false);
                }, ssrForceFetchDelay);
              }
              this.watchQuery = this.watchQuery.bind(this);
              this.query = this.query.bind(this);
              this.mutate = this.mutate.bind(this);
              this.resetStore = this.resetStore.bind(this);
              this.reFetchObservableQueries = this.reFetchObservableQueries.bind(
                this
              );
              var defaultConnectToDevTools =
                true &&
                typeof window !== 'undefined' &&
                !window.__APOLLO_CLIENT__;
              if (
                typeof connectToDevTools === 'undefined'
                  ? defaultConnectToDevTools
                  : connectToDevTools && typeof window !== 'undefined'
              ) {
                window.__APOLLO_CLIENT__ = this;
              }
              if (!hasSuggestedDevtools && 'development' !== 'production') {
                hasSuggestedDevtools = true;
                if (
                  typeof window !== 'undefined' &&
                  window.document &&
                  window.top === window.self
                ) {
                  if (
                    typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ ===
                    'undefined'
                  ) {
                    if (
                      window.navigator &&
                      window.navigator.userAgent &&
                      window.navigator.userAgent.indexOf('Chrome') > -1
                    ) {
                      console.debug(
                        'Download the Apollo DevTools ' +
                          'for a better development experience: ' +
                          'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm'
                      );
                    }
                  }
                }
              }
              this.version =
                _version_js__WEBPACK_IMPORTED_MODULE_4__['version'];
              this.localState = new _LocalState_js__WEBPACK_IMPORTED_MODULE_7__[
                'LocalState'
              ]({
                cache: cache,
                client: this,
                resolvers: resolvers,
                fragmentMatcher: fragmentMatcher,
              });
              this.queryManager = new _QueryManager_js__WEBPACK_IMPORTED_MODULE_6__[
                'QueryManager'
              ]({
                cache: this.cache,
                link: this.link,
                queryDeduplication: queryDeduplication,
                ssrMode: ssrMode,
                clientAwareness: {
                  name: clientAwarenessName,
                  version: clientAwarenessVersion,
                },
                localState: this.localState,
                assumeImmutableResults: assumeImmutableResults,
                onBroadcast: function () {
                  if (_this.devToolsHookCb) {
                    _this.devToolsHookCb({
                      action: {},
                      state: {
                        queries: _this.queryManager.getQueryStore(),
                        mutations: _this.queryManager.mutationStore.getStore(),
                      },
                      dataWithOptimisticResults: _this.cache.extract(true),
                    });
                  }
                },
              });
            }
            ApolloClient.prototype.stop = function () {
              this.queryManager.stop();
            };
            ApolloClient.prototype.watchQuery = function (options) {
              if (this.defaultOptions.watchQuery) {
                options = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['compact']
                )(this.defaultOptions.watchQuery, options);
              }
              if (
                this.disableNetworkFetches &&
                (options.fetchPolicy === 'network-only' ||
                  options.fetchPolicy === 'cache-and-network')
              ) {
                options = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    options
                  ),
                  { fetchPolicy: 'cache-first' }
                );
              }
              return this.queryManager.watchQuery(options);
            };
            ApolloClient.prototype.query = function (options) {
              if (this.defaultOptions.query) {
                options = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['compact']
                )(this.defaultOptions.query, options);
              }
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    options.fetchPolicy !== 'cache-and-network',
                    'The cache-and-network fetchPolicy does not work with client.query, because ' +
                      'client.query can only return a single result. Please use client.watchQuery ' +
                      'to receive multiple results from the cache and the network, or consider ' +
                      'using a different fetchPolicy, such as cache-first or network-only.'
                  );
              if (
                this.disableNetworkFetches &&
                options.fetchPolicy === 'network-only'
              ) {
                options = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    options
                  ),
                  { fetchPolicy: 'cache-first' }
                );
              }
              return this.queryManager.query(options);
            };
            ApolloClient.prototype.mutate = function (options) {
              if (this.defaultOptions.mutate) {
                options = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['compact']
                )(this.defaultOptions.mutate, options);
              }
              return this.queryManager.mutate(options);
            };
            ApolloClient.prototype.subscribe = function (options) {
              return this.queryManager.startGraphQLSubscription(options);
            };
            ApolloClient.prototype.readQuery = function (options, optimistic) {
              if (optimistic === void 0) {
                optimistic = false;
              }
              return this.cache.readQuery(options, optimistic);
            };
            ApolloClient.prototype.readFragment = function (
              options,
              optimistic
            ) {
              if (optimistic === void 0) {
                optimistic = false;
              }
              return this.cache.readFragment(options, optimistic);
            };
            ApolloClient.prototype.writeQuery = function (options) {
              this.cache.writeQuery(options);
              this.queryManager.broadcastQueries();
            };
            ApolloClient.prototype.writeFragment = function (options) {
              this.cache.writeFragment(options);
              this.queryManager.broadcastQueries();
            };
            ApolloClient.prototype.__actionHookForDevTools = function (cb) {
              this.devToolsHookCb = cb;
            };
            ApolloClient.prototype.__requestRaw = function (payload) {
              return Object(
                _link_core_index_js__WEBPACK_IMPORTED_MODULE_2__['execute']
              )(this.link, payload);
            };
            ApolloClient.prototype.resetStore = function () {
              var _this = this;
              return Promise.resolve()
                .then(function () {
                  return _this.queryManager.clearStore();
                })
                .then(function () {
                  return Promise.all(
                    _this.resetStoreCallbacks.map(function (fn) {
                      return fn();
                    })
                  );
                })
                .then(function () {
                  return _this.reFetchObservableQueries();
                });
            };
            ApolloClient.prototype.clearStore = function () {
              var _this = this;
              return Promise.resolve()
                .then(function () {
                  return _this.queryManager.clearStore();
                })
                .then(function () {
                  return Promise.all(
                    _this.clearStoreCallbacks.map(function (fn) {
                      return fn();
                    })
                  );
                });
            };
            ApolloClient.prototype.onResetStore = function (cb) {
              var _this = this;
              this.resetStoreCallbacks.push(cb);
              return function () {
                _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(
                  function (c) {
                    return c !== cb;
                  }
                );
              };
            };
            ApolloClient.prototype.onClearStore = function (cb) {
              var _this = this;
              this.clearStoreCallbacks.push(cb);
              return function () {
                _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(
                  function (c) {
                    return c !== cb;
                  }
                );
              };
            };
            ApolloClient.prototype.reFetchObservableQueries = function (
              includeStandby
            ) {
              return this.queryManager.reFetchObservableQueries(includeStandby);
            };
            ApolloClient.prototype.extract = function (optimistic) {
              return this.cache.extract(optimistic);
            };
            ApolloClient.prototype.restore = function (serializedState) {
              return this.cache.restore(serializedState);
            };
            ApolloClient.prototype.addResolvers = function (resolvers) {
              this.localState.addResolvers(resolvers);
            };
            ApolloClient.prototype.setResolvers = function (resolvers) {
              this.localState.setResolvers(resolvers);
            };
            ApolloClient.prototype.getResolvers = function () {
              return this.localState.getResolvers();
            };
            ApolloClient.prototype.setLocalStateFragmentMatcher = function (
              fragmentMatcher
            ) {
              this.localState.setFragmentMatcher(fragmentMatcher);
            };
            ApolloClient.prototype.setLink = function (newLink) {
              this.link = this.queryManager.link = newLink;
            };
            return ApolloClient;
          })();

          //# sourceMappingURL=ApolloClient.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/LocalState.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/core/LocalState.js ***!
  \********************************************************/
        /*! exports provided: LocalState */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'LocalState',
            function () {
              return LocalState;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! graphql/language/visitor */ './node_modules/graphql/language/visitor.js'
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
            graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _cache_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../cache/index.js */ './node_modules/@apollo/client/cache/index.js'
          );

          var LocalState = (function () {
            function LocalState(_a) {
              var cache = _a.cache,
                client = _a.client,
                resolvers = _a.resolvers,
                fragmentMatcher = _a.fragmentMatcher;
              this.cache = cache;
              if (client) {
                this.client = client;
              }
              if (resolvers) {
                this.addResolvers(resolvers);
              }
              if (fragmentMatcher) {
                this.setFragmentMatcher(fragmentMatcher);
              }
            }
            LocalState.prototype.addResolvers = function (resolvers) {
              var _this = this;
              this.resolvers = this.resolvers || {};
              if (Array.isArray(resolvers)) {
                resolvers.forEach(function (resolverGroup) {
                  _this.resolvers = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'mergeDeep'
                    ]
                  )(_this.resolvers, resolverGroup);
                });
              } else {
                this.resolvers = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__['mergeDeep']
                )(this.resolvers, resolvers);
              }
            };
            LocalState.prototype.setResolvers = function (resolvers) {
              this.resolvers = {};
              this.addResolvers(resolvers);
            };
            LocalState.prototype.getResolvers = function () {
              return this.resolvers || {};
            };
            LocalState.prototype.runResolvers = function (_a) {
              var document = _a.document,
                remoteResult = _a.remoteResult,
                context = _a.context,
                variables = _a.variables,
                _b = _a.onlyRunForcedResolvers,
                onlyRunForcedResolvers = _b === void 0 ? false : _b;
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_c) {
                    if (document) {
                      return [
                        2,
                        this.resolveDocument(
                          document,
                          remoteResult.data,
                          context,
                          variables,
                          this.fragmentMatcher,
                          onlyRunForcedResolvers
                        ).then(function (localResult) {
                          return Object(
                            tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                          )(
                            Object(
                              tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                            )({}, remoteResult),
                            { data: localResult.result }
                          );
                        }),
                      ];
                    }
                    return [2, remoteResult];
                  });
                }
              );
            };
            LocalState.prototype.setFragmentMatcher = function (
              fragmentMatcher
            ) {
              this.fragmentMatcher = fragmentMatcher;
            };
            LocalState.prototype.getFragmentMatcher = function () {
              return this.fragmentMatcher;
            };
            LocalState.prototype.clientQuery = function (document) {
              if (
                Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'hasDirectives'
                  ]
                )(['client'], document)
              ) {
                if (this.resolvers) {
                  return document;
                }
              }
              return null;
            };
            LocalState.prototype.serverQuery = function (document) {
              return Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                  'removeClientSetsFromDocument'
                ]
              )(document);
            };
            LocalState.prototype.prepareContext = function (context) {
              var cache = this.cache;
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  context
                ),
                {
                  cache: cache,
                  getCacheKey: function (obj) {
                    return cache.identify(obj);
                  },
                }
              );
            };
            LocalState.prototype.addExportedVariables = function (
              document,
              variables,
              context
            ) {
              if (variables === void 0) {
                variables = {};
              }
              if (context === void 0) {
                context = {};
              }
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_a) {
                    if (document) {
                      return [
                        2,
                        this.resolveDocument(
                          document,
                          this.buildRootValueFromCache(document, variables) ||
                            {},
                          this.prepareContext(context),
                          variables
                        ).then(function (data) {
                          return Object(
                            tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                          )(
                            Object(
                              tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                            )({}, variables),
                            data.exportedVariables
                          );
                        }),
                      ];
                    }
                    return [
                      2,
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        variables
                      ),
                    ];
                  });
                }
              );
            };
            LocalState.prototype.shouldForceResolvers = function (document) {
              var forceResolvers = false;
              Object(
                graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
              )(document, {
                Directive: {
                  enter: function (node) {
                    if (node.name.value === 'client' && node.arguments) {
                      forceResolvers = node.arguments.some(function (arg) {
                        return (
                          arg.name.value === 'always' &&
                          arg.value.kind === 'BooleanValue' &&
                          arg.value.value === true
                        );
                      });
                      if (forceResolvers) {
                        return graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__[
                          'BREAK'
                        ];
                      }
                    }
                  },
                },
              });
              return forceResolvers;
            };
            LocalState.prototype.buildRootValueFromCache = function (
              document,
              variables
            ) {
              return this.cache.diff({
                query: Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                    'buildQueryFromSelectionSet'
                  ]
                )(document),
                variables: variables,
                returnPartialData: true,
                optimistic: false,
              }).result;
            };
            LocalState.prototype.resolveDocument = function (
              document,
              rootValue,
              context,
              variables,
              fragmentMatcher,
              onlyRunForcedResolvers
            ) {
              if (context === void 0) {
                context = {};
              }
              if (variables === void 0) {
                variables = {};
              }
              if (fragmentMatcher === void 0) {
                fragmentMatcher = function () {
                  return true;
                };
              }
              if (onlyRunForcedResolvers === void 0) {
                onlyRunForcedResolvers = false;
              }
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  var mainDefinition,
                    fragments,
                    fragmentMap,
                    definitionOperation,
                    defaultOperationType,
                    _a,
                    cache,
                    client,
                    execContext;
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_b) {
                    mainDefinition = Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getMainDefinition'
                      ]
                    )(document);
                    fragments = Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'getFragmentDefinitions'
                      ]
                    )(document);
                    fragmentMap = Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'createFragmentMap'
                      ]
                    )(fragments);
                    definitionOperation = mainDefinition.operation;
                    defaultOperationType = definitionOperation
                      ? definitionOperation.charAt(0).toUpperCase() +
                        definitionOperation.slice(1)
                      : 'Query';
                    (_a = this), (cache = _a.cache), (client = _a.client);
                    execContext = {
                      fragmentMap: fragmentMap,
                      context: Object(
                        tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                      )(
                        Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                          {},
                          context
                        ),
                        { cache: cache, client: client }
                      ),
                      variables: variables,
                      fragmentMatcher: fragmentMatcher,
                      defaultOperationType: defaultOperationType,
                      exportedVariables: {},
                      onlyRunForcedResolvers: onlyRunForcedResolvers,
                    };
                    return [
                      2,
                      this.resolveSelectionSet(
                        mainDefinition.selectionSet,
                        rootValue,
                        execContext
                      ).then(function (result) {
                        return {
                          result: result,
                          exportedVariables: execContext.exportedVariables,
                        };
                      }),
                    ];
                  });
                }
              );
            };
            LocalState.prototype.resolveSelectionSet = function (
              selectionSet,
              rootValue,
              execContext
            ) {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  var fragmentMap, context, variables, resultsToMerge, execute;
                  var _this = this;
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_a) {
                    (fragmentMap = execContext.fragmentMap),
                      (context = execContext.context),
                      (variables = execContext.variables);
                    resultsToMerge = [rootValue];
                    execute = function (selection) {
                      return Object(
                        tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter']
                      )(_this, void 0, void 0, function () {
                        var fragment, typeCondition;
                        return Object(
                          tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                        )(this, function (_a) {
                          if (
                            !Object(
                              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                'shouldInclude'
                              ]
                            )(selection, variables)
                          ) {
                            return [2];
                          }
                          if (
                            Object(
                              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                'isField'
                              ]
                            )(selection)
                          ) {
                            return [
                              2,
                              this.resolveField(
                                selection,
                                rootValue,
                                execContext
                              ).then(function (fieldResult) {
                                var _a;
                                if (typeof fieldResult !== 'undefined') {
                                  resultsToMerge.push(
                                    ((_a = {}),
                                    (_a[
                                      Object(
                                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                          'resultKeyNameFromField'
                                        ]
                                      )(selection)
                                    ] = fieldResult),
                                    _a)
                                  );
                                }
                              }),
                            ];
                          }
                          if (
                            Object(
                              _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                'isInlineFragment'
                              ]
                            )(selection)
                          ) {
                            fragment = selection;
                          } else {
                            fragment = fragmentMap[selection.name.value];
                            false
                              ? undefined
                              : Object(
                                  ts_invariant__WEBPACK_IMPORTED_MODULE_2__[
                                    'invariant'
                                  ]
                                )(
                                  fragment,
                                  'No fragment named ' + selection.name.value
                                );
                          }
                          if (fragment && fragment.typeCondition) {
                            typeCondition = fragment.typeCondition.name.value;
                            if (
                              execContext.fragmentMatcher(
                                rootValue,
                                typeCondition,
                                context
                              )
                            ) {
                              return [
                                2,
                                this.resolveSelectionSet(
                                  fragment.selectionSet,
                                  rootValue,
                                  execContext
                                ).then(function (fragmentResult) {
                                  resultsToMerge.push(fragmentResult);
                                }),
                              ];
                            }
                          }
                          return [2];
                        });
                      });
                    };
                    return [
                      2,
                      Promise.all(selectionSet.selections.map(execute)).then(
                        function () {
                          return Object(
                            _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                              'mergeDeepArray'
                            ]
                          )(resultsToMerge);
                        }
                      ),
                    ];
                  });
                }
              );
            };
            LocalState.prototype.resolveField = function (
              field,
              rootValue,
              execContext
            ) {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  var variables,
                    fieldName,
                    aliasedFieldName,
                    aliasUsed,
                    defaultResult,
                    resultPromise,
                    resolverType,
                    resolverMap,
                    resolve;
                  var _this = this;
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_a) {
                    variables = execContext.variables;
                    fieldName = field.name.value;
                    aliasedFieldName = Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'resultKeyNameFromField'
                      ]
                    )(field);
                    aliasUsed = fieldName !== aliasedFieldName;
                    defaultResult =
                      rootValue[aliasedFieldName] || rootValue[fieldName];
                    resultPromise = Promise.resolve(defaultResult);
                    if (
                      !execContext.onlyRunForcedResolvers ||
                      this.shouldForceResolvers(field)
                    ) {
                      resolverType =
                        rootValue.__typename ||
                        execContext.defaultOperationType;
                      resolverMap =
                        this.resolvers && this.resolvers[resolverType];
                      if (resolverMap) {
                        resolve =
                          resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                        if (resolve) {
                          resultPromise = Promise.resolve(
                            _cache_index_js__WEBPACK_IMPORTED_MODULE_4__[
                              'cacheSlot'
                            ].withValue(this.cache, resolve, [
                              rootValue,
                              Object(
                                _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__[
                                  'argumentsObjectFromField'
                                ]
                              )(field, variables),
                              execContext.context,
                              {
                                field: field,
                                fragmentMap: execContext.fragmentMap,
                              },
                            ])
                          );
                        }
                      }
                    }
                    return [
                      2,
                      resultPromise.then(function (result) {
                        if (result === void 0) {
                          result = defaultResult;
                        }
                        if (field.directives) {
                          field.directives.forEach(function (directive) {
                            if (
                              directive.name.value === 'export' &&
                              directive.arguments
                            ) {
                              directive.arguments.forEach(function (arg) {
                                if (
                                  arg.name.value === 'as' &&
                                  arg.value.kind === 'StringValue'
                                ) {
                                  execContext.exportedVariables[
                                    arg.value.value
                                  ] = result;
                                }
                              });
                            }
                          });
                        }
                        if (!field.selectionSet) {
                          return result;
                        }
                        if (result == null) {
                          return result;
                        }
                        if (Array.isArray(result)) {
                          return _this.resolveSubSelectedArray(
                            field,
                            result,
                            execContext
                          );
                        }
                        if (field.selectionSet) {
                          return _this.resolveSelectionSet(
                            field.selectionSet,
                            result,
                            execContext
                          );
                        }
                      }),
                    ];
                  });
                }
              );
            };
            LocalState.prototype.resolveSubSelectedArray = function (
              field,
              result,
              execContext
            ) {
              var _this = this;
              return Promise.all(
                result.map(function (item) {
                  if (item === null) {
                    return null;
                  }
                  if (Array.isArray(item)) {
                    return _this.resolveSubSelectedArray(
                      field,
                      item,
                      execContext
                    );
                  }
                  if (field.selectionSet) {
                    return _this.resolveSelectionSet(
                      field.selectionSet,
                      item,
                      execContext
                    );
                  }
                })
              );
            };
            return LocalState;
          })();

          //# sourceMappingURL=LocalState.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/MutationStore.js':
        /*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/core/MutationStore.js ***!
  \***********************************************************/
        /*! exports provided: MutationStore */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'MutationStore',
            function () {
              return MutationStore;
            }
          );
          var MutationStore = (function () {
            function MutationStore() {
              this.store = {};
            }
            MutationStore.prototype.getStore = function () {
              return this.store;
            };
            MutationStore.prototype.get = function (mutationId) {
              return this.store[mutationId];
            };
            MutationStore.prototype.initMutation = function (
              mutationId,
              mutation,
              variables
            ) {
              this.store[mutationId] = {
                mutation: mutation,
                variables: variables || {},
                loading: true,
                error: null,
              };
            };
            MutationStore.prototype.markMutationError = function (
              mutationId,
              error
            ) {
              var mutation = this.store[mutationId];
              if (mutation) {
                mutation.loading = false;
                mutation.error = error;
              }
            };
            MutationStore.prototype.markMutationResult = function (mutationId) {
              var mutation = this.store[mutationId];
              if (mutation) {
                mutation.loading = false;
                mutation.error = null;
              }
            };
            MutationStore.prototype.reset = function () {
              this.store = {};
            };
            return MutationStore;
          })();

          //# sourceMappingURL=MutationStore.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/ObservableQuery.js':
        /*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/core/ObservableQuery.js ***!
  \*************************************************************/
        /*! exports provided: ObservableQuery */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ObservableQuery',
            function () {
              return ObservableQuery;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! @wry/equality */ './node_modules/@wry/equality/lib/equality.esm.js'
          );
          /* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./networkStatus.js */ './node_modules/@apollo/client/core/networkStatus.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _Reobserver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./Reobserver.js */ './node_modules/@apollo/client/core/Reobserver.js'
          );

          var warnedAboutUpdateQuery = false;
          var ObservableQuery = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              ObservableQuery,
              _super
            );
            function ObservableQuery(_a) {
              var queryManager = _a.queryManager,
                queryInfo = _a.queryInfo,
                options = _a.options;
              var _this =
                _super.call(this, function (observer) {
                  return _this.onSubscribe(observer);
                }) || this;
              _this.observers = new Set();
              _this.subscriptions = new Set();
              _this.observer = {
                next: function (result) {
                  if (
                    _this.lastError ||
                    _this.isDifferentFromLastResult(result)
                  ) {
                    _this.updateLastResult(result);
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                        'iterateObserversSafely'
                      ]
                    )(_this.observers, 'next', result);
                  }
                },
                error: function (error) {
                  _this.updateLastResult(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        _this.lastResult
                      ),
                      {
                        errors: error.graphQLErrors,
                        networkStatus:
                          _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                            'NetworkStatus'
                          ].error,
                        loading: false,
                      }
                    )
                  );
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'iterateObserversSafely'
                    ]
                  )(_this.observers, 'error', (_this.lastError = error));
                },
              };
              _this.isTornDown = false;
              _this.options = options;
              _this.queryId = queryManager.generateQueryId();
              var opDef = Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                  'getOperationDefinition'
                ]
              )(options.query);
              _this.queryName = opDef && opDef.name && opDef.name.value;
              _this.queryManager = queryManager;
              _this.queryInfo = queryInfo;
              return _this;
            }
            Object.defineProperty(ObservableQuery.prototype, 'variables', {
              get: function () {
                return this.options.variables;
              },
              enumerable: false,
              configurable: true,
            });
            ObservableQuery.prototype.result = function () {
              var _this = this;
              return new Promise(function (resolve, reject) {
                var observer = {
                  next: function (result) {
                    resolve(result);
                    _this.observers.delete(observer);
                    if (!_this.observers.size) {
                      _this.queryManager.removeQuery(_this.queryId);
                    }
                    setTimeout(function () {
                      subscription.unsubscribe();
                    }, 0);
                  },
                  error: reject,
                };
                var subscription = _this.subscribe(observer);
              });
            };
            ObservableQuery.prototype.getCurrentResult = function () {
              var _a = this,
                lastResult = _a.lastResult,
                lastError = _a.lastError;
              var networkStatus =
                this.queryInfo.networkStatus ||
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__['NetworkStatus']
                  .ready;
              var result = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  lastError ? { error: lastError } : lastResult
                ),
                {
                  loading: Object(
                    _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                      'isNetworkRequestInFlight'
                    ]
                  )(networkStatus),
                  networkStatus: networkStatus,
                }
              );
              if (this.isTornDown) {
                return result;
              }
              var _b = this.options.fetchPolicy,
                fetchPolicy = _b === void 0 ? 'cache-first' : _b;
              if (
                fetchPolicy === 'no-cache' ||
                fetchPolicy === 'network-only'
              ) {
                result.partial = false;
              } else if (
                !result.data ||
                !this.queryManager.transform(this.options.query)
                  .hasForcedResolvers
              ) {
                var diff = this.queryInfo.getDiff();
                result.partial = !diff.complete;
                result.data =
                  diff.complete || this.options.returnPartialData
                    ? diff.result
                    : void 0;
                if (
                  diff.complete &&
                  result.networkStatus ===
                    _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                      'NetworkStatus'
                    ].loading &&
                  (fetchPolicy === 'cache-first' ||
                    fetchPolicy === 'cache-only')
                ) {
                  result.networkStatus =
                    _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                      'NetworkStatus'
                    ].ready;
                  result.loading = false;
                }
              }
              this.updateLastResult(result);
              return result;
            };
            ObservableQuery.prototype.isDifferentFromLastResult = function (
              newResult
            ) {
              return !Object(
                _wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal']
              )(this.lastResultSnapshot, newResult);
            };
            ObservableQuery.prototype.getLastResult = function () {
              return this.lastResult;
            };
            ObservableQuery.prototype.getLastError = function () {
              return this.lastError;
            };
            ObservableQuery.prototype.resetLastResults = function () {
              delete this.lastResult;
              delete this.lastResultSnapshot;
              delete this.lastError;
              this.isTornDown = false;
            };
            ObservableQuery.prototype.resetQueryStoreErrors = function () {
              this.queryManager.resetErrors(this.queryId);
            };
            ObservableQuery.prototype.refetch = function (variables) {
              var fetchPolicy = this.options.fetchPolicy;
              if (fetchPolicy === 'cache-only') {
                return Promise.reject(
                  false
                    ? undefined
                    : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                        'InvariantError'
                      ](
                        'cache-only fetchPolicy option should not be used together with query refetch.'
                      )
                );
              }
              var reobserveOptions = {
                pollInterval: 0,
              };
              if (
                fetchPolicy !== 'no-cache' &&
                fetchPolicy !== 'cache-and-network'
              ) {
                reobserveOptions.fetchPolicy = 'network-only';
                reobserveOptions.nextFetchPolicy = fetchPolicy;
              }
              if (
                variables &&
                !Object(_wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal'])(
                  this.options.variables,
                  variables
                )
              ) {
                reobserveOptions.variables = this.options.variables = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    this.options.variables
                  ),
                  variables
                );
              }
              return this.newReobserver(false).reobserve(
                reobserveOptions,
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__['NetworkStatus']
                  .refetch
              );
            };
            ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
              var _this = this;
              var combinedOptions = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  fetchMoreOptions.query
                    ? fetchMoreOptions
                    : Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                          Object(
                            tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                          )({}, this.options),
                          fetchMoreOptions
                        ),
                        {
                          variables: Object(
                            tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                          )(
                            Object(
                              tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                            )({}, this.options.variables),
                            fetchMoreOptions.variables
                          ),
                        }
                      )
                ),
                { fetchPolicy: 'no-cache' }
              );
              var qid = this.queryManager.generateQueryId();
              if (combinedOptions.notifyOnNetworkStatusChange) {
                var currentResult = this.getCurrentResult();
                this.queryInfo.networkStatus =
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                    'NetworkStatus'
                  ].fetchMore;
                this.observer.next(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      currentResult
                    ),
                    {
                      loading: true,
                      networkStatus:
                        _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                          'NetworkStatus'
                        ].fetchMore,
                    }
                  )
                );
              }
              return this.queryManager
                .fetchQuery(
                  qid,
                  combinedOptions,
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                    'NetworkStatus'
                  ].fetchMore
                )
                .then(function (fetchMoreResult) {
                  var data = fetchMoreResult.data;
                  var updateQuery = fetchMoreOptions.updateQuery;
                  if (updateQuery) {
                    if (true && !warnedAboutUpdateQuery) {
                      false ||
                        ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                          'invariant'
                        ].warn(
                          'The updateQuery callback for fetchMore is deprecated, and will be removed\nin the next major version of Apollo Client.\n\nPlease convert updateQuery functions to field policies with appropriate\nread and merge functions, or use/adapt a helper function (such as\nconcatPagination, offsetLimitPagination, or relayStylePagination) from\n@apollo/client/utilities.\n\nThe field policy system handles pagination more effectively than a\nhand-written updateQuery function, and you only need to define the policy\nonce, rather than every time you call fetchMore.'
                        );
                      warnedAboutUpdateQuery = true;
                    }
                    _this.updateQuery(function (previous) {
                      return updateQuery(previous, {
                        fetchMoreResult: data,
                        variables: combinedOptions.variables,
                      });
                    });
                  } else {
                    _this.queryManager.cache.writeQuery({
                      query: combinedOptions.query,
                      variables: combinedOptions.variables,
                      data: data,
                    });
                  }
                  return fetchMoreResult;
                })
                .finally(function () {
                  _this.queryManager.stopQuery(qid);
                  _this.reobserve();
                });
            };
            ObservableQuery.prototype.subscribeToMore = function (options) {
              var _this = this;
              var subscription = this.queryManager
                .startGraphQLSubscription({
                  query: options.document,
                  variables: options.variables,
                  context: options.context,
                })
                .subscribe({
                  next: function (subscriptionData) {
                    var updateQuery = options.updateQuery;
                    if (updateQuery) {
                      _this.updateQuery(function (previous, _a) {
                        var variables = _a.variables;
                        return updateQuery(previous, {
                          subscriptionData: subscriptionData,
                          variables: variables,
                        });
                      });
                    }
                  },
                  error: function (err) {
                    if (options.onError) {
                      options.onError(err);
                      return;
                    }
                    false ||
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                        'invariant'
                      ].error('Unhandled GraphQL subscription error', err);
                  },
                });
              this.subscriptions.add(subscription);
              return function () {
                if (_this.subscriptions.delete(subscription)) {
                  subscription.unsubscribe();
                }
              };
            };
            ObservableQuery.prototype.setOptions = function (newOptions) {
              return this.reobserve(newOptions);
            };
            ObservableQuery.prototype.setVariables = function (variables) {
              if (
                Object(_wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal'])(
                  this.variables,
                  variables
                )
              ) {
                return this.observers.size ? this.result() : Promise.resolve();
              }
              this.options.variables = variables;
              if (!this.observers.size) {
                return Promise.resolve();
              }
              var _a = this.options.fetchPolicy,
                fetchPolicy = _a === void 0 ? 'cache-first' : _a;
              if (
                fetchPolicy !== 'cache-first' &&
                fetchPolicy !== 'no-cache' &&
                fetchPolicy !== 'network-only'
              ) {
                fetchPolicy = 'cache-and-network';
              }
              return this.reobserve(
                {
                  fetchPolicy: fetchPolicy,
                  variables: variables,
                },
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__['NetworkStatus']
                  .setVariables
              );
            };
            ObservableQuery.prototype.updateQuery = function (mapFn) {
              var _a;
              var queryManager = this.queryManager;
              var result = queryManager.cache.diff({
                query: this.options.query,
                variables: this.variables,
                previousResult:
                  (_a = this.lastResult) === null || _a === void 0
                    ? void 0
                    : _a.data,
                returnPartialData: true,
                optimistic: false,
              }).result;
              var newResult = mapFn(result, {
                variables: this.variables,
              });
              if (newResult) {
                queryManager.cache.writeQuery({
                  query: this.options.query,
                  data: newResult,
                  variables: this.variables,
                });
                queryManager.broadcastQueries();
              }
            };
            ObservableQuery.prototype.startPolling = function (pollInterval) {
              this.getReobserver().updateOptions({
                pollInterval: pollInterval,
              });
            };
            ObservableQuery.prototype.stopPolling = function () {
              if (this.reobserver) {
                this.reobserver.updateOptions({ pollInterval: 0 });
              }
            };
            ObservableQuery.prototype.updateLastResult = function (newResult) {
              var previousResult = this.lastResult;
              this.lastResult = newResult;
              this.lastResultSnapshot = this.queryManager.assumeImmutableResults
                ? newResult
                : Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'cloneDeep'
                    ]
                  )(newResult);
              if (
                !Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                    'isNonEmptyArray'
                  ]
                )(newResult.errors)
              ) {
                delete this.lastError;
              }
              return previousResult;
            };
            ObservableQuery.prototype.onSubscribe = function (observer) {
              var _this = this;
              if (observer === this.observer) {
                return function () {};
              }
              try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                  subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
              } catch (_a) {}
              var first = !this.observers.size;
              this.observers.add(observer);
              if (this.lastError) {
                observer.error && observer.error(this.lastError);
              } else if (this.lastResult) {
                observer.next && observer.next(this.lastResult);
              }
              if (first) {
                this.reobserve().catch(function (_) {});
              }
              return function () {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                  _this.tearDownQuery();
                }
              };
            };
            ObservableQuery.prototype.getReobserver = function () {
              return (
                this.reobserver || (this.reobserver = this.newReobserver(true))
              );
            };
            ObservableQuery.prototype.newReobserver = function (shareOptions) {
              var _this = this;
              var _a = this,
                queryManager = _a.queryManager,
                queryId = _a.queryId;
              queryManager.setObservableQuery(this);
              return new _Reobserver_js__WEBPACK_IMPORTED_MODULE_5__[
                'Reobserver'
              ](
                this.observer,
                shareOptions
                  ? this.options
                  : Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      this.options
                    ),
                function (currentOptions, newNetworkStatus) {
                  queryManager.setObservableQuery(_this);
                  return queryManager.fetchQueryObservable(
                    queryId,
                    currentOptions,
                    newNetworkStatus
                  );
                },
                !queryManager.ssrMode &&
                  function () {
                    return !Object(
                      _networkStatus_js__WEBPACK_IMPORTED_MODULE_3__[
                        'isNetworkRequestInFlight'
                      ]
                    )(_this.queryInfo.networkStatus);
                  }
              );
            };
            ObservableQuery.prototype.reobserve = function (
              newOptions,
              newNetworkStatus
            ) {
              this.isTornDown = false;
              return this.getReobserver().reobserve(
                newOptions,
                newNetworkStatus
              );
            };
            ObservableQuery.prototype.tearDownQuery = function () {
              var queryManager = this.queryManager;
              if (this.reobserver) {
                this.reobserver.stop();
                delete this.reobserver;
              }
              this.isTornDown = true;
              this.subscriptions.forEach(function (sub) {
                return sub.unsubscribe();
              });
              this.subscriptions.clear();
              queryManager.stopQuery(this.queryId);
              this.observers.clear();
            };
            return ObservableQuery;
          })(_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__['Observable']);

          function defaultSubscriptionObserverErrorCallback(error) {
            false ||
              ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant'].error(
                'Unhandled error',
                error.message,
                error.stack
              );
          }
          //# sourceMappingURL=ObservableQuery.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/QueryInfo.js':
        /*!*******************************************************!*\
  !*** ./node_modules/@apollo/client/core/QueryInfo.js ***!
  \*******************************************************/
        /*! exports provided: QueryInfo */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'QueryInfo',
            function () {
              return QueryInfo;
            }
          );
          /* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! @wry/equality */ './node_modules/@wry/equality/lib/equality.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./networkStatus.js */ './node_modules/@apollo/client/core/networkStatus.js'
          );

          var QueryInfo = (function () {
            function QueryInfo(cache) {
              this.cache = cache;
              this.listeners = new Set();
              this.document = null;
              this.lastRequestId = 1;
              this.subscriptions = new Set();
              this.dirty = false;
              this.diff = null;
              this.observableQuery = null;
            }
            QueryInfo.prototype.init = function (query) {
              var networkStatus =
                query.networkStatus ||
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__['NetworkStatus']
                  .loading;
              if (
                this.variables &&
                this.networkStatus !==
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                    'NetworkStatus'
                  ].loading &&
                !Object(_wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal'])(
                  this.variables,
                  query.variables
                )
              ) {
                networkStatus =
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                    'NetworkStatus'
                  ].setVariables;
              }
              if (
                !Object(_wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal'])(
                  query.variables,
                  this.variables
                )
              ) {
                this.diff = null;
              }
              Object.assign(this, {
                document: query.document,
                variables: query.variables,
                networkError: null,
                graphQLErrors: this.graphQLErrors || [],
                networkStatus: networkStatus,
              });
              if (query.observableQuery) {
                this.setObservableQuery(query.observableQuery);
              }
              if (query.lastRequestId) {
                this.lastRequestId = query.lastRequestId;
              }
              return this;
            };
            QueryInfo.prototype.getDiff = function (variables) {
              if (variables === void 0) {
                variables = this.variables;
              }
              if (
                this.diff &&
                Object(_wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal'])(
                  variables,
                  this.variables
                )
              ) {
                return this.diff;
              }
              this.updateWatch((this.variables = variables));
              return (this.diff = this.cache.diff({
                query: this.document,
                variables: variables,
                returnPartialData: true,
                optimistic: true,
              }));
            };
            QueryInfo.prototype.setDiff = function (diff) {
              var _this = this;
              var oldDiff = this.diff;
              this.diff = diff;
              if (
                !this.dirty &&
                (diff === null || diff === void 0 ? void 0 : diff.result) !==
                  (oldDiff === null || oldDiff === void 0
                    ? void 0
                    : oldDiff.result)
              ) {
                this.dirty = true;
                if (!this.notifyTimeout) {
                  this.notifyTimeout = setTimeout(function () {
                    return _this.notify();
                  }, 0);
                }
              }
            };
            QueryInfo.prototype.setObservableQuery = function (oq) {
              if (oq === this.observableQuery) return;
              if (this.oqListener) {
                this.listeners.delete(this.oqListener);
              }
              this.observableQuery = oq;
              if (oq) {
                oq['queryInfo'] = this;
                this.listeners.add(
                  (this.oqListener = function () {
                    return oq.reobserve();
                  })
                );
              } else {
                delete this.oqListener;
              }
            };
            QueryInfo.prototype.notify = function () {
              var _this = this;
              if (this.notifyTimeout) {
                clearTimeout(this.notifyTimeout);
                this.notifyTimeout = void 0;
              }
              if (this.shouldNotify()) {
                this.listeners.forEach(function (listener) {
                  return listener(_this);
                });
              }
              this.dirty = false;
            };
            QueryInfo.prototype.shouldNotify = function () {
              if (!this.dirty || !this.listeners.size) {
                return false;
              }
              if (
                Object(
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                    'isNetworkRequestInFlight'
                  ]
                )(this.networkStatus) &&
                this.observableQuery
              ) {
                var fetchPolicy = this.observableQuery.options.fetchPolicy;
                if (
                  fetchPolicy !== 'cache-only' &&
                  fetchPolicy !== 'cache-and-network'
                ) {
                  return false;
                }
              }
              return true;
            };
            QueryInfo.prototype.stop = function () {
              this.cancel();
              delete this.cancel;
              var oq = this.observableQuery;
              if (oq) oq.stopPolling();
            };
            QueryInfo.prototype.cancel = function () {};
            QueryInfo.prototype.updateWatch = function (variables) {
              var _this = this;
              if (variables === void 0) {
                variables = this.variables;
              }
              var oq = this.observableQuery;
              if (oq && oq.options.fetchPolicy === 'no-cache') {
                return;
              }
              if (
                !this.lastWatch ||
                this.lastWatch.query !== this.document ||
                !Object(_wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal'])(
                  variables,
                  this.lastWatch.variables
                )
              ) {
                this.cancel();
                this.cancel = this.cache.watch(
                  (this.lastWatch = {
                    query: this.document,
                    variables: variables,
                    optimistic: true,
                    callback: function (diff) {
                      return _this.setDiff(diff);
                    },
                  })
                );
              }
            };
            QueryInfo.prototype.markResult = function (
              result,
              options,
              allowCacheWrite
            ) {
              var _this = this;
              this.graphQLErrors = Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__[
                  'isNonEmptyArray'
                ]
              )(result.errors)
                ? result.errors
                : [];
              if (options.fetchPolicy === 'no-cache') {
                this.diff = { result: result.data, complete: true };
              } else if (allowCacheWrite) {
                var ignoreErrors =
                  options.errorPolicy === 'ignore' ||
                  options.errorPolicy === 'all';
                var writeWithErrors = !Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__[
                    'graphQLResultHasError'
                  ]
                )(result);
                if (!writeWithErrors && ignoreErrors && result.data) {
                  writeWithErrors = true;
                }
                if (writeWithErrors) {
                  this.cache.performTransaction(function (cache) {
                    if (
                      _this.lastWrittenResult &&
                      Object(
                        _wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal']
                      )(result.data, _this.lastWrittenResult.data) &&
                      Object(
                        _wry_equality__WEBPACK_IMPORTED_MODULE_0__['equal']
                      )(options.variables, _this.lastWrittenVars)
                    ) {
                      if (_this.diff && _this.diff.complete) {
                        result.data = _this.diff.result;
                        return;
                      }
                    } else {
                      cache.writeQuery({
                        query: _this.document,
                        data: result.data,
                        variables: options.variables,
                      });
                      _this.lastWrittenResult = result;
                      _this.lastWrittenVars = options.variables;
                    }
                    var diff = cache.diff({
                      query: _this.document,
                      variables: options.variables,
                      returnPartialData: true,
                      optimistic: true,
                    });
                    _this.updateWatch(options.variables);
                    _this.diff = diff;
                    if (diff.complete) {
                      result.data = diff.result;
                    }
                  });
                } else {
                  this.lastWrittenResult = this.lastWrittenVars = void 0;
                }
              }
            };
            QueryInfo.prototype.markReady = function () {
              this.networkError = null;
              return (this.networkStatus =
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                  'NetworkStatus'
                ].ready);
            };
            QueryInfo.prototype.markError = function (error) {
              this.networkStatus =
                _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                  'NetworkStatus'
                ].error;
              this.lastWrittenResult = this.lastWrittenVars = void 0;
              if (error.graphQLErrors) {
                this.graphQLErrors = error.graphQLErrors;
              }
              if (error.networkError) {
                this.networkError = error.networkError;
              }
              return error;
            };
            return QueryInfo;
          })();

          //# sourceMappingURL=QueryInfo.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/QueryManager.js':
        /*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/QueryManager.js ***!
  \**********************************************************/
        /*! exports provided: QueryManager */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'QueryManager',
            function () {
              return QueryManager;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! @wry/equality */ './node_modules/@wry/equality/lib/equality.esm.js'
          );
          /* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../link/core/index.js */ './node_modules/@apollo/client/link/core/index.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ../errors/index.js */ './node_modules/@apollo/client/errors/index.js'
          );
          /* harmony import */ var _MutationStore_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./MutationStore.js */ './node_modules/@apollo/client/core/MutationStore.js'
          );
          /* harmony import */ var _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./ObservableQuery.js */ './node_modules/@apollo/client/core/ObservableQuery.js'
          );
          /* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./networkStatus.js */ './node_modules/@apollo/client/core/networkStatus.js'
          );
          /* harmony import */ var _LocalState_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
            /*! ./LocalState.js */ './node_modules/@apollo/client/core/LocalState.js'
          );
          /* harmony import */ var _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
            /*! ./QueryInfo.js */ './node_modules/@apollo/client/core/QueryInfo.js'
          );

          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var QueryManager = (function () {
            function QueryManager(_a) {
              var cache = _a.cache,
                link = _a.link,
                _b = _a.queryDeduplication,
                queryDeduplication = _b === void 0 ? false : _b,
                _c = _a.onBroadcast,
                onBroadcast =
                  _c === void 0
                    ? function () {
                        return undefined;
                      }
                    : _c,
                _d = _a.ssrMode,
                ssrMode = _d === void 0 ? false : _d,
                _e = _a.clientAwareness,
                clientAwareness = _e === void 0 ? {} : _e,
                localState = _a.localState,
                assumeImmutableResults = _a.assumeImmutableResults;
              this.mutationStore = new _MutationStore_js__WEBPACK_IMPORTED_MODULE_6__[
                'MutationStore'
              ]();
              this.clientAwareness = {};
              this.queries = new Map();
              this.fetchCancelFns = new Map();
              this.transformCache = new (_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'canUseWeakMap'
              ]
                ? WeakMap
                : Map)();
              this.queryIdCounter = 1;
              this.requestIdCounter = 1;
              this.mutationIdCounter = 1;
              this.inFlightLinkObservables = new Map();
              this.cache = cache;
              this.link = link;
              this.queryDeduplication = queryDeduplication;
              this.onBroadcast = onBroadcast;
              this.clientAwareness = clientAwareness;
              this.localState =
                localState ||
                new _LocalState_js__WEBPACK_IMPORTED_MODULE_9__['LocalState']({
                  cache: cache,
                });
              this.ssrMode = ssrMode;
              this.assumeImmutableResults = !!assumeImmutableResults;
            }
            QueryManager.prototype.stop = function () {
              var _this = this;
              this.queries.forEach(function (_info, queryId) {
                _this.stopQueryNoBroadcast(queryId);
              });
              this.cancelPendingFetches(
                false
                  ? undefined
                  : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                      'InvariantError'
                    ]('QueryManager stopped while query was in flight')
              );
            };
            QueryManager.prototype.cancelPendingFetches = function (error) {
              this.fetchCancelFns.forEach(function (cancel) {
                return cancel(error);
              });
              this.fetchCancelFns.clear();
            };
            QueryManager.prototype.mutate = function (_a) {
              var mutation = _a.mutation,
                variables = _a.variables,
                optimisticResponse = _a.optimisticResponse,
                updateQueriesByName = _a.updateQueries,
                _b = _a.refetchQueries,
                refetchQueries = _b === void 0 ? [] : _b,
                _c = _a.awaitRefetchQueries,
                awaitRefetchQueries = _c === void 0 ? false : _c,
                updateWithProxyFn = _a.update,
                _d = _a.errorPolicy,
                errorPolicy = _d === void 0 ? 'none' : _d,
                fetchPolicy = _a.fetchPolicy,
                _e = _a.context,
                context = _e === void 0 ? {} : _e;
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__awaiter'])(
                this,
                void 0,
                void 0,
                function () {
                  var mutationId, generateUpdateQueriesInfo, optimistic_1, self;
                  var _this = this;
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__generator']
                  )(this, function (_f) {
                    switch (_f.label) {
                      case 0:
                        false
                          ? undefined
                          : Object(
                              ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                                'invariant'
                              ]
                            )(
                              mutation,
                              'mutation option is required. You must specify your GraphQL document in the mutation option.'
                            );
                        false
                          ? undefined
                          : Object(
                              ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                                'invariant'
                              ]
                            )(
                              !fetchPolicy || fetchPolicy === 'no-cache',
                              "Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior."
                            );
                        mutationId = this.generateMutationId();
                        mutation = this.transform(mutation).document;
                        variables = this.getVariables(mutation, variables);
                        if (!this.transform(mutation).hasClientExports)
                          return [3, 2];
                        return [
                          4,
                          this.localState.addExportedVariables(
                            mutation,
                            variables,
                            context
                          ),
                        ];
                      case 1:
                        variables = _f.sent();
                        _f.label = 2;
                      case 2:
                        generateUpdateQueriesInfo = function () {
                          var ret = {};
                          if (updateQueriesByName) {
                            _this.queries.forEach(function (_a, queryId) {
                              var observableQuery = _a.observableQuery;
                              if (observableQuery) {
                                var queryName = observableQuery.queryName;
                                if (
                                  queryName &&
                                  hasOwnProperty.call(
                                    updateQueriesByName,
                                    queryName
                                  )
                                ) {
                                  ret[queryId] = {
                                    updater: updateQueriesByName[queryName],
                                    queryInfo: _this.queries.get(queryId),
                                  };
                                }
                              }
                            });
                          }
                          return ret;
                        };
                        this.mutationStore.initMutation(
                          mutationId,
                          mutation,
                          variables
                        );
                        if (optimisticResponse) {
                          optimistic_1 =
                            typeof optimisticResponse === 'function'
                              ? optimisticResponse(variables)
                              : optimisticResponse;
                          this.cache.recordOptimisticTransaction(function (
                            cache
                          ) {
                            try {
                              markMutationResult(
                                {
                                  mutationId: mutationId,
                                  result: { data: optimistic_1 },
                                  document: mutation,
                                  variables: variables,
                                  queryUpdatersById: generateUpdateQueriesInfo(),
                                  update: updateWithProxyFn,
                                },
                                cache
                              );
                            } catch (error) {
                              false ||
                                ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                                  'invariant'
                                ].error(error);
                            }
                          },
                          mutationId);
                        }
                        this.broadcastQueries();
                        self = this;
                        return [
                          2,
                          new Promise(function (resolve, reject) {
                            var storeResult;
                            var error;
                            self
                              .getObservableFromLink(
                                mutation,
                                Object(
                                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                                )(
                                  Object(
                                    tslib__WEBPACK_IMPORTED_MODULE_0__[
                                      '__assign'
                                    ]
                                  )({}, context),
                                  { optimisticResponse: optimisticResponse }
                                ),
                                variables,
                                false
                              )
                              .subscribe({
                                next: function (result) {
                                  if (
                                    Object(
                                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                                        'graphQLResultHasError'
                                      ]
                                    )(result) &&
                                    errorPolicy === 'none'
                                  ) {
                                    error = new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                                      'ApolloError'
                                    ]({
                                      graphQLErrors: result.errors,
                                    });
                                    return;
                                  }
                                  self.mutationStore.markMutationResult(
                                    mutationId
                                  );
                                  if (fetchPolicy !== 'no-cache') {
                                    try {
                                      markMutationResult(
                                        {
                                          mutationId: mutationId,
                                          result: result,
                                          document: mutation,
                                          variables: variables,
                                          queryUpdatersById: generateUpdateQueriesInfo(),
                                          update: updateWithProxyFn,
                                        },
                                        self.cache
                                      );
                                    } catch (e) {
                                      error = new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                                        'ApolloError'
                                      ]({
                                        networkError: e,
                                      });
                                      return;
                                    }
                                  }
                                  storeResult = result;
                                },
                                error: function (err) {
                                  self.mutationStore.markMutationError(
                                    mutationId,
                                    err
                                  );
                                  if (optimisticResponse) {
                                    self.cache.removeOptimistic(mutationId);
                                  }
                                  self.broadcastQueries();
                                  reject(
                                    new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                                      'ApolloError'
                                    ]({
                                      networkError: err,
                                    })
                                  );
                                },
                                complete: function () {
                                  if (error) {
                                    self.mutationStore.markMutationError(
                                      mutationId,
                                      error
                                    );
                                  }
                                  if (optimisticResponse) {
                                    self.cache.removeOptimistic(mutationId);
                                  }
                                  self.broadcastQueries();
                                  if (error) {
                                    reject(error);
                                    return;
                                  }
                                  if (typeof refetchQueries === 'function') {
                                    refetchQueries = refetchQueries(
                                      storeResult
                                    );
                                  }
                                  var refetchQueryPromises = [];
                                  if (
                                    Object(
                                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                                        'isNonEmptyArray'
                                      ]
                                    )(refetchQueries)
                                  ) {
                                    refetchQueries.forEach(function (
                                      refetchQuery
                                    ) {
                                      if (typeof refetchQuery === 'string') {
                                        self.queries.forEach(function (_a) {
                                          var observableQuery =
                                            _a.observableQuery;
                                          if (
                                            observableQuery &&
                                            observableQuery.queryName ===
                                              refetchQuery
                                          ) {
                                            refetchQueryPromises.push(
                                              observableQuery.refetch()
                                            );
                                          }
                                        });
                                      } else {
                                        var queryOptions = {
                                          query: refetchQuery.query,
                                          variables: refetchQuery.variables,
                                          fetchPolicy: 'network-only',
                                        };
                                        if (refetchQuery.context) {
                                          queryOptions.context =
                                            refetchQuery.context;
                                        }
                                        refetchQueryPromises.push(
                                          self.query(queryOptions)
                                        );
                                      }
                                    });
                                  }
                                  Promise.all(
                                    awaitRefetchQueries
                                      ? refetchQueryPromises
                                      : []
                                  ).then(function () {
                                    if (
                                      errorPolicy === 'ignore' &&
                                      storeResult &&
                                      Object(
                                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                                          'graphQLResultHasError'
                                        ]
                                      )(storeResult)
                                    ) {
                                      delete storeResult.errors;
                                    }
                                    resolve(storeResult);
                                  }, reject);
                                },
                              });
                          }),
                        ];
                    }
                  });
                }
              );
            };
            QueryManager.prototype.fetchQuery = function (
              queryId,
              options,
              networkStatus
            ) {
              return this.fetchQueryObservable(queryId, options, networkStatus)
                .promise;
            };
            QueryManager.prototype.getQueryStore = function () {
              var store = Object.create(null);
              this.queries.forEach(function (info, queryId) {
                store[queryId] = {
                  variables: info.variables,
                  networkStatus: info.networkStatus,
                  networkError: info.networkError,
                  graphQLErrors: info.graphQLErrors,
                };
              });
              return store;
            };
            QueryManager.prototype.resetErrors = function (queryId) {
              var queryInfo = this.queries.get(queryId);
              if (queryInfo) {
                queryInfo.networkError = undefined;
                queryInfo.graphQLErrors = [];
              }
            };
            QueryManager.prototype.transform = function (document) {
              var transformCache = this.transformCache;
              if (!transformCache.has(document)) {
                var transformed = this.cache.transformDocument(document);
                var forLink = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                    'removeConnectionDirectiveFromDocument'
                  ]
                )(this.cache.transformForLink(transformed));
                var clientQuery = this.localState.clientQuery(transformed);
                var serverQuery =
                  forLink && this.localState.serverQuery(forLink);
                var cacheEntry_1 = {
                  document: transformed,
                  hasClientExports: Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'hasClientExports'
                    ]
                  )(transformed),
                  hasForcedResolvers: this.localState.shouldForceResolvers(
                    transformed
                  ),
                  clientQuery: clientQuery,
                  serverQuery: serverQuery,
                  defaultVars: Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'getDefaultValues'
                    ]
                  )(
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                        'getOperationDefinition'
                      ]
                    )(transformed)
                  ),
                };
                var add = function (doc) {
                  if (doc && !transformCache.has(doc)) {
                    transformCache.set(doc, cacheEntry_1);
                  }
                };
                add(document);
                add(transformed);
                add(clientQuery);
                add(serverQuery);
              }
              return transformCache.get(document);
            };
            QueryManager.prototype.getVariables = function (
              document,
              variables
            ) {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  this.transform(document).defaultVars
                ),
                variables
              );
            };
            QueryManager.prototype.watchQuery = function (options) {
              options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  options
                ),
                {
                  variables: this.getVariables(
                    options.query,
                    options.variables
                  ),
                }
              );
              if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
                options.notifyOnNetworkStatusChange = false;
              }
              var queryInfo = new _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__[
                'QueryInfo'
              ](this.cache);
              var observable = new _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_7__[
                'ObservableQuery'
              ]({
                queryManager: this,
                queryInfo: queryInfo,
                options: options,
              });
              this.queries.set(observable.queryId, queryInfo);
              queryInfo.init({
                document: options.query,
                observableQuery: observable,
                variables: options.variables,
              });
              return observable;
            };
            QueryManager.prototype.query = function (options) {
              var _this = this;
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    options.query,
                    'query option is required. You must specify your GraphQL document ' +
                      'in the query option.'
                  );
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    options.query.kind === 'Document',
                    'You must wrap the query string in a "gql" tag.'
                  );
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    !options.returnPartialData,
                    'returnPartialData option only supported on watchQuery.'
                  );
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    !options.pollInterval,
                    'pollInterval option only supported on watchQuery.'
                  );
              var queryId = this.generateQueryId();
              return this.fetchQuery(queryId, options).finally(function () {
                return _this.stopQuery(queryId);
              });
            };
            QueryManager.prototype.generateQueryId = function () {
              return String(this.queryIdCounter++);
            };
            QueryManager.prototype.generateRequestId = function () {
              return this.requestIdCounter++;
            };
            QueryManager.prototype.generateMutationId = function () {
              return String(this.mutationIdCounter++);
            };
            QueryManager.prototype.stopQueryInStore = function (queryId) {
              this.stopQueryInStoreNoBroadcast(queryId);
              this.broadcastQueries();
            };
            QueryManager.prototype.stopQueryInStoreNoBroadcast = function (
              queryId
            ) {
              var queryInfo = this.queries.get(queryId);
              if (queryInfo) queryInfo.stop();
            };
            QueryManager.prototype.clearStore = function () {
              this.cancelPendingFetches(
                false
                  ? undefined
                  : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                      'InvariantError'
                    ](
                      'Store reset while query was in flight (not completed in link chain)'
                    )
              );
              this.queries.forEach(function (queryInfo) {
                if (queryInfo.observableQuery) {
                  queryInfo.networkStatus =
                    _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                      'NetworkStatus'
                    ].loading;
                } else {
                  queryInfo.stop();
                }
              });
              this.mutationStore.reset();
              return this.cache.reset();
            };
            QueryManager.prototype.resetStore = function () {
              var _this = this;
              return this.clearStore().then(function () {
                return _this.reFetchObservableQueries();
              });
            };
            QueryManager.prototype.reFetchObservableQueries = function (
              includeStandby
            ) {
              var _this = this;
              if (includeStandby === void 0) {
                includeStandby = false;
              }
              var observableQueryPromises = [];
              this.queries.forEach(function (_a, queryId) {
                var observableQuery = _a.observableQuery;
                if (observableQuery) {
                  var fetchPolicy = observableQuery.options.fetchPolicy;
                  observableQuery.resetLastResults();
                  if (
                    fetchPolicy !== 'cache-only' &&
                    (includeStandby || fetchPolicy !== 'standby')
                  ) {
                    observableQueryPromises.push(observableQuery.refetch());
                  }
                  _this.getQuery(queryId).setDiff(null);
                }
              });
              this.broadcastQueries();
              return Promise.all(observableQueryPromises);
            };
            QueryManager.prototype.setObservableQuery = function (
              observableQuery
            ) {
              this.getQuery(observableQuery.queryId).setObservableQuery(
                observableQuery
              );
            };
            QueryManager.prototype.startGraphQLSubscription = function (_a) {
              var _this = this;
              var query = _a.query,
                fetchPolicy = _a.fetchPolicy,
                variables = _a.variables,
                _b = _a.context,
                context = _b === void 0 ? {} : _b;
              query = this.transform(query).document;
              variables = this.getVariables(query, variables);
              var makeObservable = function (variables) {
                return _this
                  .getObservableFromLink(query, context, variables, false)
                  .map(function (result) {
                    if (!fetchPolicy || fetchPolicy !== 'no-cache') {
                      if (
                        !Object(
                          _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                            'graphQLResultHasError'
                          ]
                        )(result)
                      ) {
                        _this.cache.write({
                          query: query,
                          result: result.data,
                          dataId: 'ROOT_SUBSCRIPTION',
                          variables: variables,
                        });
                      }
                      _this.broadcastQueries();
                    }
                    if (
                      Object(
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                          'graphQLResultHasError'
                        ]
                      )(result)
                    ) {
                      throw new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                        'ApolloError'
                      ]({
                        graphQLErrors: result.errors,
                      });
                    }
                    return result;
                  });
              };
              if (this.transform(query).hasClientExports) {
                var observablePromise_1 = this.localState
                  .addExportedVariables(query, variables, context)
                  .then(makeObservable);
                return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                  'Observable'
                ](function (observer) {
                  var sub = null;
                  observablePromise_1.then(function (observable) {
                    return (sub = observable.subscribe(observer));
                  }, observer.error);
                  return function () {
                    return sub && sub.unsubscribe();
                  };
                });
              }
              return makeObservable(variables);
            };
            QueryManager.prototype.stopQuery = function (queryId) {
              this.stopQueryNoBroadcast(queryId);
              this.broadcastQueries();
            };
            QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
              this.stopQueryInStoreNoBroadcast(queryId);
              this.removeQuery(queryId);
            };
            QueryManager.prototype.removeQuery = function (queryId) {
              this.fetchCancelFns.delete(queryId);
              this.getQuery(queryId).subscriptions.forEach(function (x) {
                return x.unsubscribe();
              });
              this.queries.delete(queryId);
            };
            QueryManager.prototype.broadcastQueries = function () {
              this.onBroadcast();
              this.queries.forEach(function (info) {
                return info.notify();
              });
            };
            QueryManager.prototype.getLocalState = function () {
              return this.localState;
            };
            QueryManager.prototype.getObservableFromLink = function (
              query,
              context,
              variables,
              deduplication
            ) {
              var _this = this;
              var _a;
              if (deduplication === void 0) {
                deduplication =
                  (_a =
                    context === null || context === void 0
                      ? void 0
                      : context.queryDeduplication) !== null && _a !== void 0
                    ? _a
                    : this.queryDeduplication;
              }
              var observable;
              var serverQuery = this.transform(query).serverQuery;
              if (serverQuery) {
                var _b = this,
                  inFlightLinkObservables_1 = _b.inFlightLinkObservables,
                  link = _b.link;
                var operation = {
                  query: serverQuery,
                  variables: variables,
                  operationName:
                    Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                        'getOperationName'
                      ]
                    )(serverQuery) || void 0,
                  context: this.prepareContext(
                    Object(
                      tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                    )(
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        context
                      ),
                      { forceFetch: !deduplication }
                    )
                  ),
                };
                context = operation.context;
                if (deduplication) {
                  var byVariables_1 =
                    inFlightLinkObservables_1.get(serverQuery) || new Map();
                  inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                  var varJson_1 = JSON.stringify(variables);
                  observable = byVariables_1.get(varJson_1);
                  if (!observable) {
                    var concast = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'Concast'
                    ]([
                      Object(
                        _link_core_index_js__WEBPACK_IMPORTED_MODULE_3__[
                          'execute'
                        ]
                      )(link, operation),
                    ]);
                    byVariables_1.set(varJson_1, (observable = concast));
                    concast.cleanup(function () {
                      if (
                        byVariables_1.delete(varJson_1) &&
                        byVariables_1.size < 1
                      ) {
                        inFlightLinkObservables_1.delete(serverQuery);
                      }
                    });
                  }
                } else {
                  observable = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                    'Concast'
                  ]([
                    Object(
                      _link_core_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'execute'
                      ]
                    )(link, operation),
                  ]);
                }
              } else {
                observable = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                  'Concast'
                ]([
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                    'Observable'
                  ].of({ data: {} }),
                ]);
                context = this.prepareContext(context);
              }
              var clientQuery = this.transform(query).clientQuery;
              if (clientQuery) {
                observable = Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__['asyncMap']
                )(observable, function (result) {
                  return _this.localState.runResolvers({
                    document: clientQuery,
                    remoteResult: result,
                    context: context,
                    variables: variables,
                  });
                });
              }
              return observable;
            };
            QueryManager.prototype.getResultsFromLink = function (
              queryInfo,
              allowCacheWrite,
              options
            ) {
              var lastRequestId = queryInfo.lastRequestId;
              return Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__['asyncMap']
              )(
                this.getObservableFromLink(
                  queryInfo.document,
                  options.context,
                  options.variables
                ),
                function (result) {
                  var hasErrors = Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'isNonEmptyArray'
                    ]
                  )(result.errors);
                  if (lastRequestId >= queryInfo.lastRequestId) {
                    if (hasErrors && options.errorPolicy === 'none') {
                      throw queryInfo.markError(
                        new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                          'ApolloError'
                        ]({
                          graphQLErrors: result.errors,
                        })
                      );
                    }
                    queryInfo.markResult(result, options, allowCacheWrite);
                    queryInfo.markReady();
                  }
                  var aqr = {
                    data: result.data,
                    loading: false,
                    networkStatus:
                      queryInfo.networkStatus ||
                      _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                        'NetworkStatus'
                      ].ready,
                  };
                  if (hasErrors && options.errorPolicy !== 'ignore') {
                    aqr.errors = result.errors;
                  }
                  return aqr;
                },
                function (networkError) {
                  var error = Object(
                    _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                      'isApolloError'
                    ]
                  )(networkError)
                    ? networkError
                    : new _errors_index_js__WEBPACK_IMPORTED_MODULE_5__[
                        'ApolloError'
                      ]({ networkError: networkError });
                  if (lastRequestId >= queryInfo.lastRequestId) {
                    queryInfo.markError(error);
                  }
                  throw error;
                }
              );
            };
            QueryManager.prototype.fetchQueryObservable = function (
              queryId,
              options,
              networkStatus
            ) {
              var _this = this;
              if (networkStatus === void 0) {
                networkStatus =
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                    'NetworkStatus'
                  ].loading;
              }
              var query = this.transform(options.query).document;
              var variables = this.getVariables(query, options.variables);
              var queryInfo = this.getQuery(queryId);
              var oldNetworkStatus = queryInfo.networkStatus;
              var _a = options.fetchPolicy,
                fetchPolicy = _a === void 0 ? 'cache-first' : _a,
                _b = options.errorPolicy,
                errorPolicy = _b === void 0 ? 'none' : _b,
                _c = options.returnPartialData,
                returnPartialData = _c === void 0 ? false : _c,
                _d = options.notifyOnNetworkStatusChange,
                notifyOnNetworkStatusChange = _d === void 0 ? false : _d,
                _e = options.context,
                context = _e === void 0 ? {} : _e;
              var mightUseNetwork =
                fetchPolicy === 'cache-first' ||
                fetchPolicy === 'cache-and-network' ||
                fetchPolicy === 'network-only' ||
                fetchPolicy === 'no-cache';
              if (
                mightUseNetwork &&
                notifyOnNetworkStatusChange &&
                typeof oldNetworkStatus === 'number' &&
                oldNetworkStatus !== networkStatus &&
                Object(
                  _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                    'isNetworkRequestInFlight'
                  ]
                )(networkStatus)
              ) {
                if (fetchPolicy !== 'cache-first') {
                  fetchPolicy = 'cache-and-network';
                }
                returnPartialData = true;
              }
              var normalized = Object.assign({}, options, {
                query: query,
                variables: variables,
                fetchPolicy: fetchPolicy,
                errorPolicy: errorPolicy,
                returnPartialData: returnPartialData,
                notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,
                context: context,
              });
              var fromVariables = function (variables) {
                normalized.variables = variables;
                return _this.fetchQueryByPolicy(
                  queryInfo,
                  normalized,
                  networkStatus
                );
              };
              this.fetchCancelFns.set(queryId, function (reason) {
                Promise.resolve().then(function () {
                  return concast.cancel(reason);
                });
              });
              var concast = new _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'Concast'
              ](
                this.transform(normalized.query).hasClientExports
                  ? this.localState
                      .addExportedVariables(
                        normalized.query,
                        normalized.variables,
                        normalized.context
                      )
                      .then(fromVariables)
                  : fromVariables(normalized.variables)
              );
              concast.cleanup(function () {
                _this.fetchCancelFns.delete(queryId);
                if (options.nextFetchPolicy) {
                  options.fetchPolicy = options.nextFetchPolicy;
                  options.nextFetchPolicy = void 0;
                }
              });
              return concast;
            };
            QueryManager.prototype.fetchQueryByPolicy = function (
              queryInfo,
              options,
              networkStatus
            ) {
              var _this = this;
              var query = options.query,
                variables = options.variables,
                fetchPolicy = options.fetchPolicy,
                errorPolicy = options.errorPolicy,
                returnPartialData = options.returnPartialData,
                context = options.context;
              queryInfo.init({
                document: query,
                variables: variables,
                lastRequestId: this.generateRequestId(),
                networkStatus: networkStatus,
              });
              var readCache = function () {
                return queryInfo.getDiff(variables);
              };
              var resultsFromCache = function (diff, networkStatus) {
                if (networkStatus === void 0) {
                  networkStatus =
                    queryInfo.networkStatus ||
                    _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                      'NetworkStatus'
                    ].loading;
                }
                var data = diff.result;
                if (
                  true &&
                  Object(
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'isNonEmptyArray'
                    ]
                  )(diff.missing) &&
                  !Object(_wry_equality__WEBPACK_IMPORTED_MODULE_2__['equal'])(
                    data,
                    {}
                  )
                ) {
                  false ||
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant'].warn(
                      'Missing cache result fields: ' +
                        diff.missing
                          .map(function (m) {
                            return m.path.join('.');
                          })
                          .join(', '),
                      diff.missing
                    );
                }
                var fromData = function (data) {
                  return _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                    'Observable'
                  ].of(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {
                        data: data,
                        loading: Object(
                          _networkStatus_js__WEBPACK_IMPORTED_MODULE_8__[
                            'isNetworkRequestInFlight'
                          ]
                        )(networkStatus),
                        networkStatus: networkStatus,
                      },
                      diff.complete ? null : { partial: true }
                    )
                  );
                };
                if (_this.transform(query).hasForcedResolvers) {
                  return _this.localState
                    .runResolvers({
                      document: query,
                      remoteResult: { data: data },
                      context: context,
                      variables: variables,
                      onlyRunForcedResolvers: true,
                    })
                    .then(function (resolved) {
                      return fromData(resolved.data);
                    });
                }
                return fromData(data);
              };
              var resultsFromLink = function (allowCacheWrite) {
                return _this.getResultsFromLink(queryInfo, allowCacheWrite, {
                  variables: variables,
                  context: context,
                  fetchPolicy: fetchPolicy,
                  errorPolicy: errorPolicy,
                });
              };
              switch (fetchPolicy) {
                default:
                case 'cache-first': {
                  var diff = readCache();
                  if (diff.complete) {
                    return [resultsFromCache(diff, queryInfo.markReady())];
                  }
                  if (returnPartialData) {
                    return [resultsFromCache(diff), resultsFromLink(true)];
                  }
                  return [resultsFromLink(true)];
                }
                case 'cache-and-network': {
                  var diff = readCache();
                  if (diff.complete || returnPartialData) {
                    return [resultsFromCache(diff), resultsFromLink(true)];
                  }
                  return [resultsFromLink(true)];
                }
                case 'cache-only':
                  return [resultsFromCache(readCache(), queryInfo.markReady())];
                case 'network-only':
                  return [resultsFromLink(true)];
                case 'no-cache':
                  return [resultsFromLink(false)];
                case 'standby':
                  return [];
              }
            };
            QueryManager.prototype.getQuery = function (queryId) {
              if (queryId && !this.queries.has(queryId)) {
                this.queries.set(
                  queryId,
                  new _QueryInfo_js__WEBPACK_IMPORTED_MODULE_10__['QueryInfo'](
                    this.cache
                  )
                );
              }
              return this.queries.get(queryId);
            };
            QueryManager.prototype.prepareContext = function (context) {
              if (context === void 0) {
                context = {};
              }
              var newContext = this.localState.prepareContext(context);
              return Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  newContext
                ),
                { clientAwareness: this.clientAwareness }
              );
            };
            return QueryManager;
          })();

          function markMutationResult(mutation, cache) {
            if (
              !Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                  'graphQLResultHasError'
                ]
              )(mutation.result)
            ) {
              var cacheWrites_1 = [
                {
                  result: mutation.result.data,
                  dataId: 'ROOT_MUTATION',
                  query: mutation.document,
                  variables: mutation.variables,
                },
              ];
              var queryUpdatersById_1 = mutation.queryUpdatersById;
              if (queryUpdatersById_1) {
                Object.keys(queryUpdatersById_1).forEach(function (id) {
                  var _a = queryUpdatersById_1[id],
                    updater = _a.updater,
                    _b = _a.queryInfo,
                    document = _b.document,
                    variables = _b.variables;
                  var _c = cache.diff({
                      query: document,
                      variables: variables,
                      returnPartialData: true,
                      optimistic: false,
                    }),
                    currentQueryResult = _c.result,
                    complete = _c.complete;
                  if (complete && currentQueryResult) {
                    var nextQueryResult = updater(currentQueryResult, {
                      mutationResult: mutation.result,
                      queryName:
                        Object(
                          _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__[
                            'getOperationName'
                          ]
                        )(document) || undefined,
                      queryVariables: variables,
                    });
                    if (nextQueryResult) {
                      cacheWrites_1.push({
                        result: nextQueryResult,
                        dataId: 'ROOT_QUERY',
                        query: document,
                        variables: variables,
                      });
                    }
                  }
                });
              }
              cache.performTransaction(function (c) {
                cacheWrites_1.forEach(function (write) {
                  return c.write(write);
                });
                var update = mutation.update;
                if (update) {
                  update(c, mutation.result);
                }
              }, null);
            }
          }
          //# sourceMappingURL=QueryManager.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/Reobserver.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/core/Reobserver.js ***!
  \********************************************************/
        /*! exports provided: Reobserver */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Reobserver',
            function () {
              return Reobserver;
            }
          );
          /* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./networkStatus.js */ './node_modules/@apollo/client/core/networkStatus.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          var Reobserver = (function () {
            function Reobserver(observer, options, fetch, shouldFetch) {
              this.observer = observer;
              this.options = options;
              this.fetch = fetch;
              this.shouldFetch = shouldFetch;
            }
            Reobserver.prototype.reobserve = function (
              newOptions,
              newNetworkStatus
            ) {
              if (newOptions) {
                this.updateOptions(newOptions);
              } else {
                this.updatePolling();
              }
              var concast = this.fetch(this.options, newNetworkStatus);
              if (this.concast) {
                this.concast.removeObserver(this.observer, true);
              }
              concast.addObserver(this.observer);
              return (this.concast = concast).promise;
            };
            Reobserver.prototype.updateOptions = function (newOptions) {
              Object.assign(
                this.options,
                Object(
                  _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__['compact']
                )(newOptions)
              );
              this.updatePolling();
              return this;
            };
            Reobserver.prototype.stop = function () {
              if (this.concast) {
                this.concast.removeObserver(this.observer);
                delete this.concast;
              }
              if (this.pollingInfo) {
                clearTimeout(this.pollingInfo.timeout);
                this.options.pollInterval = 0;
                this.updatePolling();
              }
            };
            Reobserver.prototype.updatePolling = function () {
              var _this = this;
              var _a = this,
                pollingInfo = _a.pollingInfo,
                pollInterval = _a.options.pollInterval;
              if (!pollInterval) {
                if (pollingInfo) {
                  clearTimeout(pollingInfo.timeout);
                  delete this.pollingInfo;
                }
                return;
              }
              if (pollingInfo && pollingInfo.interval === pollInterval) {
                return;
              }
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant']
                  )(
                    pollInterval,
                    'Attempted to start a polling query without a polling interval.'
                  );
              if (this.shouldFetch === false) {
                return;
              }
              var info = pollingInfo || (this.pollingInfo = {});
              info.interval = pollInterval;
              var maybeFetch = function () {
                if (_this.pollingInfo) {
                  if (_this.shouldFetch && _this.shouldFetch()) {
                    _this
                      .reobserve(
                        {
                          fetchPolicy: 'network-only',
                        },
                        _networkStatus_js__WEBPACK_IMPORTED_MODULE_0__[
                          'NetworkStatus'
                        ].poll
                      )
                      .then(poll, poll);
                  } else {
                    poll();
                  }
                }
              };
              var poll = function () {
                var info = _this.pollingInfo;
                if (info) {
                  clearTimeout(info.timeout);
                  info.timeout = setTimeout(maybeFetch, info.interval);
                }
              };
              poll();
            };
            return Reobserver;
          })();

          //# sourceMappingURL=Reobserver.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/index.js':
        /*!***************************************************!*\
  !*** ./node_modules/@apollo/client/core/index.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resetCaches',
            function () {
              return resetCaches;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'disableFragmentWarnings',
            function () {
              return disableFragmentWarnings;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'enableExperimentalFragmentVariables',
            function () {
              return enableExperimentalFragmentVariables;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'disableExperimentalFragmentVariables',
            function () {
              return disableExperimentalFragmentVariables;
            }
          );
          /* harmony import */ var _ApolloClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloClient.js */ './node_modules/@apollo/client/core/ApolloClient.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloClient',
            function () {
              return _ApolloClient_js__WEBPACK_IMPORTED_MODULE_0__[
                'ApolloClient'
              ];
            }
          );

          /* harmony import */ var _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./ObservableQuery.js */ './node_modules/@apollo/client/core/ObservableQuery.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ObservableQuery',
            function () {
              return _ObservableQuery_js__WEBPACK_IMPORTED_MODULE_1__[
                'ObservableQuery'
              ];
            }
          );

          /* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./networkStatus.js */ './node_modules/@apollo/client/core/networkStatus.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'NetworkStatus',
            function () {
              return _networkStatus_js__WEBPACK_IMPORTED_MODULE_2__[
                'NetworkStatus'
              ];
            }
          );

          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./types.js */ './node_modules/@apollo/client/core/types.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(
            _types_js__WEBPACK_IMPORTED_MODULE_3__
          );
          /* harmony reexport (unknown) */ for (var __WEBPACK_IMPORT_KEY__ in _types_js__WEBPACK_IMPORTED_MODULE_3__)
            if (
              [
                'default',
                'ApolloClient',
                'ObservableQuery',
                'NetworkStatus',
                'isApolloError',
                'ApolloError',
                'Cache',
                'ApolloCache',
                'InMemoryCache',
                'MissingFieldError',
                'defaultDataIdFromObject',
                'makeVar',
                'fromError',
                'toPromise',
                'fromPromise',
                'throwServerError',
                'Observable',
                'isReference',
                'makeReference',
                'resetCaches',
                'disableFragmentWarnings',
                'enableExperimentalFragmentVariables',
                'disableExperimentalFragmentVariables',
                'gql',
              ].indexOf(__WEBPACK_IMPORT_KEY__) < 0
            )
              (function (key) {
                __webpack_require__.d(__webpack_exports__, key, function () {
                  return _types_js__WEBPACK_IMPORTED_MODULE_3__[key];
                });
              })(__WEBPACK_IMPORT_KEY__);
          /* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../errors/index.js */ './node_modules/@apollo/client/errors/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isApolloError',
            function () {
              return _errors_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'isApolloError'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloError',
            function () {
              return _errors_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'ApolloError'
              ];
            }
          );

          /* harmony import */ var _cache_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ../cache/index.js */ './node_modules/@apollo/client/cache/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Cache',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__['Cache'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloCache',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__[
                'ApolloCache'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'InMemoryCache',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__[
                'InMemoryCache'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'MissingFieldError',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__[
                'MissingFieldError'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'defaultDataIdFromObject',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__[
                'defaultDataIdFromObject'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'makeVar',
            function () {
              return _cache_index_js__WEBPACK_IMPORTED_MODULE_5__['makeVar'];
            }
          );

          /* harmony import */ var _cache_inmemory_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ../cache/inmemory/types.js */ './node_modules/@apollo/client/cache/inmemory/types.js'
          );
          /* harmony import */ var _cache_inmemory_types_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __webpack_require__.n(
            _cache_inmemory_types_js__WEBPACK_IMPORTED_MODULE_6__
          );
          /* harmony reexport (unknown) */ for (var __WEBPACK_IMPORT_KEY__ in _cache_inmemory_types_js__WEBPACK_IMPORTED_MODULE_6__)
            if (
              [
                'default',
                'ApolloClient',
                'ObservableQuery',
                'NetworkStatus',
                'isApolloError',
                'ApolloError',
                'Cache',
                'ApolloCache',
                'InMemoryCache',
                'MissingFieldError',
                'defaultDataIdFromObject',
                'makeVar',
                'fromError',
                'toPromise',
                'fromPromise',
                'throwServerError',
                'Observable',
                'isReference',
                'makeReference',
                'resetCaches',
                'disableFragmentWarnings',
                'enableExperimentalFragmentVariables',
                'disableExperimentalFragmentVariables',
                'gql',
              ].indexOf(__WEBPACK_IMPORT_KEY__) < 0
            )
              (function (key) {
                __webpack_require__.d(__webpack_exports__, key, function () {
                  return _cache_inmemory_types_js__WEBPACK_IMPORTED_MODULE_6__[
                    key
                  ];
                });
              })(__WEBPACK_IMPORT_KEY__);
          /* harmony import */ var _link_core_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ../link/core/index.js */ './node_modules/@apollo/client/link/core/index.js'
          );
          /* harmony reexport (unknown) */ for (var __WEBPACK_IMPORT_KEY__ in _link_core_index_js__WEBPACK_IMPORTED_MODULE_7__)
            if (
              [
                'default',
                'ApolloClient',
                'ObservableQuery',
                'NetworkStatus',
                'isApolloError',
                'ApolloError',
                'Cache',
                'ApolloCache',
                'InMemoryCache',
                'MissingFieldError',
                'defaultDataIdFromObject',
                'makeVar',
                'fromError',
                'toPromise',
                'fromPromise',
                'throwServerError',
                'Observable',
                'isReference',
                'makeReference',
                'resetCaches',
                'disableFragmentWarnings',
                'enableExperimentalFragmentVariables',
                'disableExperimentalFragmentVariables',
                'gql',
              ].indexOf(__WEBPACK_IMPORT_KEY__) < 0
            )
              (function (key) {
                __webpack_require__.d(__webpack_exports__, key, function () {
                  return _link_core_index_js__WEBPACK_IMPORTED_MODULE_7__[key];
                });
              })(__WEBPACK_IMPORT_KEY__);
          /* harmony import */ var _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ../link/http/index.js */ './node_modules/@apollo/client/link/http/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'parseAndCheckHttpResponse',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'parseAndCheckHttpResponse'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'serializeFetchParameter',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'serializeFetchParameter'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fallbackHttpConfig',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'fallbackHttpConfig'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'selectHttpOptionsAndBody',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'selectHttpOptionsAndBody'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'checkFetcher',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'checkFetcher'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createSignalIfSupported',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'createSignalIfSupported'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'selectURI',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'selectURI'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createHttpLink',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'createHttpLink'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'HttpLink',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'HttpLink'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'rewriteURIForGET',
            function () {
              return _link_http_index_js__WEBPACK_IMPORTED_MODULE_8__[
                'rewriteURIForGET'
              ];
            }
          );

          /* harmony import */ var _link_utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
            /*! ../link/utils/index.js */ './node_modules/@apollo/client/link/utils/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fromError',
            function () {
              return _link_utils_index_js__WEBPACK_IMPORTED_MODULE_9__[
                'fromError'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toPromise',
            function () {
              return _link_utils_index_js__WEBPACK_IMPORTED_MODULE_9__[
                'toPromise'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fromPromise',
            function () {
              return _link_utils_index_js__WEBPACK_IMPORTED_MODULE_9__[
                'fromPromise'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'throwServerError',
            function () {
              return _link_utils_index_js__WEBPACK_IMPORTED_MODULE_9__[
                'throwServerError'
              ];
            }
          );

          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Observable',
            function () {
              return _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__[
                'Observable'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isReference',
            function () {
              return _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__[
                'isReference'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'makeReference',
            function () {
              return _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__[
                'makeReference'
              ];
            }
          );

          /* harmony import */ var graphql_tag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
            /*! graphql-tag */ './node_modules/graphql-tag/src/index.js'
          );
          /* harmony import */ var graphql_tag__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/ __webpack_require__.n(
            graphql_tag__WEBPACK_IMPORTED_MODULE_11__
          );
          /* harmony reexport (default from non-harmony) */ __webpack_require__.d(
            __webpack_exports__,
            'gql',
            function () {
              return graphql_tag__WEBPACK_IMPORTED_MODULE_11___default.a;
            }
          );

          var resetCaches =
              graphql_tag__WEBPACK_IMPORTED_MODULE_11___default.a.resetCaches,
            disableFragmentWarnings =
              graphql_tag__WEBPACK_IMPORTED_MODULE_11___default.a
                .disableFragmentWarnings,
            enableExperimentalFragmentVariables =
              graphql_tag__WEBPACK_IMPORTED_MODULE_11___default.a
                .enableExperimentalFragmentVariables,
            disableExperimentalFragmentVariables =
              graphql_tag__WEBPACK_IMPORTED_MODULE_11___default.a
                .disableExperimentalFragmentVariables;

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/networkStatus.js':
        /*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/core/networkStatus.js ***!
  \***********************************************************/
        /*! exports provided: NetworkStatus, isNetworkRequestInFlight */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'NetworkStatus',
            function () {
              return NetworkStatus;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isNetworkRequestInFlight',
            function () {
              return isNetworkRequestInFlight;
            }
          );
          var NetworkStatus;
          (function (NetworkStatus) {
            NetworkStatus[(NetworkStatus['loading'] = 1)] = 'loading';
            NetworkStatus[(NetworkStatus['setVariables'] = 2)] = 'setVariables';
            NetworkStatus[(NetworkStatus['fetchMore'] = 3)] = 'fetchMore';
            NetworkStatus[(NetworkStatus['refetch'] = 4)] = 'refetch';
            NetworkStatus[(NetworkStatus['poll'] = 6)] = 'poll';
            NetworkStatus[(NetworkStatus['ready'] = 7)] = 'ready';
            NetworkStatus[(NetworkStatus['error'] = 8)] = 'error';
          })(NetworkStatus || (NetworkStatus = {}));
          function isNetworkRequestInFlight(networkStatus) {
            return networkStatus ? networkStatus < 7 : false;
          }
          //# sourceMappingURL=networkStatus.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/core/types.js':
        /*!***************************************************!*\
  !*** ./node_modules/@apollo/client/core/types.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          //# sourceMappingURL=types.js.map
          /***/
        },

      /***/ './node_modules/@apollo/client/errors/index.js':
        /*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/errors/index.js ***!
  \*****************************************************/
        /*! exports provided: isApolloError, ApolloError */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isApolloError',
            function () {
              return isApolloError;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloError',
            function () {
              return ApolloError;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          function isApolloError(err) {
            return err.hasOwnProperty('graphQLErrors');
          }
          var generateErrorMessage = function (err) {
            var message = '';
            if (
              Object(
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__[
                  'isNonEmptyArray'
                ]
              )(err.graphQLErrors)
            ) {
              err.graphQLErrors.forEach(function (graphQLError) {
                var errorMessage = graphQLError
                  ? graphQLError.message
                  : 'Error message not found.';
                message += errorMessage + '\n';
              });
            }
            if (err.networkError) {
              message += err.networkError.message + '\n';
            }
            message = message.replace(/\n$/, '');
            return message;
          };
          var ApolloError = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              ApolloError,
              _super
            );
            function ApolloError(_a) {
              var graphQLErrors = _a.graphQLErrors,
                networkError = _a.networkError,
                errorMessage = _a.errorMessage,
                extraInfo = _a.extraInfo;
              var _this = _super.call(this, errorMessage) || this;
              _this.graphQLErrors = graphQLErrors || [];
              _this.networkError = networkError || null;
              _this.message = errorMessage || generateErrorMessage(_this);
              _this.extraInfo = extraInfo;
              _this.__proto__ = ApolloError.prototype;
              return _this;
            }
            return ApolloError;
          })(Error);

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/ApolloLink.js':
        /*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/ApolloLink.js ***!
  \*************************************************************/
        /*! exports provided: ApolloLink */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloLink',
            function () {
              return ApolloLink;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utils/index.js */ './node_modules/@apollo/client/link/utils/index.js'
          );

          function passthrough(op, forward) {
            return forward
              ? forward(op)
              : _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                  'Observable'
                ].of();
          }
          function toLink(handler) {
            return typeof handler === 'function'
              ? new ApolloLink(handler)
              : handler;
          }
          function isTerminating(link) {
            return link.request.length <= 1;
          }
          var LinkError = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              LinkError,
              _super
            );
            function LinkError(message, link) {
              var _this = _super.call(this, message) || this;
              _this.link = link;
              return _this;
            }
            return LinkError;
          })(Error);
          var ApolloLink = (function () {
            function ApolloLink(request) {
              if (request) this.request = request;
            }
            ApolloLink.empty = function () {
              return new ApolloLink(function () {
                return _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                  'Observable'
                ].of();
              });
            };
            ApolloLink.from = function (links) {
              if (links.length === 0) return ApolloLink.empty();
              return links.map(toLink).reduce(function (x, y) {
                return x.concat(y);
              });
            };
            ApolloLink.split = function (test, left, right) {
              var leftLink = toLink(left);
              var rightLink = toLink(right || new ApolloLink(passthrough));
              if (isTerminating(leftLink) && isTerminating(rightLink)) {
                return new ApolloLink(function (operation) {
                  return test(operation)
                    ? leftLink.request(operation) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of()
                    : rightLink.request(operation) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of();
                });
              } else {
                return new ApolloLink(function (operation, forward) {
                  return test(operation)
                    ? leftLink.request(operation, forward) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of()
                    : rightLink.request(operation, forward) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of();
                });
              }
            };
            ApolloLink.execute = function (link, operation) {
              return (
                link.request(
                  Object(
                    _utils_index_js__WEBPACK_IMPORTED_MODULE_3__[
                      'createOperation'
                    ]
                  )(
                    operation.context,
                    Object(
                      _utils_index_js__WEBPACK_IMPORTED_MODULE_3__[
                        'transformOperation'
                      ]
                    )(
                      Object(
                        _utils_index_js__WEBPACK_IMPORTED_MODULE_3__[
                          'validateOperation'
                        ]
                      )(operation)
                    )
                  )
                ) ||
                _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                  'Observable'
                ].of()
              );
            };
            ApolloLink.concat = function (first, second) {
              var firstLink = toLink(first);
              if (isTerminating(firstLink)) {
                false ||
                  ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant'].warn(
                    new LinkError(
                      'You are calling concat on a terminating link, which will have no effect',
                      firstLink
                    )
                  );
                return firstLink;
              }
              var nextLink = toLink(second);
              if (isTerminating(nextLink)) {
                return new ApolloLink(function (operation) {
                  return (
                    firstLink.request(operation, function (op) {
                      return (
                        nextLink.request(op) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of()
                      );
                    }) ||
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                      'Observable'
                    ].of()
                  );
                });
              } else {
                return new ApolloLink(function (operation, forward) {
                  return (
                    firstLink.request(operation, function (op) {
                      return (
                        nextLink.request(op, forward) ||
                        _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                          'Observable'
                        ].of()
                      );
                    }) ||
                    _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                      'Observable'
                    ].of()
                  );
                });
              }
            };
            ApolloLink.prototype.split = function (test, left, right) {
              return this.concat(
                ApolloLink.split(
                  test,
                  left,
                  right || new ApolloLink(passthrough)
                )
              );
            };
            ApolloLink.prototype.concat = function (next) {
              return ApolloLink.concat(this, next);
            };
            ApolloLink.prototype.request = function (operation, forward) {
              throw false
                ? undefined
                : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                    'InvariantError'
                  ]('request is not implemented');
            };
            ApolloLink.prototype.onError = function (reason) {
              throw reason;
            };
            ApolloLink.prototype.setOnError = function (fn) {
              this.onError = fn;
              return this;
            };
            return ApolloLink;
          })();

          //# sourceMappingURL=ApolloLink.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/concat.js':
        /*!*********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/concat.js ***!
  \*********************************************************/
        /*! exports provided: concat */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'concat',
            function () {
              return concat;
            }
          );
          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );

          var concat =
            _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__['ApolloLink'].concat;
          //# sourceMappingURL=concat.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/empty.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/empty.js ***!
  \********************************************************/
        /*! exports provided: empty */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'empty',
            function () {
              return empty;
            }
          );
          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );

          var empty =
            _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__['ApolloLink'].empty;
          //# sourceMappingURL=empty.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/execute.js':
        /*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/execute.js ***!
  \**********************************************************/
        /*! exports provided: execute */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'execute',
            function () {
              return execute;
            }
          );
          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );

          var execute =
            _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__['ApolloLink'].execute;
          //# sourceMappingURL=execute.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/from.js':
        /*!*******************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/from.js ***!
  \*******************************************************/
        /*! exports provided: from */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'from',
            function () {
              return from;
            }
          );
          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );

          var from =
            _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__['ApolloLink'].from;
          //# sourceMappingURL=from.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/index.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/index.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./empty.js */ './node_modules/@apollo/client/link/core/empty.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'empty',
            function () {
              return _empty_js__WEBPACK_IMPORTED_MODULE_0__['empty'];
            }
          );

          /* harmony import */ var _from_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./from.js */ './node_modules/@apollo/client/link/core/from.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'from',
            function () {
              return _from_js__WEBPACK_IMPORTED_MODULE_1__['from'];
            }
          );

          /* harmony import */ var _split_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./split.js */ './node_modules/@apollo/client/link/core/split.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'split',
            function () {
              return _split_js__WEBPACK_IMPORTED_MODULE_2__['split'];
            }
          );

          /* harmony import */ var _concat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./concat.js */ './node_modules/@apollo/client/link/core/concat.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'concat',
            function () {
              return _concat_js__WEBPACK_IMPORTED_MODULE_3__['concat'];
            }
          );

          /* harmony import */ var _execute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./execute.js */ './node_modules/@apollo/client/link/core/execute.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'execute',
            function () {
              return _execute_js__WEBPACK_IMPORTED_MODULE_4__['execute'];
            }
          );

          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ApolloLink',
            function () {
              return _ApolloLink_js__WEBPACK_IMPORTED_MODULE_5__['ApolloLink'];
            }
          );

          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./types.js */ './node_modules/@apollo/client/link/core/types.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __webpack_require__.n(
            _types_js__WEBPACK_IMPORTED_MODULE_6__
          );
          /* harmony reexport (unknown) */ for (var __WEBPACK_IMPORT_KEY__ in _types_js__WEBPACK_IMPORTED_MODULE_6__)
            if (
              [
                'default',
                'empty',
                'from',
                'split',
                'concat',
                'execute',
                'ApolloLink',
              ].indexOf(__WEBPACK_IMPORT_KEY__) < 0
            )
              (function (key) {
                __webpack_require__.d(__webpack_exports__, key, function () {
                  return _types_js__WEBPACK_IMPORTED_MODULE_6__[key];
                });
              })(__WEBPACK_IMPORT_KEY__);

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/split.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/split.js ***!
  \********************************************************/
        /*! exports provided: split */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'split',
            function () {
              return split;
            }
          );
          /* harmony import */ var _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./ApolloLink.js */ './node_modules/@apollo/client/link/core/ApolloLink.js'
          );

          var split =
            _ApolloLink_js__WEBPACK_IMPORTED_MODULE_0__['ApolloLink'].split;
          //# sourceMappingURL=split.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/core/types.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/types.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          //# sourceMappingURL=types.js.map
          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/HttpLink.js':
        /*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/HttpLink.js ***!
  \***********************************************************/
        /*! exports provided: HttpLink */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'HttpLink',
            function () {
              return HttpLink;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../core/index.js */ './node_modules/@apollo/client/link/core/index.js'
          );
          /* harmony import */ var _createHttpLink_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./createHttpLink.js */ './node_modules/@apollo/client/link/http/createHttpLink.js'
          );

          var HttpLink = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              HttpLink,
              _super
            );
            function HttpLink(options) {
              if (options === void 0) {
                options = {};
              }
              var _this =
                _super.call(
                  this,
                  Object(
                    _createHttpLink_js__WEBPACK_IMPORTED_MODULE_2__[
                      'createHttpLink'
                    ]
                  )(options).request
                ) || this;
              _this.options = options;
              return _this;
            }
            return HttpLink;
          })(_core_index_js__WEBPACK_IMPORTED_MODULE_1__['ApolloLink']);

          //# sourceMappingURL=HttpLink.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/checkFetcher.js':
        /*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/checkFetcher.js ***!
  \***************************************************************/
        /*! exports provided: checkFetcher */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'checkFetcher',
            function () {
              return checkFetcher;
            }
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          var checkFetcher = function (fetcher) {
            if (!fetcher && typeof fetch === 'undefined') {
              throw false
                ? undefined
                : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__[
                    'InvariantError'
                  ](
                    "\n\"fetch\" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    "
                  );
            }
          };
          //# sourceMappingURL=checkFetcher.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/createHttpLink.js':
        /*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/createHttpLink.js ***!
  \*****************************************************************/
        /*! exports provided: createHttpLink */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createHttpLink',
            function () {
              return createHttpLink;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../core/index.js */ './node_modules/@apollo/client/link/core/index.js'
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );
          /* harmony import */ var _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./serializeFetchParameter.js */ './node_modules/@apollo/client/link/http/serializeFetchParameter.js'
          );
          /* harmony import */ var _selectURI_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./selectURI.js */ './node_modules/@apollo/client/link/http/selectURI.js'
          );
          /* harmony import */ var _parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./parseAndCheckHttpResponse.js */ './node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js'
          );
          /* harmony import */ var _checkFetcher_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./checkFetcher.js */ './node_modules/@apollo/client/link/http/checkFetcher.js'
          );
          /* harmony import */ var _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./selectHttpOptionsAndBody.js */ './node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js'
          );
          /* harmony import */ var _createSignalIfSupported_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./createSignalIfSupported.js */ './node_modules/@apollo/client/link/http/createSignalIfSupported.js'
          );
          /* harmony import */ var _rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
            /*! ./rewriteURIForGET.js */ './node_modules/@apollo/client/link/http/rewriteURIForGET.js'
          );
          /* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
            /*! ../utils/index.js */ './node_modules/@apollo/client/link/utils/index.js'
          );

          var createHttpLink = function (linkOptions) {
            if (linkOptions === void 0) {
              linkOptions = {};
            }
            var _a = linkOptions.uri,
              uri = _a === void 0 ? '/graphql' : _a,
              fetcher = linkOptions.fetch,
              includeExtensions = linkOptions.includeExtensions,
              useGETForQueries = linkOptions.useGETForQueries,
              requestOptions = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__rest']
              )(linkOptions, [
                'uri',
                'fetch',
                'includeExtensions',
                'useGETForQueries',
              ]);
            Object(
              _checkFetcher_js__WEBPACK_IMPORTED_MODULE_6__['checkFetcher']
            )(fetcher);
            if (!fetcher) {
              fetcher = fetch;
            }
            var linkConfig = {
              http: { includeExtensions: includeExtensions },
              options: requestOptions.fetchOptions,
              credentials: requestOptions.credentials,
              headers: requestOptions.headers,
            };
            return new _core_index_js__WEBPACK_IMPORTED_MODULE_1__[
              'ApolloLink'
            ](function (operation) {
              var chosenURI = Object(
                _selectURI_js__WEBPACK_IMPORTED_MODULE_4__['selectURI']
              )(operation, uri);
              var context = operation.getContext();
              var clientAwarenessHeaders = {};
              if (context.clientAwareness) {
                var _a = context.clientAwareness,
                  name_1 = _a.name,
                  version = _a.version;
                if (name_1) {
                  clientAwarenessHeaders['apollographql-client-name'] = name_1;
                }
                if (version) {
                  clientAwarenessHeaders[
                    'apollographql-client-version'
                  ] = version;
                }
              }
              var contextHeaders = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  clientAwarenessHeaders
                ),
                context.headers
              );
              var contextConfig = {
                http: context.http,
                options: context.fetchOptions,
                credentials: context.credentials,
                headers: contextHeaders,
              };
              var _b = Object(
                  _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_7__[
                    'selectHttpOptionsAndBody'
                  ]
                )(
                  operation,
                  _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_7__[
                    'fallbackHttpConfig'
                  ],
                  linkConfig,
                  contextConfig
                ),
                options = _b.options,
                body = _b.body;
              var controller;
              if (!options.signal) {
                var _c = Object(
                    _createSignalIfSupported_js__WEBPACK_IMPORTED_MODULE_8__[
                      'createSignalIfSupported'
                    ]
                  )(),
                  _controller = _c.controller,
                  signal = _c.signal;
                controller = _controller;
                if (controller) options.signal = signal;
              }
              var definitionIsMutation = function (d) {
                return (
                  d.kind === 'OperationDefinition' && d.operation === 'mutation'
                );
              };
              if (
                useGETForQueries &&
                !operation.query.definitions.some(definitionIsMutation)
              ) {
                options.method = 'GET';
              }
              if (options.method === 'GET') {
                var _d = Object(
                    _rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_9__[
                      'rewriteURIForGET'
                    ]
                  )(chosenURI, body),
                  newURI = _d.newURI,
                  parseError = _d.parseError;
                if (parseError) {
                  return Object(
                    _utils_index_js__WEBPACK_IMPORTED_MODULE_10__['fromError']
                  )(parseError);
                }
                chosenURI = newURI;
              } else {
                try {
                  options.body = Object(
                    _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_3__[
                      'serializeFetchParameter'
                    ]
                  )(body, 'Payload');
                } catch (parseError) {
                  return Object(
                    _utils_index_js__WEBPACK_IMPORTED_MODULE_10__['fromError']
                  )(parseError);
                }
              }
              return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__[
                'Observable'
              ](function (observer) {
                fetcher(chosenURI, options)
                  .then(function (response) {
                    operation.setContext({ response: response });
                    return response;
                  })
                  .then(
                    Object(
                      _parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_5__[
                        'parseAndCheckHttpResponse'
                      ]
                    )(operation)
                  )
                  .then(function (result) {
                    observer.next(result);
                    observer.complete();
                    return result;
                  })
                  .catch(function (err) {
                    if (err.name === 'AbortError') return;
                    if (err.result && err.result.errors && err.result.data) {
                      observer.next(err.result);
                    }
                    observer.error(err);
                  });
                return function () {
                  if (controller) controller.abort();
                };
              });
            });
          };
          //# sourceMappingURL=createHttpLink.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/createSignalIfSupported.js':
        /*!**************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/createSignalIfSupported.js ***!
  \**************************************************************************/
        /*! exports provided: createSignalIfSupported */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createSignalIfSupported',
            function () {
              return createSignalIfSupported;
            }
          );
          var createSignalIfSupported = function () {
            if (typeof AbortController === 'undefined')
              return { controller: false, signal: false };
            var controller = new AbortController();
            var signal = controller.signal;
            return { controller: controller, signal: signal };
          };
          //# sourceMappingURL=createSignalIfSupported.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/index.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/index.js ***!
  \********************************************************/
        /*! exports provided: parseAndCheckHttpResponse, serializeFetchParameter, fallbackHttpConfig, selectHttpOptionsAndBody, checkFetcher, createSignalIfSupported, selectURI, createHttpLink, HttpLink, rewriteURIForGET */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./parseAndCheckHttpResponse.js */ './node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'parseAndCheckHttpResponse',
            function () {
              return _parseAndCheckHttpResponse_js__WEBPACK_IMPORTED_MODULE_0__[
                'parseAndCheckHttpResponse'
              ];
            }
          );

          /* harmony import */ var _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./serializeFetchParameter.js */ './node_modules/@apollo/client/link/http/serializeFetchParameter.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'serializeFetchParameter',
            function () {
              return _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_1__[
                'serializeFetchParameter'
              ];
            }
          );

          /* harmony import */ var _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./selectHttpOptionsAndBody.js */ './node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fallbackHttpConfig',
            function () {
              return _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_2__[
                'fallbackHttpConfig'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'selectHttpOptionsAndBody',
            function () {
              return _selectHttpOptionsAndBody_js__WEBPACK_IMPORTED_MODULE_2__[
                'selectHttpOptionsAndBody'
              ];
            }
          );

          /* harmony import */ var _checkFetcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./checkFetcher.js */ './node_modules/@apollo/client/link/http/checkFetcher.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'checkFetcher',
            function () {
              return _checkFetcher_js__WEBPACK_IMPORTED_MODULE_3__[
                'checkFetcher'
              ];
            }
          );

          /* harmony import */ var _createSignalIfSupported_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./createSignalIfSupported.js */ './node_modules/@apollo/client/link/http/createSignalIfSupported.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createSignalIfSupported',
            function () {
              return _createSignalIfSupported_js__WEBPACK_IMPORTED_MODULE_4__[
                'createSignalIfSupported'
              ];
            }
          );

          /* harmony import */ var _selectURI_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./selectURI.js */ './node_modules/@apollo/client/link/http/selectURI.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'selectURI',
            function () {
              return _selectURI_js__WEBPACK_IMPORTED_MODULE_5__['selectURI'];
            }
          );

          /* harmony import */ var _createHttpLink_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./createHttpLink.js */ './node_modules/@apollo/client/link/http/createHttpLink.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createHttpLink',
            function () {
              return _createHttpLink_js__WEBPACK_IMPORTED_MODULE_6__[
                'createHttpLink'
              ];
            }
          );

          /* harmony import */ var _HttpLink_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./HttpLink.js */ './node_modules/@apollo/client/link/http/HttpLink.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'HttpLink',
            function () {
              return _HttpLink_js__WEBPACK_IMPORTED_MODULE_7__['HttpLink'];
            }
          );

          /* harmony import */ var _rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./rewriteURIForGET.js */ './node_modules/@apollo/client/link/http/rewriteURIForGET.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'rewriteURIForGET',
            function () {
              return _rewriteURIForGET_js__WEBPACK_IMPORTED_MODULE_8__[
                'rewriteURIForGET'
              ];
            }
          );

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js ***!
  \****************************************************************************/
        /*! exports provided: parseAndCheckHttpResponse */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'parseAndCheckHttpResponse',
            function () {
              return parseAndCheckHttpResponse;
            }
          );
          /* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../utils/index.js */ './node_modules/@apollo/client/link/utils/index.js'
          );

          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function parseAndCheckHttpResponse(operations) {
            return function (response) {
              return response
                .text()
                .then(function (bodyText) {
                  try {
                    return JSON.parse(bodyText);
                  } catch (err) {
                    var parseError = err;
                    parseError.name = 'ServerParseError';
                    parseError.response = response;
                    parseError.statusCode = response.status;
                    parseError.bodyText = bodyText;
                    throw parseError;
                  }
                })
                .then(function (result) {
                  if (response.status >= 300) {
                    Object(
                      _utils_index_js__WEBPACK_IMPORTED_MODULE_0__[
                        'throwServerError'
                      ]
                    )(
                      response,
                      result,
                      'Response not successful: Received status code ' +
                        response.status
                    );
                  }
                  if (
                    !Array.isArray(result) &&
                    !hasOwnProperty.call(result, 'data') &&
                    !hasOwnProperty.call(result, 'errors')
                  ) {
                    Object(
                      _utils_index_js__WEBPACK_IMPORTED_MODULE_0__[
                        'throwServerError'
                      ]
                    )(
                      response,
                      result,
                      "Server response was missing for query '" +
                        (Array.isArray(operations)
                          ? operations.map(function (op) {
                              return op.operationName;
                            })
                          : operations.operationName) +
                        "'."
                    );
                  }
                  return result;
                });
            };
          }
          //# sourceMappingURL=parseAndCheckHttpResponse.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/rewriteURIForGET.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/rewriteURIForGET.js ***!
  \*******************************************************************/
        /*! exports provided: rewriteURIForGET */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'rewriteURIForGET',
            function () {
              return rewriteURIForGET;
            }
          );
          /* harmony import */ var _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./serializeFetchParameter.js */ './node_modules/@apollo/client/link/http/serializeFetchParameter.js'
          );

          function rewriteURIForGET(chosenURI, body) {
            var queryParams = [];
            var addQueryParam = function (key, value) {
              queryParams.push(key + '=' + encodeURIComponent(value));
            };
            if ('query' in body) {
              addQueryParam('query', body.query);
            }
            if (body.operationName) {
              addQueryParam('operationName', body.operationName);
            }
            if (body.variables) {
              var serializedVariables = void 0;
              try {
                serializedVariables = Object(
                  _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__[
                    'serializeFetchParameter'
                  ]
                )(body.variables, 'Variables map');
              } catch (parseError) {
                return { parseError: parseError };
              }
              addQueryParam('variables', serializedVariables);
            }
            if (body.extensions) {
              var serializedExtensions = void 0;
              try {
                serializedExtensions = Object(
                  _serializeFetchParameter_js__WEBPACK_IMPORTED_MODULE_0__[
                    'serializeFetchParameter'
                  ]
                )(body.extensions, 'Extensions map');
              } catch (parseError) {
                return { parseError: parseError };
              }
              addQueryParam('extensions', serializedExtensions);
            }
            var fragment = '',
              preFragment = chosenURI;
            var fragmentStart = chosenURI.indexOf('#');
            if (fragmentStart !== -1) {
              fragment = chosenURI.substr(fragmentStart);
              preFragment = chosenURI.substr(0, fragmentStart);
            }
            var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
            var newURI =
              preFragment +
              queryParamsPrefix +
              queryParams.join('&') +
              fragment;
            return { newURI: newURI };
          }
          //# sourceMappingURL=rewriteURIForGET.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js':
        /*!***************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js ***!
  \***************************************************************************/
        /*! exports provided: fallbackHttpConfig, selectHttpOptionsAndBody */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'fallbackHttpConfig',
            function () {
              return fallbackHttpConfig;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'selectHttpOptionsAndBody',
            function () {
              return selectHttpOptionsAndBody;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! graphql/language/printer */ './node_modules/graphql/language/printer.js'
          );
          /* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
            graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__
          );

          var defaultHttpOptions = {
            includeQuery: true,
            includeExtensions: false,
          };
          var defaultHeaders = {
            accept: '*/*',
            'content-type': 'application/json',
          };
          var defaultOptions = {
            method: 'POST',
          };
          var fallbackHttpConfig = {
            http: defaultHttpOptions,
            headers: defaultHeaders,
            options: defaultOptions,
          };
          var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
            var configs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              configs[_i - 2] = arguments[_i];
            }
            var options = Object(
              tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
            )(
              Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                {},
                fallbackConfig.options
              ),
              {
                headers: fallbackConfig.headers,
                credentials: fallbackConfig.credentials,
              }
            );
            var http = fallbackConfig.http || {};
            configs.forEach(function (config) {
              options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    options
                  ),
                  config.options
                ),
                {
                  headers: Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                  )(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      options.headers
                    ),
                    config.headers
                  ),
                }
              );
              if (config.credentials) options.credentials = config.credentials;
              http = Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  http
                ),
                config.http
              );
            });
            var operationName = operation.operationName,
              extensions = operation.extensions,
              variables = operation.variables,
              query = operation.query;
            var body = { operationName: operationName, variables: variables };
            if (http.includeExtensions) body.extensions = extensions;
            if (http.includeQuery)
              body.query = Object(
                graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__['print']
              )(query);
            return {
              options: options,
              body: body,
            };
          };
          //# sourceMappingURL=selectHttpOptionsAndBody.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/selectURI.js':
        /*!************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/selectURI.js ***!
  \************************************************************/
        /*! exports provided: selectURI */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'selectURI',
            function () {
              return selectURI;
            }
          );
          var selectURI = function (operation, fallbackURI) {
            var context = operation.getContext();
            var contextURI = context.uri;
            if (contextURI) {
              return contextURI;
            } else if (typeof fallbackURI === 'function') {
              return fallbackURI(operation);
            } else {
              return fallbackURI || '/graphql';
            }
          };
          //# sourceMappingURL=selectURI.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/http/serializeFetchParameter.js':
        /*!**************************************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/serializeFetchParameter.js ***!
  \**************************************************************************/
        /*! exports provided: serializeFetchParameter */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'serializeFetchParameter',
            function () {
              return serializeFetchParameter;
            }
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          var serializeFetchParameter = function (p, label) {
            var serialized;
            try {
              serialized = JSON.stringify(p);
            } catch (e) {
              var parseError = false
                ? undefined
                : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__[
                    'InvariantError'
                  ](
                    'Network request failed. ' +
                      label +
                      ' is not serializable: ' +
                      e.message
                  );
              parseError.parseError = e;
              throw parseError;
            }
            return serialized;
          };
          //# sourceMappingURL=serializeFetchParameter.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/createOperation.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/createOperation.js ***!
  \*******************************************************************/
        /*! exports provided: createOperation */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createOperation',
            function () {
              return createOperation;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );

          function createOperation(starting, operation) {
            var context = Object(
              tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
            )({}, starting);
            var setContext = function (next) {
              if (typeof next === 'function') {
                context = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    context
                  ),
                  next(context)
                );
              } else {
                context = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    context
                  ),
                  next
                );
              }
            };
            var getContext = function () {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                {},
                context
              );
            };
            Object.defineProperty(operation, 'setContext', {
              enumerable: false,
              value: setContext,
            });
            Object.defineProperty(operation, 'getContext', {
              enumerable: false,
              value: getContext,
            });
            return operation;
          }
          //# sourceMappingURL=createOperation.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/fromError.js':
        /*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/fromError.js ***!
  \*************************************************************/
        /*! exports provided: fromError */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'fromError',
            function () {
              return fromError;
            }
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          function fromError(errorValue) {
            return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__[
              'Observable'
            ](function (observer) {
              observer.error(errorValue);
            });
          }
          //# sourceMappingURL=fromError.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/fromPromise.js':
        /*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/fromPromise.js ***!
  \***************************************************************/
        /*! exports provided: fromPromise */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'fromPromise',
            function () {
              return fromPromise;
            }
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          function fromPromise(promise) {
            return new _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__[
              'Observable'
            ](function (observer) {
              promise
                .then(function (value) {
                  observer.next(value);
                  observer.complete();
                })
                .catch(observer.error.bind(observer));
            });
          }
          //# sourceMappingURL=fromPromise.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/index.js':
        /*!*********************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/index.js ***!
  \*********************************************************/
        /*! exports provided: fromError, toPromise, fromPromise, throwServerError, validateOperation, createOperation, transformOperation */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _fromError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./fromError.js */ './node_modules/@apollo/client/link/utils/fromError.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fromError',
            function () {
              return _fromError_js__WEBPACK_IMPORTED_MODULE_0__['fromError'];
            }
          );

          /* harmony import */ var _toPromise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./toPromise.js */ './node_modules/@apollo/client/link/utils/toPromise.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toPromise',
            function () {
              return _toPromise_js__WEBPACK_IMPORTED_MODULE_1__['toPromise'];
            }
          );

          /* harmony import */ var _fromPromise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./fromPromise.js */ './node_modules/@apollo/client/link/utils/fromPromise.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'fromPromise',
            function () {
              return _fromPromise_js__WEBPACK_IMPORTED_MODULE_2__[
                'fromPromise'
              ];
            }
          );

          /* harmony import */ var _throwServerError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./throwServerError.js */ './node_modules/@apollo/client/link/utils/throwServerError.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'throwServerError',
            function () {
              return _throwServerError_js__WEBPACK_IMPORTED_MODULE_3__[
                'throwServerError'
              ];
            }
          );

          /* harmony import */ var _validateOperation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./validateOperation.js */ './node_modules/@apollo/client/link/utils/validateOperation.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'validateOperation',
            function () {
              return _validateOperation_js__WEBPACK_IMPORTED_MODULE_4__[
                'validateOperation'
              ];
            }
          );

          /* harmony import */ var _createOperation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./createOperation.js */ './node_modules/@apollo/client/link/utils/createOperation.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createOperation',
            function () {
              return _createOperation_js__WEBPACK_IMPORTED_MODULE_5__[
                'createOperation'
              ];
            }
          );

          /* harmony import */ var _transformOperation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./transformOperation.js */ './node_modules/@apollo/client/link/utils/transformOperation.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'transformOperation',
            function () {
              return _transformOperation_js__WEBPACK_IMPORTED_MODULE_6__[
                'transformOperation'
              ];
            }
          );

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/throwServerError.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/throwServerError.js ***!
  \********************************************************************/
        /*! exports provided: throwServerError */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'throwServerError',
            function () {
              return throwServerError;
            }
          );
          var throwServerError = function (response, result, message) {
            var error = new Error(message);
            error.name = 'ServerError';
            error.response = response;
            error.statusCode = response.status;
            error.result = result;
            throw error;
          };
          //# sourceMappingURL=throwServerError.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/toPromise.js':
        /*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/toPromise.js ***!
  \*************************************************************/
        /*! exports provided: toPromise */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toPromise',
            function () {
              return toPromise;
            }
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          function toPromise(observable) {
            var completed = false;
            return new Promise(function (resolve, reject) {
              observable.subscribe({
                next: function (data) {
                  if (completed) {
                    false ||
                      ts_invariant__WEBPACK_IMPORTED_MODULE_0__[
                        'invariant'
                      ].warn(
                        'Promise Wrapper does not support multiple results from Observable'
                      );
                  } else {
                    completed = true;
                    resolve(data);
                  }
                },
                error: reject,
              });
            });
          }
          //# sourceMappingURL=toPromise.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/transformOperation.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/transformOperation.js ***!
  \**********************************************************************/
        /*! exports provided: transformOperation */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'transformOperation',
            function () {
              return transformOperation;
            }
          );
          /* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../utilities/index.js */ './node_modules/@apollo/client/utilities/index.js'
          );

          function transformOperation(operation) {
            var transformedOperation = {
              variables: operation.variables || {},
              extensions: operation.extensions || {},
              operationName: operation.operationName,
              query: operation.query,
            };
            if (!transformedOperation.operationName) {
              transformedOperation.operationName =
                typeof transformedOperation.query !== 'string'
                  ? Object(
                      _utilities_index_js__WEBPACK_IMPORTED_MODULE_0__[
                        'getOperationName'
                      ]
                    )(transformedOperation.query) || undefined
                  : '';
            }
            return transformedOperation;
          }
          //# sourceMappingURL=transformOperation.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/link/utils/validateOperation.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/validateOperation.js ***!
  \*********************************************************************/
        /*! exports provided: validateOperation */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'validateOperation',
            function () {
              return validateOperation;
            }
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          function validateOperation(operation) {
            var OPERATION_FIELDS = [
              'query',
              'operationName',
              'variables',
              'extensions',
              'context',
            ];
            for (
              var _i = 0, _a = Object.keys(operation);
              _i < _a.length;
              _i++
            ) {
              var key = _a[_i];
              if (OPERATION_FIELDS.indexOf(key) < 0) {
                throw false
                  ? undefined
                  : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__[
                      'InvariantError'
                    ]('illegal argument: ' + key);
              }
            }
            return operation;
          }
          //# sourceMappingURL=validateOperation.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/arrays.js':
        /*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/arrays.js ***!
  \****************************************************************/
        /*! exports provided: isNonEmptyArray */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isNonEmptyArray',
            function () {
              return isNonEmptyArray;
            }
          );
          function isNonEmptyArray(value) {
            return Array.isArray(value) && value.length > 0;
          }
          //# sourceMappingURL=arrays.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/canUse.js':
        /*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/canUse.js ***!
  \****************************************************************/
        /*! exports provided: canUseWeakMap */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'canUseWeakMap',
            function () {
              return canUseWeakMap;
            }
          );
          var canUseWeakMap =
            typeof WeakMap === 'function' &&
            !(
              typeof navigator === 'object' &&
              navigator.product === 'ReactNative'
            );
          //# sourceMappingURL=canUse.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/cloneDeep.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/cloneDeep.js ***!
  \*******************************************************************/
        /*! exports provided: cloneDeep */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'cloneDeep',
            function () {
              return cloneDeep;
            }
          );
          var toString = Object.prototype.toString;
          function cloneDeep(value) {
            return cloneDeepHelper(value);
          }
          function cloneDeepHelper(val, seen) {
            switch (toString.call(val)) {
              case '[object Array]': {
                seen = seen || new Map();
                if (seen.has(val)) return seen.get(val);
                var copy_1 = val.slice(0);
                seen.set(val, copy_1);
                copy_1.forEach(function (child, i) {
                  copy_1[i] = cloneDeepHelper(child, seen);
                });
                return copy_1;
              }
              case '[object Object]': {
                seen = seen || new Map();
                if (seen.has(val)) return seen.get(val);
                var copy_2 = Object.create(Object.getPrototypeOf(val));
                seen.set(val, copy_2);
                Object.keys(val).forEach(function (key) {
                  copy_2[key] = cloneDeepHelper(val[key], seen);
                });
                return copy_2;
              }
              default:
                return val;
            }
          }
          //# sourceMappingURL=cloneDeep.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/compact.js':
        /*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/compact.js ***!
  \*****************************************************************/
        /*! exports provided: compact */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'compact',
            function () {
              return compact;
            }
          );
          function compact() {
            var objects = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              objects[_i] = arguments[_i];
            }
            var result = Object.create(null);
            objects.forEach(function (obj) {
              if (!obj) return;
              Object.keys(obj).forEach(function (key) {
                var value = obj[key];
                if (value !== void 0) {
                  result[key] = value;
                }
              });
            });
            return result;
          }
          //# sourceMappingURL=compact.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/environment.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/environment.js ***!
  \*********************************************************************/
        /*! exports provided: getEnv, isEnv, isDevelopment, isTest */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* WEBPACK VAR INJECTION */ (function (process) {
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'getEnv',
              function () {
                return getEnv;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'isEnv',
              function () {
                return isEnv;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'isDevelopment',
              function () {
                return isDevelopment;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'isTest',
              function () {
                return isTest;
              }
            );
            function getEnv() {
              if (typeof process !== 'undefined' && 'development') {
                return 'development';
              }
              return 'development';
            }
            function isEnv(env) {
              return getEnv() === env;
            }
            function isDevelopment() {
              return isEnv('development') === true;
            }
            function isTest() {
              return isEnv('test') === true;
            }
            //# sourceMappingURL=environment.js.map
            /* WEBPACK VAR INJECTION */
          }.call(
            this,
            __webpack_require__(
              /*! ./../../../../process/browser.js */ './node_modules/process/browser.js'
            )
          ));

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/errorHandling.js':
        /*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/errorHandling.js ***!
  \***********************************************************************/
        /*! exports provided: graphQLResultHasError */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'graphQLResultHasError',
            function () {
              return graphQLResultHasError;
            }
          );
          function graphQLResultHasError(result) {
            return (result.errors && result.errors.length > 0) || false;
          }
          //# sourceMappingURL=errorHandling.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/filterInPlace.js':
        /*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/filterInPlace.js ***!
  \***********************************************************************/
        /*! exports provided: filterInPlace */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'filterInPlace',
            function () {
              return filterInPlace;
            }
          );
          function filterInPlace(array, test, context) {
            var target = 0;
            array.forEach(function (elem, i) {
              if (test.call(this, elem, i, array)) {
                array[target++] = elem;
              }
            }, context);
            array.length = target;
            return array;
          }
          //# sourceMappingURL=filterInPlace.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js':
        /*!*************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js ***!
  \*************************************************************************/
        /*! exports provided: maybeDeepFreeze */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'maybeDeepFreeze',
            function () {
              return maybeDeepFreeze;
            }
          );
          /* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./environment.js */ './node_modules/@apollo/client/utilities/common/environment.js'
          );

          function isObject(value) {
            return value !== null && typeof value === 'object';
          }
          function deepFreeze(value) {
            var workSet = new Set([value]);
            workSet.forEach(function (obj) {
              if (isObject(obj)) {
                if (!Object.isFrozen(obj)) Object.freeze(obj);
                Object.getOwnPropertyNames(obj).forEach(function (name) {
                  if (isObject(obj[name])) workSet.add(obj[name]);
                });
              }
            });
            return value;
          }
          function maybeDeepFreeze(obj) {
            if (
              true &&
              (Object(
                _environment_js__WEBPACK_IMPORTED_MODULE_0__['isDevelopment']
              )() ||
                Object(
                  _environment_js__WEBPACK_IMPORTED_MODULE_0__['isTest']
                )())
            ) {
              deepFreeze(obj);
            }
            return obj;
          }
          //# sourceMappingURL=maybeDeepFreeze.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/common/mergeDeep.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/mergeDeep.js ***!
  \*******************************************************************/
        /*! exports provided: mergeDeep, mergeDeepArray, DeepMerger */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeDeep',
            function () {
              return mergeDeep;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeDeepArray',
            function () {
              return mergeDeepArray;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'DeepMerger',
            function () {
              return DeepMerger;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );

          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function mergeDeep() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              sources[_i] = arguments[_i];
            }
            return mergeDeepArray(sources);
          }
          function mergeDeepArray(sources) {
            var target = sources[0] || {};
            var count = sources.length;
            if (count > 1) {
              var merger = new DeepMerger();
              for (var i = 1; i < count; ++i) {
                target = merger.merge(target, sources[i]);
              }
            }
            return target;
          }
          function isObject(obj) {
            return obj !== null && typeof obj === 'object';
          }
          var defaultReconciler = function (target, source, property) {
            return this.merge(target[property], source[property]);
          };
          var DeepMerger = (function () {
            function DeepMerger(reconciler) {
              if (reconciler === void 0) {
                reconciler = defaultReconciler;
              }
              this.reconciler = reconciler;
              this.isObject = isObject;
              this.pastCopies = new Set();
            }
            DeepMerger.prototype.merge = function (target, source) {
              var _this = this;
              var context = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                context[_i - 2] = arguments[_i];
              }
              if (isObject(source) && isObject(target)) {
                Object.keys(source).forEach(function (sourceKey) {
                  if (hasOwnProperty.call(target, sourceKey)) {
                    var targetValue = target[sourceKey];
                    if (source[sourceKey] !== targetValue) {
                      var result = _this.reconciler.apply(
                        _this,
                        Object(
                          tslib__WEBPACK_IMPORTED_MODULE_0__['__spreadArrays']
                        )([target, source, sourceKey], context)
                      );
                      if (result !== targetValue) {
                        target = _this.shallowCopyForMerge(target);
                        target[sourceKey] = result;
                      }
                    }
                  } else {
                    target = _this.shallowCopyForMerge(target);
                    target[sourceKey] = source[sourceKey];
                  }
                });
                return target;
              }
              return source;
            };
            DeepMerger.prototype.shallowCopyForMerge = function (value) {
              if (isObject(value) && !this.pastCopies.has(value)) {
                if (Array.isArray(value)) {
                  value = value.slice(0);
                } else {
                  value = Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                  )({ __proto__: Object.getPrototypeOf(value) }, value);
                }
                this.pastCopies.add(value);
              }
              return value;
            };
            return DeepMerger;
          })();

          //# sourceMappingURL=mergeDeep.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/graphql/directives.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/directives.js ***!
  \*********************************************************************/
        /*! exports provided: shouldInclude, getDirectiveNames, hasDirectives, hasClientExports, getInclusionDirectives */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'shouldInclude',
            function () {
              return shouldInclude;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getDirectiveNames',
            function () {
              return getDirectiveNames;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hasDirectives',
            function () {
              return hasDirectives;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hasClientExports',
            function () {
              return hasClientExports;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getInclusionDirectives',
            function () {
              return getInclusionDirectives;
            }
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! graphql/language/visitor */ './node_modules/graphql/language/visitor.js'
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          function shouldInclude(_a, variables) {
            var directives = _a.directives;
            if (!directives || !directives.length) {
              return true;
            }
            return getInclusionDirectives(directives).every(function (_a) {
              var directive = _a.directive,
                ifArgument = _a.ifArgument;
              var evaledValue = false;
              if (ifArgument.value.kind === 'Variable') {
                evaledValue =
                  variables && variables[ifArgument.value.name.value];
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                    )(
                      evaledValue !== void 0,
                      'Invalid variable referenced in @' +
                        directive.name.value +
                        ' directive.'
                    );
              } else {
                evaledValue = ifArgument.value.value;
              }
              return directive.name.value === 'skip'
                ? !evaledValue
                : evaledValue;
            });
          }
          function getDirectiveNames(root) {
            var names = [];
            Object(
              graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__['visit']
            )(root, {
              Directive: function (node) {
                names.push(node.name.value);
              },
            });
            return names;
          }
          function hasDirectives(names, root) {
            return getDirectiveNames(root).some(function (name) {
              return names.indexOf(name) > -1;
            });
          }
          function hasClientExports(document) {
            return (
              document &&
              hasDirectives(['client'], document) &&
              hasDirectives(['export'], document)
            );
          }
          function isInclusionDirective(_a) {
            var value = _a.name.value;
            return value === 'skip' || value === 'include';
          }
          function getInclusionDirectives(directives) {
            var result = [];
            if (directives && directives.length) {
              directives.forEach(function (directive) {
                if (!isInclusionDirective(directive)) return;
                var directiveArguments = directive.arguments;
                var directiveName = directive.name.value;
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                    )(
                      directiveArguments && directiveArguments.length === 1,
                      'Incorrect number of arguments for the @' +
                        directiveName +
                        ' directive.'
                    );
                var ifArgument = directiveArguments[0];
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                    )(
                      ifArgument.name && ifArgument.name.value === 'if',
                      'Invalid argument for the @' +
                        directiveName +
                        ' directive.'
                    );
                var ifValue = ifArgument.value;
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                    )(
                      ifValue &&
                        (ifValue.kind === 'Variable' ||
                          ifValue.kind === 'BooleanValue'),
                      'Argument for the @' +
                        directiveName +
                        ' directive must be a variable or a boolean value.'
                    );
                result.push({ directive: directive, ifArgument: ifArgument });
              });
            }
            return result;
          }
          //# sourceMappingURL=directives.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/graphql/fragments.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/fragments.js ***!
  \********************************************************************/
        /*! exports provided: getFragmentQueryDocument, createFragmentMap, getFragmentFromSelection */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentQueryDocument',
            function () {
              return getFragmentQueryDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createFragmentMap',
            function () {
              return createFragmentMap;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentFromSelection',
            function () {
              return getFragmentFromSelection;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );

          function getFragmentQueryDocument(document, fragmentName) {
            var actualFragmentName = fragmentName;
            var fragments = [];
            document.definitions.forEach(function (definition) {
              if (definition.kind === 'OperationDefinition') {
                throw false
                  ? undefined
                  : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                      'InvariantError'
                    ](
                      'Found a ' +
                        definition.operation +
                        ' operation' +
                        (definition.name
                          ? " named '" + definition.name.value + "'"
                          : '') +
                        '. ' +
                        'No operations are allowed when using a fragment as a query. Only fragments are allowed.'
                    );
              }
              if (definition.kind === 'FragmentDefinition') {
                fragments.push(definition);
              }
            });
            if (typeof actualFragmentName === 'undefined') {
              false
                ? undefined
                : Object(
                    ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                  )(
                    fragments.length === 1,
                    'Found ' +
                      fragments.length +
                      ' fragments. `fragmentName` must be provided when there is not exactly 1 fragment.'
                  );
              actualFragmentName = fragments[0].name.value;
            }
            var query = Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
              Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                {},
                document
              ),
              {
                definitions: Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__spreadArrays']
                )(
                  [
                    {
                      kind: 'OperationDefinition',
                      operation: 'query',
                      selectionSet: {
                        kind: 'SelectionSet',
                        selections: [
                          {
                            kind: 'FragmentSpread',
                            name: {
                              kind: 'Name',
                              value: actualFragmentName,
                            },
                          },
                        ],
                      },
                    },
                  ],
                  document.definitions
                ),
              }
            );
            return query;
          }
          function createFragmentMap(fragments) {
            if (fragments === void 0) {
              fragments = [];
            }
            var symTable = {};
            fragments.forEach(function (fragment) {
              symTable[fragment.name.value] = fragment;
            });
            return symTable;
          }
          function getFragmentFromSelection(selection, fragmentMap) {
            switch (selection.kind) {
              case 'InlineFragment':
                return selection;
              case 'FragmentSpread': {
                var fragment = fragmentMap && fragmentMap[selection.name.value];
                false
                  ? undefined
                  : Object(
                      ts_invariant__WEBPACK_IMPORTED_MODULE_1__['invariant']
                    )(
                      fragment,
                      'No fragment named ' + selection.name.value + '.'
                    );
                return fragment;
              }
              default:
                return null;
            }
          }
          //# sourceMappingURL=fragments.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/graphql/getFromAST.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/getFromAST.js ***!
  \*********************************************************************/
        /*! exports provided: checkDocument, getOperationDefinition, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, getDefaultValues */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'checkDocument',
            function () {
              return checkDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getOperationDefinition',
            function () {
              return getOperationDefinition;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getOperationName',
            function () {
              return getOperationName;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentDefinitions',
            function () {
              return getFragmentDefinitions;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getQueryDefinition',
            function () {
              return getQueryDefinition;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentDefinition',
            function () {
              return getFragmentDefinition;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getMainDefinition',
            function () {
              return getMainDefinition;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getDefaultValues',
            function () {
              return getDefaultValues;
            }
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _storeUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./storeUtils.js */ './node_modules/@apollo/client/utilities/graphql/storeUtils.js'
          );

          function checkDocument(doc) {
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  doc && doc.kind === 'Document',
                  'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql'
                );
            var operations = doc.definitions
              .filter(function (d) {
                return d.kind !== 'FragmentDefinition';
              })
              .map(function (definition) {
                if (definition.kind !== 'OperationDefinition') {
                  throw false
                    ? undefined
                    : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__[
                        'InvariantError'
                      ](
                        'Schema type definitions not allowed in queries. Found: "' +
                          definition.kind +
                          '"'
                      );
                }
                return definition;
              });
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  operations.length <= 1,
                  'Ambiguous GraphQL document: contains ' +
                    operations.length +
                    ' operations'
                );
            return doc;
          }
          function getOperationDefinition(doc) {
            checkDocument(doc);
            return doc.definitions.filter(function (definition) {
              return definition.kind === 'OperationDefinition';
            })[0];
          }
          function getOperationName(doc) {
            return (
              doc.definitions
                .filter(function (definition) {
                  return (
                    definition.kind === 'OperationDefinition' && definition.name
                  );
                })
                .map(function (x) {
                  return x.name.value;
                })[0] || null
            );
          }
          function getFragmentDefinitions(doc) {
            return doc.definitions.filter(function (definition) {
              return definition.kind === 'FragmentDefinition';
            });
          }
          function getQueryDefinition(doc) {
            var queryDef = getOperationDefinition(doc);
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  queryDef && queryDef.operation === 'query',
                  'Must contain a query definition.'
                );
            return queryDef;
          }
          function getFragmentDefinition(doc) {
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  doc.kind === 'Document',
                  'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql'
                );
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  doc.definitions.length <= 1,
                  'Fragment must have exactly one definition.'
                );
            var fragmentDef = doc.definitions[0];
            false
              ? undefined
              : Object(ts_invariant__WEBPACK_IMPORTED_MODULE_0__['invariant'])(
                  fragmentDef.kind === 'FragmentDefinition',
                  'Must be a fragment definition.'
                );
            return fragmentDef;
          }
          function getMainDefinition(queryDoc) {
            checkDocument(queryDoc);
            var fragmentDefinition;
            for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
              var definition = _a[_i];
              if (definition.kind === 'OperationDefinition') {
                var operation = definition.operation;
                if (
                  operation === 'query' ||
                  operation === 'mutation' ||
                  operation === 'subscription'
                ) {
                  return definition;
                }
              }
              if (
                definition.kind === 'FragmentDefinition' &&
                !fragmentDefinition
              ) {
                fragmentDefinition = definition;
              }
            }
            if (fragmentDefinition) {
              return fragmentDefinition;
            }
            throw false
              ? undefined
              : new ts_invariant__WEBPACK_IMPORTED_MODULE_0__['InvariantError'](
                  'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.'
                );
          }
          function getDefaultValues(definition) {
            var defaultValues = Object.create(null);
            var defs = definition && definition.variableDefinitions;
            if (defs && defs.length) {
              defs.forEach(function (def) {
                if (def.defaultValue) {
                  Object(
                    _storeUtils_js__WEBPACK_IMPORTED_MODULE_1__[
                      'valueToObjectRepresentation'
                    ]
                  )(defaultValues, def.variable.name, def.defaultValue);
                }
              });
            }
            return defaultValues;
          }
          //# sourceMappingURL=getFromAST.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/graphql/storeUtils.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/storeUtils.js ***!
  \*********************************************************************/
        /*! exports provided: makeReference, isReference, valueToObjectRepresentation, storeKeyNameFromField, getStoreKeyName, argumentsObjectFromField, resultKeyNameFromField, getTypenameFromResult, isField, isInlineFragment */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'makeReference',
            function () {
              return makeReference;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isReference',
            function () {
              return isReference;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'valueToObjectRepresentation',
            function () {
              return valueToObjectRepresentation;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'storeKeyNameFromField',
            function () {
              return storeKeyNameFromField;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getStoreKeyName',
            function () {
              return getStoreKeyName;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'argumentsObjectFromField',
            function () {
              return argumentsObjectFromField;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resultKeyNameFromField',
            function () {
              return resultKeyNameFromField;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getTypenameFromResult',
            function () {
              return getTypenameFromResult;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isField',
            function () {
              return isField;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isInlineFragment',
            function () {
              return isInlineFragment;
            }
          );
          /* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! fast-json-stable-stringify */ './node_modules/fast-json-stable-stringify/index.js'
          );
          /* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./fragments.js */ './node_modules/@apollo/client/utilities/graphql/fragments.js'
          );

          function makeReference(id) {
            return { __ref: String(id) };
          }
          function isReference(obj) {
            return Boolean(
              obj && typeof obj === 'object' && typeof obj.__ref === 'string'
            );
          }
          function isStringValue(value) {
            return value.kind === 'StringValue';
          }
          function isBooleanValue(value) {
            return value.kind === 'BooleanValue';
          }
          function isIntValue(value) {
            return value.kind === 'IntValue';
          }
          function isFloatValue(value) {
            return value.kind === 'FloatValue';
          }
          function isVariable(value) {
            return value.kind === 'Variable';
          }
          function isObjectValue(value) {
            return value.kind === 'ObjectValue';
          }
          function isListValue(value) {
            return value.kind === 'ListValue';
          }
          function isEnumValue(value) {
            return value.kind === 'EnumValue';
          }
          function isNullValue(value) {
            return value.kind === 'NullValue';
          }
          function valueToObjectRepresentation(argObj, name, value, variables) {
            if (isIntValue(value) || isFloatValue(value)) {
              argObj[name.value] = Number(value.value);
            } else if (isBooleanValue(value) || isStringValue(value)) {
              argObj[name.value] = value.value;
            } else if (isObjectValue(value)) {
              var nestedArgObj_1 = {};
              value.fields.map(function (obj) {
                return valueToObjectRepresentation(
                  nestedArgObj_1,
                  obj.name,
                  obj.value,
                  variables
                );
              });
              argObj[name.value] = nestedArgObj_1;
            } else if (isVariable(value)) {
              var variableValue = (variables || {})[value.name.value];
              argObj[name.value] = variableValue;
            } else if (isListValue(value)) {
              argObj[name.value] = value.values.map(function (listValue) {
                var nestedArgArrayObj = {};
                valueToObjectRepresentation(
                  nestedArgArrayObj,
                  name,
                  listValue,
                  variables
                );
                return nestedArgArrayObj[name.value];
              });
            } else if (isEnumValue(value)) {
              argObj[name.value] = value.value;
            } else if (isNullValue(value)) {
              argObj[name.value] = null;
            } else {
              throw false
                ? undefined
                : new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[
                    'InvariantError'
                  ](
                    'The inline argument "' +
                      name.value +
                      '" of kind "' +
                      value.kind +
                      '"' +
                      'is not supported. Use variables instead of inline arguments to ' +
                      'overcome this limitation.'
                  );
            }
          }
          function storeKeyNameFromField(field, variables) {
            var directivesObj = null;
            if (field.directives) {
              directivesObj = {};
              field.directives.forEach(function (directive) {
                directivesObj[directive.name.value] = {};
                if (directive.arguments) {
                  directive.arguments.forEach(function (_a) {
                    var name = _a.name,
                      value = _a.value;
                    return valueToObjectRepresentation(
                      directivesObj[directive.name.value],
                      name,
                      value,
                      variables
                    );
                  });
                }
              });
            }
            var argObj = null;
            if (field.arguments && field.arguments.length) {
              argObj = {};
              field.arguments.forEach(function (_a) {
                var name = _a.name,
                  value = _a.value;
                return valueToObjectRepresentation(
                  argObj,
                  name,
                  value,
                  variables
                );
              });
            }
            return getStoreKeyName(field.name.value, argObj, directivesObj);
          }
          var KNOWN_DIRECTIVES = [
            'connection',
            'include',
            'skip',
            'client',
            'rest',
            'export',
          ];
          function getStoreKeyName(fieldName, args, directives) {
            if (
              args &&
              directives &&
              directives['connection'] &&
              directives['connection']['key']
            ) {
              if (
                directives['connection']['filter'] &&
                directives['connection']['filter'].length > 0
              ) {
                var filterKeys = directives['connection']['filter']
                  ? directives['connection']['filter']
                  : [];
                filterKeys.sort();
                var filteredArgs_1 = {};
                filterKeys.forEach(function (key) {
                  filteredArgs_1[key] = args[key];
                });
                return (
                  directives['connection']['key'] +
                  '(' +
                  JSON.stringify(filteredArgs_1) +
                  ')'
                );
              } else {
                return directives['connection']['key'];
              }
            }
            var completeFieldName = fieldName;
            if (args) {
              var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(
                args
              );
              completeFieldName += '(' + stringifiedArgs + ')';
            }
            if (directives) {
              Object.keys(directives).forEach(function (key) {
                if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;
                if (directives[key] && Object.keys(directives[key]).length) {
                  completeFieldName +=
                    '@' + key + '(' + JSON.stringify(directives[key]) + ')';
                } else {
                  completeFieldName += '@' + key;
                }
              });
            }
            return completeFieldName;
          }
          function argumentsObjectFromField(field, variables) {
            if (field.arguments && field.arguments.length) {
              var argObj_1 = {};
              field.arguments.forEach(function (_a) {
                var name = _a.name,
                  value = _a.value;
                return valueToObjectRepresentation(
                  argObj_1,
                  name,
                  value,
                  variables
                );
              });
              return argObj_1;
            }
            return null;
          }
          function resultKeyNameFromField(field) {
            return field.alias ? field.alias.value : field.name.value;
          }
          function getTypenameFromResult(result, selectionSet, fragmentMap) {
            if (typeof result.__typename === 'string') {
              return result.__typename;
            }
            for (
              var _i = 0, _a = selectionSet.selections;
              _i < _a.length;
              _i++
            ) {
              var selection = _a[_i];
              if (isField(selection)) {
                if (selection.name.value === '__typename') {
                  return result[resultKeyNameFromField(selection)];
                }
              } else {
                var typename = getTypenameFromResult(
                  result,
                  Object(
                    _fragments_js__WEBPACK_IMPORTED_MODULE_2__[
                      'getFragmentFromSelection'
                    ]
                  )(selection, fragmentMap).selectionSet,
                  fragmentMap
                );
                if (typeof typename === 'string') {
                  return typename;
                }
              }
            }
          }
          function isField(selection) {
            return selection.kind === 'Field';
          }
          function isInlineFragment(selection) {
            return selection.kind === 'InlineFragment';
          }
          //# sourceMappingURL=storeUtils.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/graphql/transform.js':
        /*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/transform.js ***!
  \********************************************************************/
        /*! exports provided: removeDirectivesFromDocument, addTypenameToDocument, removeConnectionDirectiveFromDocument, removeArgumentsFromDocument, removeFragmentSpreadFromDocument, buildQueryFromSelectionSet, removeClientSetsFromDocument */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'removeDirectivesFromDocument',
            function () {
              return removeDirectivesFromDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'addTypenameToDocument',
            function () {
              return addTypenameToDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'removeConnectionDirectiveFromDocument',
            function () {
              return removeConnectionDirectiveFromDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'removeArgumentsFromDocument',
            function () {
              return removeArgumentsFromDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'removeFragmentSpreadFromDocument',
            function () {
              return removeFragmentSpreadFromDocument;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'buildQueryFromSelectionSet',
            function () {
              return buildQueryFromSelectionSet;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'removeClientSetsFromDocument',
            function () {
              return removeClientSetsFromDocument;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! graphql/language/visitor */ './node_modules/graphql/language/visitor.js'
          );
          /* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
            graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__
          );
          /* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ts-invariant */ './node_modules/ts-invariant/lib/invariant.esm.js'
          );
          /* harmony import */ var _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./getFromAST.js */ './node_modules/@apollo/client/utilities/graphql/getFromAST.js'
          );
          /* harmony import */ var _common_filterInPlace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../common/filterInPlace.js */ './node_modules/@apollo/client/utilities/common/filterInPlace.js'
          );
          /* harmony import */ var _storeUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./storeUtils.js */ './node_modules/@apollo/client/utilities/graphql/storeUtils.js'
          );
          /* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./fragments.js */ './node_modules/@apollo/client/utilities/graphql/fragments.js'
          );

          var TYPENAME_FIELD = {
            kind: 'Field',
            name: {
              kind: 'Name',
              value: '__typename',
            },
          };
          function isEmpty(op, fragments) {
            return op.selectionSet.selections.every(function (selection) {
              return (
                selection.kind === 'FragmentSpread' &&
                isEmpty(fragments[selection.name.value], fragments)
              );
            });
          }
          function nullIfDocIsEmpty(doc) {
            return isEmpty(
              Object(
                _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__[
                  'getOperationDefinition'
                ]
              )(doc) ||
                Object(
                  _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__[
                    'getFragmentDefinition'
                  ]
                )(doc),
              Object(
                _fragments_js__WEBPACK_IMPORTED_MODULE_6__['createFragmentMap']
              )(
                Object(
                  _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__[
                    'getFragmentDefinitions'
                  ]
                )(doc)
              )
            )
              ? null
              : doc;
          }
          function getDirectiveMatcher(directives) {
            return function directiveMatcher(directive) {
              return directives.some(function (dir) {
                return (
                  (dir.name && dir.name === directive.name.value) ||
                  (dir.test && dir.test(directive))
                );
              });
            };
          }
          function removeDirectivesFromDocument(directives, doc) {
            var variablesInUse = Object.create(null);
            var variablesToRemove = [];
            var fragmentSpreadsInUse = Object.create(null);
            var fragmentSpreadsToRemove = [];
            var modifiedDoc = nullIfDocIsEmpty(
              Object(
                graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
              )(doc, {
                Variable: {
                  enter: function (node, _key, parent) {
                    if (parent.kind !== 'VariableDefinition') {
                      variablesInUse[node.name.value] = true;
                    }
                  },
                },
                Field: {
                  enter: function (node) {
                    if (directives && node.directives) {
                      var shouldRemoveField = directives.some(function (
                        directive
                      ) {
                        return directive.remove;
                      });
                      if (
                        shouldRemoveField &&
                        node.directives &&
                        node.directives.some(getDirectiveMatcher(directives))
                      ) {
                        if (node.arguments) {
                          node.arguments.forEach(function (arg) {
                            if (arg.value.kind === 'Variable') {
                              variablesToRemove.push({
                                name: arg.value.name.value,
                              });
                            }
                          });
                        }
                        if (node.selectionSet) {
                          getAllFragmentSpreadsFromSelectionSet(
                            node.selectionSet
                          ).forEach(function (frag) {
                            fragmentSpreadsToRemove.push({
                              name: frag.name.value,
                            });
                          });
                        }
                        return null;
                      }
                    }
                  },
                },
                FragmentSpread: {
                  enter: function (node) {
                    fragmentSpreadsInUse[node.name.value] = true;
                  },
                },
                Directive: {
                  enter: function (node) {
                    if (getDirectiveMatcher(directives)(node)) {
                      return null;
                    }
                  },
                },
              })
            );
            if (
              modifiedDoc &&
              Object(
                _common_filterInPlace_js__WEBPACK_IMPORTED_MODULE_4__[
                  'filterInPlace'
                ]
              )(variablesToRemove, function (v) {
                return !!v.name && !variablesInUse[v.name];
              }).length
            ) {
              modifiedDoc = removeArgumentsFromDocument(
                variablesToRemove,
                modifiedDoc
              );
            }
            if (
              modifiedDoc &&
              Object(
                _common_filterInPlace_js__WEBPACK_IMPORTED_MODULE_4__[
                  'filterInPlace'
                ]
              )(fragmentSpreadsToRemove, function (fs) {
                return !!fs.name && !fragmentSpreadsInUse[fs.name];
              }).length
            ) {
              modifiedDoc = removeFragmentSpreadFromDocument(
                fragmentSpreadsToRemove,
                modifiedDoc
              );
            }
            return modifiedDoc;
          }
          function addTypenameToDocument(doc) {
            return Object(
              graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
            )(
              Object(
                _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__['checkDocument']
              )(doc),
              {
                SelectionSet: {
                  enter: function (node, _key, parent) {
                    if (parent && parent.kind === 'OperationDefinition') {
                      return;
                    }
                    var selections = node.selections;
                    if (!selections) {
                      return;
                    }
                    var skip = selections.some(function (selection) {
                      return (
                        Object(
                          _storeUtils_js__WEBPACK_IMPORTED_MODULE_5__['isField']
                        )(selection) &&
                        (selection.name.value === '__typename' ||
                          selection.name.value.lastIndexOf('__', 0) === 0)
                      );
                    });
                    if (skip) {
                      return;
                    }
                    var field = parent;
                    if (
                      Object(
                        _storeUtils_js__WEBPACK_IMPORTED_MODULE_5__['isField']
                      )(field) &&
                      field.directives &&
                      field.directives.some(function (d) {
                        return d.name.value === 'export';
                      })
                    ) {
                      return;
                    }
                    return Object(
                      tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                    )(
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        node
                      ),
                      {
                        selections: Object(
                          tslib__WEBPACK_IMPORTED_MODULE_0__['__spreadArrays']
                        )(selections, [TYPENAME_FIELD]),
                      }
                    );
                  },
                },
              }
            );
          }
          addTypenameToDocument.added = function (field) {
            return field === TYPENAME_FIELD;
          };
          var connectionRemoveConfig = {
            test: function (directive) {
              var willRemove = directive.name.value === 'connection';
              if (willRemove) {
                if (
                  !directive.arguments ||
                  !directive.arguments.some(function (arg) {
                    return arg.name.value === 'key';
                  })
                ) {
                  false ||
                    ts_invariant__WEBPACK_IMPORTED_MODULE_2__['invariant'].warn(
                      'Removing an @connection directive even though it does not have a key. ' +
                        'You may want to use the key parameter to specify a store key.'
                    );
                }
              }
              return willRemove;
            },
          };
          function removeConnectionDirectiveFromDocument(doc) {
            return removeDirectivesFromDocument(
              [connectionRemoveConfig],
              Object(
                _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__['checkDocument']
              )(doc)
            );
          }
          function hasDirectivesInSelectionSet(
            directives,
            selectionSet,
            nestedCheck
          ) {
            if (nestedCheck === void 0) {
              nestedCheck = true;
            }
            return (
              !!selectionSet &&
              selectionSet.selections &&
              selectionSet.selections.some(function (selection) {
                return hasDirectivesInSelection(
                  directives,
                  selection,
                  nestedCheck
                );
              })
            );
          }
          function hasDirectivesInSelection(
            directives,
            selection,
            nestedCheck
          ) {
            if (nestedCheck === void 0) {
              nestedCheck = true;
            }
            if (
              !Object(_storeUtils_js__WEBPACK_IMPORTED_MODULE_5__['isField'])(
                selection
              )
            ) {
              return true;
            }
            if (!selection.directives) {
              return false;
            }
            return (
              selection.directives.some(getDirectiveMatcher(directives)) ||
              (nestedCheck &&
                hasDirectivesInSelectionSet(
                  directives,
                  selection.selectionSet,
                  nestedCheck
                ))
            );
          }
          function getArgumentMatcher(config) {
            return function argumentMatcher(argument) {
              return config.some(function (aConfig) {
                return (
                  argument.value &&
                  argument.value.kind === 'Variable' &&
                  argument.value.name &&
                  (aConfig.name === argument.value.name.value ||
                    (aConfig.test && aConfig.test(argument)))
                );
              });
            };
          }
          function removeArgumentsFromDocument(config, doc) {
            var argMatcher = getArgumentMatcher(config);
            return nullIfDocIsEmpty(
              Object(
                graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
              )(doc, {
                OperationDefinition: {
                  enter: function (node) {
                    return Object(
                      tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                    )(
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        node
                      ),
                      {
                        variableDefinitions: node.variableDefinitions
                          ? node.variableDefinitions.filter(function (varDef) {
                              return !config.some(function (arg) {
                                return arg.name === varDef.variable.name.value;
                              });
                            })
                          : [],
                      }
                    );
                  },
                },
                Field: {
                  enter: function (node) {
                    var shouldRemoveField = config.some(function (argConfig) {
                      return argConfig.remove;
                    });
                    if (shouldRemoveField) {
                      var argMatchCount_1 = 0;
                      if (node.arguments) {
                        node.arguments.forEach(function (arg) {
                          if (argMatcher(arg)) {
                            argMatchCount_1 += 1;
                          }
                        });
                      }
                      if (argMatchCount_1 === 1) {
                        return null;
                      }
                    }
                  },
                },
                Argument: {
                  enter: function (node) {
                    if (argMatcher(node)) {
                      return null;
                    }
                  },
                },
              })
            );
          }
          function removeFragmentSpreadFromDocument(config, doc) {
            function enter(node) {
              if (
                config.some(function (def) {
                  return def.name === node.name.value;
                })
              ) {
                return null;
              }
            }
            return nullIfDocIsEmpty(
              Object(
                graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
              )(doc, {
                FragmentSpread: { enter: enter },
                FragmentDefinition: { enter: enter },
              })
            );
          }
          function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
            var allFragments = [];
            selectionSet.selections.forEach(function (selection) {
              if (
                (Object(_storeUtils_js__WEBPACK_IMPORTED_MODULE_5__['isField'])(
                  selection
                ) ||
                  Object(
                    _storeUtils_js__WEBPACK_IMPORTED_MODULE_5__[
                      'isInlineFragment'
                    ]
                  )(selection)) &&
                selection.selectionSet
              ) {
                getAllFragmentSpreadsFromSelectionSet(
                  selection.selectionSet
                ).forEach(function (frag) {
                  return allFragments.push(frag);
                });
              } else if (selection.kind === 'FragmentSpread') {
                allFragments.push(selection);
              }
            });
            return allFragments;
          }
          function buildQueryFromSelectionSet(document) {
            var definition = Object(
              _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__['getMainDefinition']
            )(document);
            var definitionOperation = definition.operation;
            if (definitionOperation === 'query') {
              return document;
            }
            var modifiedDoc = Object(
              graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
            )(document, {
              OperationDefinition: {
                enter: function (node) {
                  return Object(
                    tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                  )(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      node
                    ),
                    { operation: 'query' }
                  );
                },
              },
            });
            return modifiedDoc;
          }
          function removeClientSetsFromDocument(document) {
            Object(
              _getFromAST_js__WEBPACK_IMPORTED_MODULE_3__['checkDocument']
            )(document);
            var modifiedDoc = removeDirectivesFromDocument(
              [
                {
                  test: function (directive) {
                    return directive.name.value === 'client';
                  },
                  remove: true,
                },
              ],
              document
            );
            if (modifiedDoc) {
              modifiedDoc = Object(
                graphql_language_visitor__WEBPACK_IMPORTED_MODULE_1__['visit']
              )(modifiedDoc, {
                FragmentDefinition: {
                  enter: function (node) {
                    if (node.selectionSet) {
                      var isTypenameOnly = node.selectionSet.selections.every(
                        function (selection) {
                          return (
                            Object(
                              _storeUtils_js__WEBPACK_IMPORTED_MODULE_5__[
                                'isField'
                              ]
                            )(selection) &&
                            selection.name.value === '__typename'
                          );
                        }
                      );
                      if (isTypenameOnly) {
                        return null;
                      }
                    }
                  },
                },
              });
            }
            return modifiedDoc;
          }
          //# sourceMappingURL=transform.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/index.js':
        /*!********************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/index.js ***!
  \********************************************************/
        /*! exports provided: shouldInclude, hasDirectives, hasClientExports, getDirectiveNames, getInclusionDirectives, createFragmentMap, getFragmentQueryDocument, getFragmentFromSelection, checkDocument, getOperationDefinition, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, getDefaultValues, makeReference, isReference, isField, isInlineFragment, valueToObjectRepresentation, storeKeyNameFromField, argumentsObjectFromField, resultKeyNameFromField, getStoreKeyName, getTypenameFromResult, addTypenameToDocument, buildQueryFromSelectionSet, removeDirectivesFromDocument, removeConnectionDirectiveFromDocument, removeArgumentsFromDocument, removeFragmentSpreadFromDocument, removeClientSetsFromDocument, concatPagination, offsetLimitPagination, relayStylePagination, Observable, mergeDeep, mergeDeepArray, DeepMerger, cloneDeep, maybeDeepFreeze, iterateObserversSafely, asyncMap, Concast, isNonEmptyArray, graphQLResultHasError, canUseWeakMap, compact */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./graphql/directives.js */ './node_modules/@apollo/client/utilities/graphql/directives.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'shouldInclude',
            function () {
              return _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__[
                'shouldInclude'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'hasDirectives',
            function () {
              return _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__[
                'hasDirectives'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'hasClientExports',
            function () {
              return _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__[
                'hasClientExports'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getDirectiveNames',
            function () {
              return _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__[
                'getDirectiveNames'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getInclusionDirectives',
            function () {
              return _graphql_directives_js__WEBPACK_IMPORTED_MODULE_0__[
                'getInclusionDirectives'
              ];
            }
          );

          /* harmony import */ var _graphql_fragments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./graphql/fragments.js */ './node_modules/@apollo/client/utilities/graphql/fragments.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'createFragmentMap',
            function () {
              return _graphql_fragments_js__WEBPACK_IMPORTED_MODULE_1__[
                'createFragmentMap'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentQueryDocument',
            function () {
              return _graphql_fragments_js__WEBPACK_IMPORTED_MODULE_1__[
                'getFragmentQueryDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentFromSelection',
            function () {
              return _graphql_fragments_js__WEBPACK_IMPORTED_MODULE_1__[
                'getFragmentFromSelection'
              ];
            }
          );

          /* harmony import */ var _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./graphql/getFromAST.js */ './node_modules/@apollo/client/utilities/graphql/getFromAST.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'checkDocument',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'checkDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getOperationDefinition',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getOperationDefinition'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getOperationName',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getOperationName'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentDefinitions',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getFragmentDefinitions'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getQueryDefinition',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getQueryDefinition'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getFragmentDefinition',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getFragmentDefinition'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getMainDefinition',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getMainDefinition'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getDefaultValues',
            function () {
              return _graphql_getFromAST_js__WEBPACK_IMPORTED_MODULE_2__[
                'getDefaultValues'
              ];
            }
          );

          /* harmony import */ var _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./graphql/storeUtils.js */ './node_modules/@apollo/client/utilities/graphql/storeUtils.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'makeReference',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'makeReference'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isReference',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'isReference'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isField',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'isField'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isInlineFragment',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'isInlineFragment'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'valueToObjectRepresentation',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'valueToObjectRepresentation'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'storeKeyNameFromField',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'storeKeyNameFromField'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'argumentsObjectFromField',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'argumentsObjectFromField'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'resultKeyNameFromField',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'resultKeyNameFromField'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getStoreKeyName',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'getStoreKeyName'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'getTypenameFromResult',
            function () {
              return _graphql_storeUtils_js__WEBPACK_IMPORTED_MODULE_3__[
                'getTypenameFromResult'
              ];
            }
          );

          /* harmony import */ var _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./graphql/transform.js */ './node_modules/@apollo/client/utilities/graphql/transform.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'addTypenameToDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'addTypenameToDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'buildQueryFromSelectionSet',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'buildQueryFromSelectionSet'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'removeDirectivesFromDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'removeDirectivesFromDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'removeConnectionDirectiveFromDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'removeConnectionDirectiveFromDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'removeArgumentsFromDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'removeArgumentsFromDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'removeFragmentSpreadFromDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'removeFragmentSpreadFromDocument'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'removeClientSetsFromDocument',
            function () {
              return _graphql_transform_js__WEBPACK_IMPORTED_MODULE_4__[
                'removeClientSetsFromDocument'
              ];
            }
          );

          /* harmony import */ var _policies_pagination_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ./policies/pagination.js */ './node_modules/@apollo/client/utilities/policies/pagination.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'concatPagination',
            function () {
              return _policies_pagination_js__WEBPACK_IMPORTED_MODULE_5__[
                'concatPagination'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'offsetLimitPagination',
            function () {
              return _policies_pagination_js__WEBPACK_IMPORTED_MODULE_5__[
                'offsetLimitPagination'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'relayStylePagination',
            function () {
              return _policies_pagination_js__WEBPACK_IMPORTED_MODULE_5__[
                'relayStylePagination'
              ];
            }
          );

          /* harmony import */ var _observables_Observable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./observables/Observable.js */ './node_modules/@apollo/client/utilities/observables/Observable.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Observable',
            function () {
              return _observables_Observable_js__WEBPACK_IMPORTED_MODULE_6__[
                'Observable'
              ];
            }
          );

          /* harmony import */ var _common_mergeDeep_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./common/mergeDeep.js */ './node_modules/@apollo/client/utilities/common/mergeDeep.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeDeep',
            function () {
              return _common_mergeDeep_js__WEBPACK_IMPORTED_MODULE_7__[
                'mergeDeep'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeDeepArray',
            function () {
              return _common_mergeDeep_js__WEBPACK_IMPORTED_MODULE_7__[
                'mergeDeepArray'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'DeepMerger',
            function () {
              return _common_mergeDeep_js__WEBPACK_IMPORTED_MODULE_7__[
                'DeepMerger'
              ];
            }
          );

          /* harmony import */ var _common_cloneDeep_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./common/cloneDeep.js */ './node_modules/@apollo/client/utilities/common/cloneDeep.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'cloneDeep',
            function () {
              return _common_cloneDeep_js__WEBPACK_IMPORTED_MODULE_8__[
                'cloneDeep'
              ];
            }
          );

          /* harmony import */ var _common_maybeDeepFreeze_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
            /*! ./common/maybeDeepFreeze.js */ './node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'maybeDeepFreeze',
            function () {
              return _common_maybeDeepFreeze_js__WEBPACK_IMPORTED_MODULE_9__[
                'maybeDeepFreeze'
              ];
            }
          );

          /* harmony import */ var _observables_iteration_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
            /*! ./observables/iteration.js */ './node_modules/@apollo/client/utilities/observables/iteration.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'iterateObserversSafely',
            function () {
              return _observables_iteration_js__WEBPACK_IMPORTED_MODULE_10__[
                'iterateObserversSafely'
              ];
            }
          );

          /* harmony import */ var _observables_asyncMap_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
            /*! ./observables/asyncMap.js */ './node_modules/@apollo/client/utilities/observables/asyncMap.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'asyncMap',
            function () {
              return _observables_asyncMap_js__WEBPACK_IMPORTED_MODULE_11__[
                'asyncMap'
              ];
            }
          );

          /* harmony import */ var _observables_Concast_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
            /*! ./observables/Concast.js */ './node_modules/@apollo/client/utilities/observables/Concast.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Concast',
            function () {
              return _observables_Concast_js__WEBPACK_IMPORTED_MODULE_12__[
                'Concast'
              ];
            }
          );

          /* harmony import */ var _common_arrays_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
            /*! ./common/arrays.js */ './node_modules/@apollo/client/utilities/common/arrays.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isNonEmptyArray',
            function () {
              return _common_arrays_js__WEBPACK_IMPORTED_MODULE_13__[
                'isNonEmptyArray'
              ];
            }
          );

          /* harmony import */ var _common_errorHandling_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
            /*! ./common/errorHandling.js */ './node_modules/@apollo/client/utilities/common/errorHandling.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'graphQLResultHasError',
            function () {
              return _common_errorHandling_js__WEBPACK_IMPORTED_MODULE_14__[
                'graphQLResultHasError'
              ];
            }
          );

          /* harmony import */ var _common_canUse_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
            /*! ./common/canUse.js */ './node_modules/@apollo/client/utilities/common/canUse.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'canUseWeakMap',
            function () {
              return _common_canUse_js__WEBPACK_IMPORTED_MODULE_15__[
                'canUseWeakMap'
              ];
            }
          );

          /* harmony import */ var _common_compact_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
            /*! ./common/compact.js */ './node_modules/@apollo/client/utilities/common/compact.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'compact',
            function () {
              return _common_compact_js__WEBPACK_IMPORTED_MODULE_16__[
                'compact'
              ];
            }
          );

          //# sourceMappingURL=index.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/observables/Concast.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/Concast.js ***!
  \**********************************************************************/
        /*! exports provided: Concast */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Concast',
            function () {
              return Concast;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./Observable.js */ './node_modules/@apollo/client/utilities/observables/Observable.js'
          );
          /* harmony import */ var _iteration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./iteration.js */ './node_modules/@apollo/client/utilities/observables/iteration.js'
          );

          function isPromiseLike(value) {
            return value && typeof value.then === 'function';
          }
          var Concast = (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
              Concast,
              _super
            );
            function Concast(sources) {
              var _this =
                _super.call(this, function (observer) {
                  _this.addObserver(observer);
                  return function () {
                    return _this.removeObserver(observer);
                  };
                }) || this;
              _this.observers = new Set();
              _this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
              });
              _this.handlers = {
                next: function (result) {
                  if (_this.sub !== null) {
                    _this.latest = ['next', result];
                    Object(
                      _iteration_js__WEBPACK_IMPORTED_MODULE_2__[
                        'iterateObserversSafely'
                      ]
                    )(_this.observers, 'next', result);
                  }
                },
                error: function (error) {
                  if (_this.sub !== null) {
                    if (_this.sub) _this.sub.unsubscribe();
                    _this.sub = null;
                    _this.latest = ['error', error];
                    _this.reject(error);
                    Object(
                      _iteration_js__WEBPACK_IMPORTED_MODULE_2__[
                        'iterateObserversSafely'
                      ]
                    )(_this.observers, 'error', error);
                  }
                },
                complete: function () {
                  if (_this.sub !== null) {
                    var value = _this.sources.shift();
                    if (!value) {
                      _this.sub = null;
                      if (_this.latest && _this.latest[0] === 'next') {
                        _this.resolve(_this.latest[1]);
                      } else {
                        _this.resolve();
                      }
                      Object(
                        _iteration_js__WEBPACK_IMPORTED_MODULE_2__[
                          'iterateObserversSafely'
                        ]
                      )(_this.observers, 'complete');
                    } else if (isPromiseLike(value)) {
                      value.then(function (obs) {
                        return (_this.sub = obs.subscribe(_this.handlers));
                      });
                    } else {
                      _this.sub = value.subscribe(_this.handlers);
                    }
                  }
                },
              };
              _this.cancel = function (reason) {
                _this.reject(reason);
                _this.sources = [];
                _this.handlers.complete();
              };
              _this.promise.catch(function (_) {});
              if (isPromiseLike(sources)) {
                sources.then(function (iterable) {
                  return _this.start(iterable);
                }, _this.handlers.error);
              } else {
                _this.start(sources);
              }
              return _this;
            }
            Concast.prototype.start = function (sources) {
              if (this.sub !== void 0) return;
              this.sources = Array.from(sources);
              this.handlers.complete();
            };
            Concast.prototype.addObserver = function (observer) {
              if (!this.observers.has(observer)) {
                if (this.latest) {
                  var nextOrError = this.latest[0];
                  var method = observer[nextOrError];
                  if (method) {
                    method.call(observer, this.latest[1]);
                  }
                  if (
                    this.sub === null &&
                    nextOrError === 'next' &&
                    observer.complete
                  ) {
                    observer.complete();
                  }
                }
                this.observers.add(observer);
              }
            };
            Concast.prototype.removeObserver = function (observer, quietly) {
              if (this.observers.delete(observer) && this.observers.size < 1) {
                if (quietly) return;
                if (this.sub) {
                  this.sub.unsubscribe();
                  this.reject(new Error('Observable cancelled prematurely'));
                }
                this.sub = null;
              }
            };
            Concast.prototype.cleanup = function (callback) {
              var _this = this;
              var called = false;
              var once = function () {
                if (!called) {
                  called = true;
                  _this.observers.delete(observer);
                  callback();
                }
              };
              var observer = {
                next: once,
                error: once,
                complete: once,
              };
              this.addObserver(observer);
            };
            return Concast;
          })(_Observable_js__WEBPACK_IMPORTED_MODULE_1__['Observable']);

          if (typeof Symbol === 'function' && Symbol.species) {
            Object.defineProperty(Concast, Symbol.species, {
              value: _Observable_js__WEBPACK_IMPORTED_MODULE_1__['Observable'],
            });
          }
          //# sourceMappingURL=Concast.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/observables/Observable.js':
        /*!*************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/Observable.js ***!
  \*************************************************************************/
        /*! exports provided: Observable */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! zen-observable */ './node_modules/zen-observable/index.js'
          );
          /* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            zen_observable__WEBPACK_IMPORTED_MODULE_0__
          );
          /* harmony reexport (default from non-harmony) */ __webpack_require__.d(
            __webpack_exports__,
            'Observable',
            function () {
              return zen_observable__WEBPACK_IMPORTED_MODULE_0___default.a;
            }
          );
          /* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! symbol-observable */ './node_modules/symbol-observable/es/index.js'
          );

          zen_observable__WEBPACK_IMPORTED_MODULE_0___default.a.prototype[
            '@@observable'
          ] = function () {
            return this;
          };

          //# sourceMappingURL=Observable.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/observables/asyncMap.js':
        /*!***********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/asyncMap.js ***!
  \***********************************************************************/
        /*! exports provided: asyncMap */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'asyncMap',
            function () {
              return asyncMap;
            }
          );
          /* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./Observable.js */ './node_modules/@apollo/client/utilities/observables/Observable.js'
          );

          function asyncMap(observable, mapFn, catchFn) {
            return new _Observable_js__WEBPACK_IMPORTED_MODULE_0__[
              'Observable'
            ](function (observer) {
              var next = observer.next,
                error = observer.error,
                complete = observer.complete;
              var activeCallbackCount = 0;
              var completed = false;
              function makeCallback(examiner, delegate) {
                if (examiner) {
                  return function (arg) {
                    ++activeCallbackCount;
                    new Promise(function (resolve) {
                      return resolve(examiner(arg));
                    }).then(
                      function (result) {
                        --activeCallbackCount;
                        next && next.call(observer, result);
                        if (completed) {
                          handler.complete();
                        }
                      },
                      function (e) {
                        --activeCallbackCount;
                        error && error.call(observer, e);
                      }
                    );
                  };
                } else {
                  return function (arg) {
                    return delegate && delegate.call(observer, arg);
                  };
                }
              }
              var handler = {
                next: makeCallback(mapFn, next),
                error: makeCallback(catchFn, error),
                complete: function () {
                  completed = true;
                  if (!activeCallbackCount) {
                    complete && complete.call(observer);
                  }
                },
              };
              var sub = observable.subscribe(handler);
              return function () {
                return sub.unsubscribe();
              };
            });
          }
          //# sourceMappingURL=asyncMap.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/observables/iteration.js':
        /*!************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/iteration.js ***!
  \************************************************************************/
        /*! exports provided: iterateObserversSafely */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'iterateObserversSafely',
            function () {
              return iterateObserversSafely;
            }
          );
          function iterateObserversSafely(observers, method, argument) {
            var observersWithMethod = [];
            observers.forEach(function (obs) {
              return obs[method] && observersWithMethod.push(obs);
            });
            observersWithMethod.forEach(function (obs) {
              return obs[method](argument);
            });
          }
          //# sourceMappingURL=iteration.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/utilities/policies/pagination.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/policies/pagination.js ***!
  \**********************************************************************/
        /*! exports provided: concatPagination, offsetLimitPagination, relayStylePagination */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'concatPagination',
            function () {
              return concatPagination;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'offsetLimitPagination',
            function () {
              return offsetLimitPagination;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'relayStylePagination',
            function () {
              return relayStylePagination;
            }
          );
          /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          );

          function concatPagination(keyArgs) {
            if (keyArgs === void 0) {
              keyArgs = false;
            }
            return {
              keyArgs: keyArgs,
              merge: function (existing, incoming) {
                return existing
                  ? Object(
                      tslib__WEBPACK_IMPORTED_MODULE_0__['__spreadArrays']
                    )(existing, incoming)
                  : incoming;
              },
            };
          }
          function offsetLimitPagination(keyArgs) {
            if (keyArgs === void 0) {
              keyArgs = false;
            }
            return {
              keyArgs: keyArgs,
              merge: function (existing, incoming, _a) {
                var args = _a.args;
                var merged = existing ? existing.slice(0) : [];
                var start = args ? args.offset : merged.length;
                var end = start + incoming.length;
                for (var i = start; i < end; ++i) {
                  merged[i] = incoming[i - start];
                }
                return merged;
              },
            };
          }
          function relayStylePagination(keyArgs) {
            if (keyArgs === void 0) {
              keyArgs = false;
            }
            return {
              keyArgs: keyArgs,
              read: function (existing, _a) {
                var canRead = _a.canRead;
                if (!existing) return;
                var edges = existing.edges.filter(function (edge) {
                  return canRead(edge.node);
                });
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    {},
                    existing
                  ),
                  {
                    edges: edges,
                    pageInfo: Object(
                      tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                    )(
                      Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                        {},
                        existing.pageInfo
                      ),
                      {
                        startCursor: cursorFromEdge(edges, 0),
                        endCursor: cursorFromEdge(edges, -1),
                      }
                    ),
                  }
                );
              },
              merge: function (existing, incoming, _a) {
                if (existing === void 0) {
                  existing = makeEmptyData();
                }
                var args = _a.args;
                if (!args) return existing;
                var incomingEdges = incoming.edges.slice(0);
                if (incoming.pageInfo) {
                  updateCursor(incomingEdges, 0, incoming.pageInfo.startCursor);
                  updateCursor(incomingEdges, -1, incoming.pageInfo.endCursor);
                }
                var prefix = existing.edges;
                var suffix = [];
                if (args.after) {
                  var index = prefix.findIndex(function (edge) {
                    return edge.cursor === args.after;
                  });
                  if (index >= 0) {
                    prefix = prefix.slice(0, index + 1);
                  }
                } else if (args.before) {
                  var index = prefix.findIndex(function (edge) {
                    return edge.cursor === args.before;
                  });
                  suffix = index < 0 ? prefix : prefix.slice(index);
                  prefix = [];
                } else {
                  prefix = [];
                }
                var edges = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__spreadArrays']
                )(prefix, incomingEdges, suffix);
                var pageInfo = Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      incoming.pageInfo
                    ),
                    existing.pageInfo
                  ),
                  {
                    startCursor: cursorFromEdge(edges, 0),
                    endCursor: cursorFromEdge(edges, -1),
                  }
                );
                var updatePageInfo = function (name) {
                  var value = incoming.pageInfo[name];
                  if (value !== void 0) {
                    pageInfo[name] = value;
                  }
                };
                if (!prefix.length) updatePageInfo('hasPreviousPage');
                if (!suffix.length) updatePageInfo('hasNextPage');
                return Object(
                  tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
                )(
                  Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                    Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                      {},
                      existing
                    ),
                    incoming
                  ),
                  { edges: edges, pageInfo: pageInfo }
                );
              },
            };
          }
          function makeEmptyData() {
            return {
              edges: [],
              pageInfo: {
                hasPreviousPage: false,
                hasNextPage: true,
                startCursor: '',
                endCursor: '',
              },
            };
          }
          function cursorFromEdge(edges, index) {
            if (index < 0) index += edges.length;
            var edge = edges[index];
            return (edge && edge.cursor) || '';
          }
          function updateCursor(edges, index, cursor) {
            if (index < 0) index += edges.length;
            var edge = edges[index];
            if (cursor && cursor !== edge.cursor) {
              edges[index] = Object(
                tslib__WEBPACK_IMPORTED_MODULE_0__['__assign']
              )(
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__assign'])(
                  {},
                  edge
                ),
                { cursor: cursor }
              );
            }
          }
          //# sourceMappingURL=pagination.js.map

          /***/
        },

      /***/ './node_modules/@apollo/client/version.js':
        /*!************************************************!*\
  !*** ./node_modules/@apollo/client/version.js ***!
  \************************************************/
        /*! exports provided: version */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'version',
            function () {
              return version;
            }
          );
          var version = 'local';
          //# sourceMappingURL=version.js.map

          /***/
        },

      /***/ './node_modules/@wry/context/lib/context.esm.js':
        /*!******************************************************!*\
  !*** ./node_modules/@wry/context/lib/context.esm.js ***!
  \******************************************************/
        /*! exports provided: Slot, asyncFromGen, bind, noContext, setTimeout, wrapYieldingFiberMethods */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Slot',
            function () {
              return Slot;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'asyncFromGen',
            function () {
              return asyncFromGen;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'bind',
            function () {
              return bind;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'noContext',
            function () {
              return noContext;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setTimeout',
            function () {
              return setTimeoutWithContext;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'wrapYieldingFiberMethods',
            function () {
              return wrapYieldingFiberMethods;
            }
          );
          // This currentContext variable will only be used if the makeSlotClass
          // function is called, which happens only if this is the first copy of the
          // @wry/context package to be imported.
          var currentContext = null;
          // This unique internal object is used to denote the absence of a value
          // for a given Slot, and is never exposed to outside code.
          var MISSING_VALUE = {};
          var idCounter = 1;
          // Although we can't do anything about the cost of duplicated code from
          // accidentally bundling multiple copies of the @wry/context package, we can
          // avoid creating the Slot class more than once using makeSlotClass.
          var makeSlotClass = function () {
            return /** @class */ (function () {
              function Slot() {
                // If you have a Slot object, you can find out its slot.id, but you cannot
                // guess the slot.id of a Slot you don't have access to, thanks to the
                // randomized suffix.
                this.id = [
                  'slot',
                  idCounter++,
                  Date.now(),
                  Math.random().toString(36).slice(2),
                ].join(':');
              }
              Slot.prototype.hasValue = function () {
                for (
                  var context_1 = currentContext;
                  context_1;
                  context_1 = context_1.parent
                ) {
                  // We use the Slot object iself as a key to its value, which means the
                  // value cannot be obtained without a reference to the Slot object.
                  if (this.id in context_1.slots) {
                    var value = context_1.slots[this.id];
                    if (value === MISSING_VALUE) break;
                    if (context_1 !== currentContext) {
                      // Cache the value in currentContext.slots so the next lookup will
                      // be faster. This caching is safe because the tree of contexts and
                      // the values of the slots are logically immutable.
                      currentContext.slots[this.id] = value;
                    }
                    return true;
                  }
                }
                if (currentContext) {
                  // If a value was not found for this Slot, it's never going to be found
                  // no matter how many times we look it up, so we might as well cache
                  // the absence of the value, too.
                  currentContext.slots[this.id] = MISSING_VALUE;
                }
                return false;
              };
              Slot.prototype.getValue = function () {
                if (this.hasValue()) {
                  return currentContext.slots[this.id];
                }
              };
              Slot.prototype.withValue = function (
                value,
                callback,
                // Given the prevalence of arrow functions, specifying arguments is likely
                // to be much more common than specifying `this`, hence this ordering:
                args,
                thisArg
              ) {
                var _a;
                var slots =
                  ((_a = {
                    __proto__: null,
                  }),
                  (_a[this.id] = value),
                  _a);
                var parent = currentContext;
                currentContext = { parent: parent, slots: slots };
                try {
                  // Function.prototype.apply allows the arguments array argument to be
                  // omitted or undefined, so args! is fine here.
                  return callback.apply(thisArg, args);
                } finally {
                  currentContext = parent;
                }
              };
              // Capture the current context and wrap a callback function so that it
              // reestablishes the captured context when called.
              Slot.bind = function (callback) {
                var context = currentContext;
                return function () {
                  var saved = currentContext;
                  try {
                    currentContext = context;
                    return callback.apply(this, arguments);
                  } finally {
                    currentContext = saved;
                  }
                };
              };
              // Immediately run a callback function without any captured context.
              Slot.noContext = function (
                callback,
                // Given the prevalence of arrow functions, specifying arguments is likely
                // to be much more common than specifying `this`, hence this ordering:
                args,
                thisArg
              ) {
                if (currentContext) {
                  var saved = currentContext;
                  try {
                    currentContext = null;
                    // Function.prototype.apply allows the arguments array argument to be
                    // omitted or undefined, so args! is fine here.
                    return callback.apply(thisArg, args);
                  } finally {
                    currentContext = saved;
                  }
                } else {
                  return callback.apply(thisArg, args);
                }
              };
              return Slot;
            })();
          };
          // We store a single global implementation of the Slot class as a permanent
          // non-enumerable symbol property of the Array constructor. This obfuscation
          // does nothing to prevent access to the Slot class, but at least it ensures
          // the implementation (i.e. currentContext) cannot be tampered with, and all
          // copies of the @wry/context package (hopefully just one) will share the
          // same Slot implementation. Since the first copy of the @wry/context package
          // to be imported wins, this technique imposes a very high cost for any
          // future breaking changes to the Slot class.
          var globalKey = '@wry/context:Slot';
          var host = Array;
          var Slot =
            host[globalKey] ||
            (function () {
              var Slot = makeSlotClass();
              try {
                Object.defineProperty(host, globalKey, {
                  value: (host[globalKey] = Slot),
                  enumerable: false,
                  writable: false,
                  configurable: false,
                });
              } finally {
                return Slot;
              }
            })();

          var bind = Slot.bind,
            noContext = Slot.noContext;
          function setTimeoutWithContext(callback, delay) {
            return setTimeout(bind(callback), delay);
          }
          // Turn any generator function into an async function (using yield instead
          // of await), with context automatically preserved across yields.
          function asyncFromGen(genFn) {
            return function () {
              var gen = genFn.apply(this, arguments);
              var boundNext = bind(gen.next);
              var boundThrow = bind(gen.throw);
              return new Promise(function (resolve, reject) {
                function invoke(method, argument) {
                  try {
                    var result = method.call(gen, argument);
                  } catch (error) {
                    return reject(error);
                  }
                  var next = result.done ? resolve : invokeNext;
                  if (isPromiseLike(result.value)) {
                    result.value.then(next, result.done ? reject : invokeThrow);
                  } else {
                    next(result.value);
                  }
                }
                var invokeNext = function (value) {
                  return invoke(boundNext, value);
                };
                var invokeThrow = function (error) {
                  return invoke(boundThrow, error);
                };
                invokeNext();
              });
            };
          }
          function isPromiseLike(value) {
            return value && typeof value.then === 'function';
          }
          // If you use the fibers npm package to implement coroutines in Node.js,
          // you should call this function at least once to ensure context management
          // remains coherent across any yields.
          var wrappedFibers = [];
          function wrapYieldingFiberMethods(Fiber) {
            // There can be only one implementation of Fiber per process, so this array
            // should never grow longer than one element.
            if (wrappedFibers.indexOf(Fiber) < 0) {
              var wrap = function (obj, method) {
                var fn = obj[method];
                obj[method] = function () {
                  return noContext(fn, arguments, this);
                };
              };
              // These methods can yield, according to
              // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100
              wrap(Fiber, 'yield');
              wrap(Fiber.prototype, 'run');
              wrap(Fiber.prototype, 'throwInto');
              wrappedFibers.push(Fiber);
            }
            return Fiber;
          }

          //# sourceMappingURL=context.esm.js.map

          /***/
        },

      /***/ './node_modules/@wry/equality/lib/equality.esm.js':
        /*!********************************************************!*\
  !*** ./node_modules/@wry/equality/lib/equality.esm.js ***!
  \********************************************************/
        /*! exports provided: default, equal */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'equal',
            function () {
              return equal;
            }
          );
          var _a = Object.prototype,
            toString = _a.toString,
            hasOwnProperty = _a.hasOwnProperty;
          var fnToStr = Function.prototype.toString;
          var previousComparisons = new Map();
          /**
           * Performs a deep equality check on two JavaScript values, tolerating cycles.
           */
          function equal(a, b) {
            try {
              return check(a, b);
            } finally {
              previousComparisons.clear();
            }
          }
          function check(a, b) {
            // If the two values are strictly equal, our job is easy.
            if (a === b) {
              return true;
            }
            // Object.prototype.toString returns a representation of the runtime type of
            // the given value that is considerably more precise than typeof.
            var aTag = toString.call(a);
            var bTag = toString.call(b);
            // If the runtime types of a and b are different, they could maybe be equal
            // under some interpretation of equality, but for simplicity and performance
            // we just return false instead.
            if (aTag !== bTag) {
              return false;
            }
            switch (aTag) {
              case '[object Array]':
                // Arrays are a lot like other objects, but we can cheaply compare their
                // lengths as a short-cut before comparing their elements.
                if (a.length !== b.length) return false;
              // Fall through to object case...
              case '[object Object]': {
                if (previouslyCompared(a, b)) return true;
                var aKeys = Object.keys(a);
                var bKeys = Object.keys(b);
                // If `a` and `b` have a different number of enumerable keys, they
                // must be different.
                var keyCount = aKeys.length;
                if (keyCount !== bKeys.length) return false;
                // Now make sure they have the same keys.
                for (var k = 0; k < keyCount; ++k) {
                  if (!hasOwnProperty.call(b, aKeys[k])) {
                    return false;
                  }
                }
                // Finally, check deep equality of all child properties.
                for (var k = 0; k < keyCount; ++k) {
                  var key = aKeys[k];
                  if (!check(a[key], b[key])) {
                    return false;
                  }
                }
                return true;
              }
              case '[object Error]':
                return a.name === b.name && a.message === b.message;
              case '[object Number]':
                // Handle NaN, which is !== itself.
                if (a !== a) return b !== b;
              // Fall through to shared +a === +b case...
              case '[object Boolean]':
              case '[object Date]':
                return +a === +b;
              case '[object RegExp]':
              case '[object String]':
                return a == '' + b;
              case '[object Map]':
              case '[object Set]': {
                if (a.size !== b.size) return false;
                if (previouslyCompared(a, b)) return true;
                var aIterator = a.entries();
                var isMap = aTag === '[object Map]';
                while (true) {
                  var info = aIterator.next();
                  if (info.done) break;
                  // If a instanceof Set, aValue === aKey.
                  var _a = info.value,
                    aKey = _a[0],
                    aValue = _a[1];
                  // So this works the same way for both Set and Map.
                  if (!b.has(aKey)) {
                    return false;
                  }
                  // However, we care about deep equality of values only when dealing
                  // with Map structures.
                  if (isMap && !check(aValue, b.get(aKey))) {
                    return false;
                  }
                }
                return true;
              }
              case '[object Function]': {
                var aCode = fnToStr.call(a);
                if (aCode !== fnToStr.call(b)) {
                  return false;
                }
                // We consider non-native functions equal if they have the same code
                // (native functions require === because their code is censored).
                // Note that this behavior is not entirely sound, since !== function
                // objects with the same code can behave differently depending on
                // their closure scope. However, any function can behave differently
                // depending on the values of its input arguments (including this)
                // and its calling context (including its closure scope), even
                // though the function object is === to itself; and it is entirely
                // possible for functions that are not === to behave exactly the
                // same under all conceivable circumstances. Because none of these
                // factors are statically decidable in JavaScript, JS function
                // equality is not well-defined. This ambiguity allows us to
                // consider the best possible heuristic among various imperfect
                // options, and equating non-native functions that have the same
                // code has enormous practical benefits, such as when comparing
                // functions that are repeatedly passed as fresh function
                // expressions within objects that are otherwise deeply equal. Since
                // any function created from the same syntactic expression (in the
                // same code location) will always stringify to the same code
                // according to fnToStr.call, we can reasonably expect these
                // repeatedly passed function expressions to have the same code, and
                // thus behave "the same" (with all the caveats mentioned above),
                // even though the runtime function objects are !== to one another.
                return !endsWith(aCode, nativeCodeSuffix);
              }
            }
            // Otherwise the values are not equal.
            return false;
          }
          var nativeCodeSuffix = '{ [native code] }';
          function endsWith(full, suffix) {
            var fromIndex = full.length - suffix.length;
            return (
              fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex
            );
          }
          function previouslyCompared(a, b) {
            // Though cyclic references can make an object graph appear infinite from the
            // perspective of a depth-first traversal, the graph still contains a finite
            // number of distinct object references. We use the previousComparisons cache
            // to avoid comparing the same pair of object references more than once, which
            // guarantees termination (even if we end up comparing every object in one
            // graph to every object in the other graph, which is extremely unlikely),
            // while still allowing weird isomorphic structures (like rings with different
            // lengths) a chance to pass the equality test.
            var bSet = previousComparisons.get(a);
            if (bSet) {
              // Return true here because we can be sure false will be returned somewhere
              // else if the objects are not equivalent.
              if (bSet.has(b)) return true;
            } else {
              previousComparisons.set(a, (bSet = new Set()));
            }
            bSet.add(b);
            return false;
          }

          /* harmony default export */ __webpack_exports__['default'] = equal;

          //# sourceMappingURL=equality.esm.js.map

          /***/
        },

      /***/ './node_modules/detect-browser/es/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/detect-browser/es/index.js ***!
  \*************************************************/
        /*! exports provided: BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, detect, browserName, parseUserAgent, detectOS, getNodeVersion */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* WEBPACK VAR INJECTION */ (function (process) {
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'BrowserInfo',
              function () {
                return BrowserInfo;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'NodeInfo',
              function () {
                return NodeInfo;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'SearchBotDeviceInfo',
              function () {
                return SearchBotDeviceInfo;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'BotInfo',
              function () {
                return BotInfo;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'ReactNativeInfo',
              function () {
                return ReactNativeInfo;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'detect',
              function () {
                return detect;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'browserName',
              function () {
                return browserName;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'parseUserAgent',
              function () {
                return parseUserAgent;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'detectOS',
              function () {
                return detectOS;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'getNodeVersion',
              function () {
                return getNodeVersion;
              }
            );
            var __spreadArrays =
              (undefined && undefined.__spreadArrays) ||
              function () {
                for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                  s += arguments[i].length;
                for (var r = Array(s), k = 0, i = 0; i < il; i++)
                  for (
                    var a = arguments[i], j = 0, jl = a.length;
                    j < jl;
                    j++, k++
                  )
                    r[k] = a[j];
                return r;
              };
            var BrowserInfo = /** @class */ (function () {
              function BrowserInfo(name, version, os) {
                this.name = name;
                this.version = version;
                this.os = os;
                this.type = 'browser';
              }
              return BrowserInfo;
            })();

            var NodeInfo = /** @class */ (function () {
              function NodeInfo(version) {
                this.version = version;
                this.type = 'node';
                this.name = 'node';
                this.os = process.platform;
              }
              return NodeInfo;
            })();

            var SearchBotDeviceInfo = /** @class */ (function () {
              function SearchBotDeviceInfo(name, version, os, bot) {
                this.name = name;
                this.version = version;
                this.os = os;
                this.bot = bot;
                this.type = 'bot-device';
              }
              return SearchBotDeviceInfo;
            })();

            var BotInfo = /** @class */ (function () {
              function BotInfo() {
                this.type = 'bot';
                this.bot = true; // NOTE: deprecated test name instead
                this.name = 'bot';
                this.version = null;
                this.os = null;
              }
              return BotInfo;
            })();

            var ReactNativeInfo = /** @class */ (function () {
              function ReactNativeInfo() {
                this.type = 'react-native';
                this.name = 'react-native';
                this.version = null;
                this.os = null;
              }
              return ReactNativeInfo;
            })();

            // tslint:disable-next-line:max-line-length
            var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
            var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
            var REQUIRED_VERSION_PARTS = 3;
            var userAgentRules = [
              ['aol', /AOLShield\/([0-9\._]+)/],
              ['edge', /Edge\/([0-9\._]+)/],
              ['edge-ios', /EdgiOS\/([0-9\._]+)/],
              ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
              ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
              ['samsung', /SamsungBrowser\/([0-9\.]+)/],
              ['silk', /\bSilk\/([0-9._-]+)\b/],
              ['miui', /MiuiBrowser\/([0-9\.]+)$/],
              ['beaker', /BeakerBrowser\/([0-9\.]+)/],
              ['edge-chromium', /Edg\/([0-9\.]+)/],
              [
                'chromium-webview',
                /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
              ],
              ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
              ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
              ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
              ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
              ['fxios', /FxiOS\/([0-9\.]+)/],
              ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
              ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
              ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
              ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
              ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
              ['ie', /MSIE\s(7\.0)/],
              ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
              ['android', /Android\s([0-9\.]+)/],
              ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
              ['safari', /Version\/([0-9\._]+).*Safari/],
              ['facebook', /FBAV\/([0-9\.]+)/],
              ['instagram', /Instagram\s([0-9\.]+)/],
              ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
              ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
              ['searchbot', SEARCHBOX_UA_REGEX],
            ];
            var operatingSystemRules = [
              ['iOS', /iP(hone|od|ad)/],
              ['Android OS', /Android/],
              ['BlackBerry OS', /BlackBerry|BB10/],
              ['Windows Mobile', /IEMobile/],
              ['Amazon OS', /Kindle/],
              ['Windows 3.11', /Win16/],
              ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
              ['Windows 98', /(Windows 98)|(Win98)/],
              ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
              ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
              ['Windows Server 2003', /(Windows NT 5.2)/],
              ['Windows Vista', /(Windows NT 6.0)/],
              ['Windows 7', /(Windows NT 6.1)/],
              ['Windows 8', /(Windows NT 6.2)/],
              ['Windows 8.1', /(Windows NT 6.3)/],
              ['Windows 10', /(Windows NT 10.0)/],
              ['Windows ME', /Windows ME/],
              ['Open BSD', /OpenBSD/],
              ['Sun OS', /SunOS/],
              ['Chrome OS', /CrOS/],
              ['Linux', /(Linux)|(X11)/],
              ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
              ['QNX', /QNX/],
              ['BeOS', /BeOS/],
              ['OS/2', /OS\/2/],
            ];
            function detect(userAgent) {
              if (!!userAgent) {
                return parseUserAgent(userAgent);
              }
              if (
                typeof document === 'undefined' &&
                typeof navigator !== 'undefined' &&
                navigator.product === 'ReactNative'
              ) {
                return new ReactNativeInfo();
              }
              if (typeof navigator !== 'undefined') {
                return parseUserAgent(navigator.userAgent);
              }
              return getNodeVersion();
            }
            function matchUserAgent(ua) {
              // opted for using reduce here rather than Array#first with a regex.test call
              // this is primarily because using the reduce we only perform the regex
              // execution once rather than once for the test and for the exec again below
              // probably something that needs to be benchmarked though
              return (
                ua !== '' &&
                userAgentRules.reduce(function (matched, _a) {
                  var browser = _a[0],
                    regex = _a[1];
                  if (matched) {
                    return matched;
                  }
                  var uaMatch = regex.exec(ua);
                  return !!uaMatch && [browser, uaMatch];
                }, false)
              );
            }
            function browserName(ua) {
              var data = matchUserAgent(ua);
              return data ? data[0] : null;
            }
            function parseUserAgent(ua) {
              var matchedRule = matchUserAgent(ua);
              if (!matchedRule) {
                return null;
              }
              var name = matchedRule[0],
                match = matchedRule[1];
              if (name === 'searchbot') {
                return new BotInfo();
              }
              var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
              if (versionParts) {
                if (versionParts.length < REQUIRED_VERSION_PARTS) {
                  versionParts = __spreadArrays(
                    versionParts,
                    createVersionParts(
                      REQUIRED_VERSION_PARTS - versionParts.length
                    )
                  );
                }
              } else {
                versionParts = [];
              }
              var version = versionParts.join('.');
              var os = detectOS(ua);
              var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
              if (searchBotMatch && searchBotMatch[1]) {
                return new SearchBotDeviceInfo(
                  name,
                  version,
                  os,
                  searchBotMatch[1]
                );
              }
              return new BrowserInfo(name, version, os);
            }
            function detectOS(ua) {
              for (
                var ii = 0, count = operatingSystemRules.length;
                ii < count;
                ii++
              ) {
                var _a = operatingSystemRules[ii],
                  os = _a[0],
                  regex = _a[1];
                var match = regex.exec(ua);
                if (match) {
                  return os;
                }
              }
              return null;
            }
            function getNodeVersion() {
              var isNode = typeof process !== 'undefined' && process.version;
              return isNode ? new NodeInfo(process.version.slice(1)) : null;
            }
            function createVersionParts(count) {
              var output = [];
              for (var ii = 0; ii < count; ii++) {
                output.push('0');
              }
              return output;
            }

            /* WEBPACK VAR INJECTION */
          }.call(
            this,
            __webpack_require__(
              /*! ./../../process/browser.js */ './node_modules/process/browser.js'
            )
          ));

          /***/
        },

      /***/ './node_modules/fast-json-stable-stringify/index.js':
        /*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          module.exports = function (data, opts) {
            if (!opts) opts = {};
            if (typeof opts === 'function') opts = { cmp: opts };
            var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

            var cmp =
              opts.cmp &&
              (function (f) {
                return function (node) {
                  return function (a, b) {
                    var aobj = { key: a, value: node[a] };
                    var bobj = { key: b, value: node[b] };
                    return f(aobj, bobj);
                  };
                };
              })(opts.cmp);

            var seen = [];
            return (function stringify(node) {
              if (node && node.toJSON && typeof node.toJSON === 'function') {
                node = node.toJSON();
              }

              if (node === undefined) return;
              if (typeof node == 'number')
                return isFinite(node) ? '' + node : 'null';
              if (typeof node !== 'object') return JSON.stringify(node);

              var i, out;
              if (Array.isArray(node)) {
                out = '[';
                for (i = 0; i < node.length; i++) {
                  if (i) out += ',';
                  out += stringify(node[i]) || 'null';
                }
                return out + ']';
              }

              if (node === null) return 'null';

              if (seen.indexOf(node) !== -1) {
                if (cycles) return JSON.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
              }

              var seenIndex = seen.push(node) - 1;
              var keys = Object.keys(node).sort(cmp && cmp(node));
              out = '';
              for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node[key]);

                if (!value) continue;
                if (out) out += ',';
                out += JSON.stringify(key) + ':' + value;
              }
              seen.splice(seenIndex, 1);
              return '{' + out + '}';
            })(data);
          };

          /***/
        },

      /***/ './node_modules/graphql-tag/src/index.js':
        /*!***********************************************!*\
  !*** ./node_modules/graphql-tag/src/index.js ***!
  \***********************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          var parser = __webpack_require__(
            /*! graphql/language/parser */ './node_modules/graphql/language/parser.js'
          );

          var parse = parser.parse;

          // Strip insignificant whitespace
          // Note that this could do a lot more, such as reorder fields etc.
          function normalize(string) {
            return string.replace(/[\s,]+/g, ' ').trim();
          }

          // A map docString -> graphql document
          var docCache = {};

          // A map fragmentName -> [normalized source]
          var fragmentSourceMap = {};

          function cacheKeyFromLoc(loc) {
            return normalize(loc.source.body.substring(loc.start, loc.end));
          }

          // For testing.
          function resetCaches() {
            docCache = {};
            fragmentSourceMap = {};
          }

          // Take a unstripped parsed document (query/mutation or even fragment), and
          // check all fragment definitions, checking for name->source uniqueness.
          // We also want to make sure only unique fragments exist in the document.
          var printFragmentWarnings = true;
          function processFragments(ast) {
            var astFragmentMap = {};
            var definitions = [];

            for (var i = 0; i < ast.definitions.length; i++) {
              var fragmentDefinition = ast.definitions[i];

              if (fragmentDefinition.kind === 'FragmentDefinition') {
                var fragmentName = fragmentDefinition.name.value;
                var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

                // We know something about this fragment
                if (
                  fragmentSourceMap.hasOwnProperty(fragmentName) &&
                  !fragmentSourceMap[fragmentName][sourceKey]
                ) {
                  // this is a problem because the app developer is trying to register another fragment with
                  // the same name as one previously registered. So, we tell them about it.
                  if (printFragmentWarnings) {
                    console.warn(
                      'Warning: fragment with name ' +
                        fragmentName +
                        ' already exists.\n' +
                        'graphql-tag enforces all fragment names across your application to be unique; read more about\n' +
                        'this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names'
                    );
                  }

                  fragmentSourceMap[fragmentName][sourceKey] = true;
                } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
                  fragmentSourceMap[fragmentName] = {};
                  fragmentSourceMap[fragmentName][sourceKey] = true;
                }

                if (!astFragmentMap[sourceKey]) {
                  astFragmentMap[sourceKey] = true;
                  definitions.push(fragmentDefinition);
                }
              } else {
                definitions.push(fragmentDefinition);
              }
            }

            ast.definitions = definitions;
            return ast;
          }

          function disableFragmentWarnings() {
            printFragmentWarnings = false;
          }

          function stripLoc(doc, removeLocAtThisLevel) {
            var docType = Object.prototype.toString.call(doc);

            if (docType === '[object Array]') {
              return doc.map(function (d) {
                return stripLoc(d, removeLocAtThisLevel);
              });
            }

            if (docType !== '[object Object]') {
              throw new Error('Unexpected input.');
            }

            // We don't want to remove the root loc field so we can use it
            // for fragment substitution (see below)
            if (removeLocAtThisLevel && doc.loc) {
              delete doc.loc;
            }

            // https://github.com/apollographql/graphql-tag/issues/40
            if (doc.loc) {
              delete doc.loc.startToken;
              delete doc.loc.endToken;
            }

            var keys = Object.keys(doc);
            var key;
            var value;
            var valueType;

            for (key in keys) {
              if (keys.hasOwnProperty(key)) {
                value = doc[keys[key]];
                valueType = Object.prototype.toString.call(value);

                if (
                  valueType === '[object Object]' ||
                  valueType === '[object Array]'
                ) {
                  doc[keys[key]] = stripLoc(value, true);
                }
              }
            }

            return doc;
          }

          var experimentalFragmentVariables = false;
          function parseDocument(doc) {
            var cacheKey = normalize(doc);

            if (docCache[cacheKey]) {
              return docCache[cacheKey];
            }

            var parsed = parse(doc, {
              experimentalFragmentVariables: experimentalFragmentVariables,
            });
            if (!parsed || parsed.kind !== 'Document') {
              throw new Error('Not a valid GraphQL document.');
            }

            // check that all "new" fragments inside the documents are consistent with
            // existing fragments of the same name
            parsed = processFragments(parsed);
            parsed = stripLoc(parsed, false);
            docCache[cacheKey] = parsed;

            return parsed;
          }

          function enableExperimentalFragmentVariables() {
            experimentalFragmentVariables = true;
          }

          function disableExperimentalFragmentVariables() {
            experimentalFragmentVariables = false;
          }

          // XXX This should eventually disallow arbitrary string interpolation, like Relay does
          function gql(/* arguments */) {
            var args = Array.prototype.slice.call(arguments);

            var literals = args[0];

            // We always get literals[0] and then matching post literals for each arg given
            var result = typeof literals === 'string' ? literals : literals[0];

            for (var i = 1; i < args.length; i++) {
              if (args[i] && args[i].kind && args[i].kind === 'Document') {
                result += args[i].loc.source.body;
              } else {
                result += args[i];
              }

              result += literals[i];
            }

            return parseDocument(result);
          }

          // Support typescript, which isn't as nice as Babel about default exports
          gql.default = gql;
          gql.resetCaches = resetCaches;
          gql.disableFragmentWarnings = disableFragmentWarnings;
          gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
          gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

          module.exports = gql;

          /***/
        },

      /***/ './node_modules/graphql/error/GraphQLError.js':
        /*!****************************************************!*\
  !*** ./node_modules/graphql/error/GraphQLError.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.printError = printError;
          exports.GraphQLError = void 0;

          var _isObjectLike = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/isObjectLike */ './node_modules/graphql/jsutils/isObjectLike.js'
            )
          );

          var _symbols = __webpack_require__(
            /*! ../polyfills/symbols */ './node_modules/graphql/polyfills/symbols.js'
          );

          var _location = __webpack_require__(
            /*! ../language/location */ './node_modules/graphql/language/location.js'
          );

          var _printLocation = __webpack_require__(
            /*! ../language/printLocation */ './node_modules/graphql/language/printLocation.js'
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _typeof(obj) {
            '@babel/helpers - typeof';
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true,
                },
              }
            );
            if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call;
            }
            return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return self;
          }

          function _wrapNativeSuper(Class) {
            var _cache = typeof Map === 'function' ? new Map() : undefined;
            _wrapNativeSuper = function _wrapNativeSuper(Class) {
              if (Class === null || !_isNativeFunction(Class)) return Class;
              if (typeof Class !== 'function') {
                throw new TypeError(
                  'Super expression must either be null or a function'
                );
              }
              if (typeof _cache !== 'undefined') {
                if (_cache.has(Class)) return _cache.get(Class);
                _cache.set(Class, Wrapper);
              }
              function Wrapper() {
                return _construct(
                  Class,
                  arguments,
                  _getPrototypeOf(this).constructor
                );
              }
              Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
              return _setPrototypeOf(Wrapper, Class);
            };
            return _wrapNativeSuper(Class);
          }

          function _construct(Parent, args, Class) {
            if (_isNativeReflectConstruct()) {
              _construct = Reflect.construct;
            } else {
              _construct = function _construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();
                if (Class) _setPrototypeOf(instance, Class.prototype);
                return instance;
              };
            }
            return _construct.apply(null, arguments);
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === 'undefined' || !Reflect.construct)
              return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === 'function') return true;
            try {
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              );
              return true;
            } catch (e) {
              return false;
            }
          }

          function _isNativeFunction(fn) {
            return Function.toString.call(fn).indexOf('[native code]') !== -1;
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
              };
            return _setPrototypeOf(o, p);
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                };
            return _getPrototypeOf(o);
          }

          /**
           * A GraphQLError describes an Error found during the parse, validate, or
           * execute phases of performing a GraphQL operation. In addition to a message
           * and stack trace, it also includes information about the locations in a
           * GraphQL document and/or execution result that correspond to the Error.
           */
          var GraphQLError = /*#__PURE__*/ (function (_Error) {
            _inherits(GraphQLError, _Error);

            var _super = _createSuper(GraphQLError);

            /**
             * A message describing the Error for debugging purposes.
             *
             * Enumerable, and appears in the result of JSON.stringify().
             *
             * Note: should be treated as readonly, despite invariant usage.
             */

            /**
             * An array of { line, column } locations within the source GraphQL document
             * which correspond to this error.
             *
             * Errors during validation often contain multiple locations, for example to
             * point out two things with the same name. Errors during execution include a
             * single location, the field which produced the error.
             *
             * Enumerable, and appears in the result of JSON.stringify().
             */

            /**
             * An array describing the JSON-path into the execution response which
             * corresponds to this error. Only included for errors during execution.
             *
             * Enumerable, and appears in the result of JSON.stringify().
             */

            /**
             * An array of GraphQL AST Nodes corresponding to this error.
             */

            /**
             * The source GraphQL document for the first location of this error.
             *
             * Note that if this Error represents more than one node, the source may not
             * represent nodes after the first node.
             */

            /**
             * An array of character offsets within the source GraphQL document
             * which correspond to this error.
             */

            /**
             * The original error thrown from a field resolver during execution.
             */

            /**
             * Extension fields to add to the formatted error.
             */
            function GraphQLError(
              message,
              nodes,
              source,
              positions,
              path,
              originalError,
              extensions
            ) {
              var _locations2, _source2, _positions2, _extensions2;

              var _this;

              _classCallCheck(this, GraphQLError);

              _this = _super.call(this, message); // Compute list of blame nodes.

              var _nodes = Array.isArray(nodes)
                ? nodes.length !== 0
                  ? nodes
                  : undefined
                : nodes
                ? [nodes]
                : undefined; // Compute locations in the source for the given nodes/positions.

              var _source = source;

              if (!_source && _nodes) {
                var _nodes$0$loc;

                _source =
                  (_nodes$0$loc = _nodes[0].loc) === null ||
                  _nodes$0$loc === void 0
                    ? void 0
                    : _nodes$0$loc.source;
              }

              var _positions = positions;

              if (!_positions && _nodes) {
                _positions = _nodes.reduce(function (list, node) {
                  if (node.loc) {
                    list.push(node.loc.start);
                  }

                  return list;
                }, []);
              }

              if (_positions && _positions.length === 0) {
                _positions = undefined;
              }

              var _locations;

              if (positions && source) {
                _locations = positions.map(function (pos) {
                  return (0, _location.getLocation)(source, pos);
                });
              } else if (_nodes) {
                _locations = _nodes.reduce(function (list, node) {
                  if (node.loc) {
                    list.push(
                      (0, _location.getLocation)(
                        node.loc.source,
                        node.loc.start
                      )
                    );
                  }

                  return list;
                }, []);
              }

              var _extensions = extensions;

              if (_extensions == null && originalError != null) {
                var originalExtensions = originalError.extensions;

                if ((0, _isObjectLike.default)(originalExtensions)) {
                  _extensions = originalExtensions;
                }
              }

              Object.defineProperties(_assertThisInitialized(_this), {
                name: {
                  value: 'GraphQLError',
                },
                message: {
                  value: message,
                  // By being enumerable, JSON.stringify will include `message` in the
                  // resulting output. This ensures that the simplest possible GraphQL
                  // service adheres to the spec.
                  enumerable: true,
                  writable: true,
                },
                locations: {
                  // Coercing falsy values to undefined ensures they will not be included
                  // in JSON.stringify() when not provided.
                  value:
                    (_locations2 = _locations) !== null &&
                    _locations2 !== void 0
                      ? _locations2
                      : undefined,
                  // By being enumerable, JSON.stringify will include `locations` in the
                  // resulting output. This ensures that the simplest possible GraphQL
                  // service adheres to the spec.
                  enumerable: _locations != null,
                },
                path: {
                  // Coercing falsy values to undefined ensures they will not be included
                  // in JSON.stringify() when not provided.
                  value: path !== null && path !== void 0 ? path : undefined,
                  // By being enumerable, JSON.stringify will include `path` in the
                  // resulting output. This ensures that the simplest possible GraphQL
                  // service adheres to the spec.
                  enumerable: path != null,
                },
                nodes: {
                  value:
                    _nodes !== null && _nodes !== void 0 ? _nodes : undefined,
                },
                source: {
                  value:
                    (_source2 = _source) !== null && _source2 !== void 0
                      ? _source2
                      : undefined,
                },
                positions: {
                  value:
                    (_positions2 = _positions) !== null &&
                    _positions2 !== void 0
                      ? _positions2
                      : undefined,
                },
                originalError: {
                  value: originalError,
                },
                extensions: {
                  // Coercing falsy values to undefined ensures they will not be included
                  // in JSON.stringify() when not provided.
                  value:
                    (_extensions2 = _extensions) !== null &&
                    _extensions2 !== void 0
                      ? _extensions2
                      : undefined,
                  // By being enumerable, JSON.stringify will include `path` in the
                  // resulting output. This ensures that the simplest possible GraphQL
                  // service adheres to the spec.
                  enumerable: _extensions != null,
                },
              }); // Include (non-enumerable) stack trace.

              if (
                originalError === null || originalError === void 0
                  ? void 0
                  : originalError.stack
              ) {
                Object.defineProperty(_assertThisInitialized(_this), 'stack', {
                  value: originalError.stack,
                  writable: true,
                  configurable: true,
                });
                return _possibleConstructorReturn(_this);
              } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

              if (Error.captureStackTrace) {
                Error.captureStackTrace(
                  _assertThisInitialized(_this),
                  GraphQLError
                );
              } else {
                Object.defineProperty(_assertThisInitialized(_this), 'stack', {
                  value: Error().stack,
                  writable: true,
                  configurable: true,
                });
              }

              return _this;
            }

            _createClass(GraphQLError, [
              {
                key: 'toString',
                value: function toString() {
                  return printError(this);
                }, // FIXME: workaround to not break chai comparisons, should be remove in v16
                // $FlowFixMe Flow doesn't support computed properties yet
              },
              {
                key: _symbols.SYMBOL_TO_STRING_TAG,
                get: function get() {
                  return 'Object';
                },
              },
            ]);

            return GraphQLError;
          })(/*#__PURE__*/ _wrapNativeSuper(Error));
          /**
           * Prints a GraphQLError to a string, representing useful location information
           * about the error's position in the source.
           */

          exports.GraphQLError = GraphQLError;

          function printError(error) {
            var output = error.message;

            if (error.nodes) {
              for (
                var _i2 = 0, _error$nodes2 = error.nodes;
                _i2 < _error$nodes2.length;
                _i2++
              ) {
                var node = _error$nodes2[_i2];

                if (node.loc) {
                  output +=
                    '\n\n' + (0, _printLocation.printLocation)(node.loc);
                }
              }
            } else if (error.source && error.locations) {
              for (
                var _i4 = 0, _error$locations2 = error.locations;
                _i4 < _error$locations2.length;
                _i4++
              ) {
                var location = _error$locations2[_i4];
                output +=
                  '\n\n' +
                  (0, _printLocation.printSourceLocation)(
                    error.source,
                    location
                  );
              }
            }

            return output;
          }

          /***/
        },

      /***/ './node_modules/graphql/error/syntaxError.js':
        /*!***************************************************!*\
  !*** ./node_modules/graphql/error/syntaxError.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.syntaxError = syntaxError;

          var _GraphQLError = __webpack_require__(
            /*! ./GraphQLError */ './node_modules/graphql/error/GraphQLError.js'
          );

          /**
           * Produces a GraphQLError representing a syntax error, containing useful
           * descriptive information about the syntax error's position in the source.
           */
          function syntaxError(source, position, description) {
            return new _GraphQLError.GraphQLError(
              'Syntax Error: '.concat(description),
              undefined,
              source,
              [position]
            );
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/defineInspect.js':
        /*!*******************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineInspect.js ***!
  \*******************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = defineInspect;

          var _invariant = _interopRequireDefault(
            __webpack_require__(
              /*! ./invariant */ './node_modules/graphql/jsutils/invariant.js'
            )
          );

          var _nodejsCustomInspectSymbol = _interopRequireDefault(
            __webpack_require__(
              /*! ./nodejsCustomInspectSymbol */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js'
            )
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`
           */
          function defineInspect(classObject) {
            var fn = classObject.prototype.toJSON;
            typeof fn === 'function' || (0, _invariant.default)(0);
            classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')

            if (_nodejsCustomInspectSymbol.default) {
              classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;
            }
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/devAssert.js':
        /*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/devAssert.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = devAssert;

          function devAssert(condition, message) {
            var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

            if (!booleanCondition) {
              throw new Error(message);
            }
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/inspect.js':
        /*!*************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = inspect;

          var _nodejsCustomInspectSymbol = _interopRequireDefault(
            __webpack_require__(
              /*! ./nodejsCustomInspectSymbol */ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js'
            )
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _typeof(obj) {
            '@babel/helpers - typeof';
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          var MAX_ARRAY_LENGTH = 10;
          var MAX_RECURSIVE_DEPTH = 2;
          /**
           * Used to print values in error messages.
           */

          function inspect(value) {
            return formatValue(value, []);
          }

          function formatValue(value, seenValues) {
            switch (_typeof(value)) {
              case 'string':
                return JSON.stringify(value);

              case 'function':
                return value.name
                  ? '[function '.concat(value.name, ']')
                  : '[function]';

              case 'object':
                if (value === null) {
                  return 'null';
                }

                return formatObjectValue(value, seenValues);

              default:
                return String(value);
            }
          }

          function formatObjectValue(value, previouslySeenValues) {
            if (previouslySeenValues.indexOf(value) !== -1) {
              return '[Circular]';
            }

            var seenValues = [].concat(previouslySeenValues, [value]);
            var customInspectFn = getCustomFn(value);

            if (customInspectFn !== undefined) {
              // $FlowFixMe(>=0.90.0)
              var customValue = customInspectFn.call(value); // check for infinite recursion

              if (customValue !== value) {
                return typeof customValue === 'string'
                  ? customValue
                  : formatValue(customValue, seenValues);
              }
            } else if (Array.isArray(value)) {
              return formatArray(value, seenValues);
            }

            return formatObject(value, seenValues);
          }

          function formatObject(object, seenValues) {
            var keys = Object.keys(object);

            if (keys.length === 0) {
              return '{}';
            }

            if (seenValues.length > MAX_RECURSIVE_DEPTH) {
              return '[' + getObjectTag(object) + ']';
            }

            var properties = keys.map(function (key) {
              var value = formatValue(object[key], seenValues);
              return key + ': ' + value;
            });
            return '{ ' + properties.join(', ') + ' }';
          }

          function formatArray(array, seenValues) {
            if (array.length === 0) {
              return '[]';
            }

            if (seenValues.length > MAX_RECURSIVE_DEPTH) {
              return '[Array]';
            }

            var len = Math.min(MAX_ARRAY_LENGTH, array.length);
            var remaining = array.length - len;
            var items = [];

            for (var i = 0; i < len; ++i) {
              items.push(formatValue(array[i], seenValues));
            }

            if (remaining === 1) {
              items.push('... 1 more item');
            } else if (remaining > 1) {
              items.push('... '.concat(remaining, ' more items'));
            }

            return '[' + items.join(', ') + ']';
          }

          function getCustomFn(object) {
            var customInspectFn =
              object[String(_nodejsCustomInspectSymbol.default)];

            if (typeof customInspectFn === 'function') {
              return customInspectFn;
            }

            if (typeof object.inspect === 'function') {
              return object.inspect;
            }
          }

          function getObjectTag(object) {
            var tag = Object.prototype.toString
              .call(object)
              .replace(/^\[object /, '')
              .replace(/]$/, '');

            if (tag === 'Object' && typeof object.constructor === 'function') {
              var name = object.constructor.name;

              if (typeof name === 'string' && name !== '') {
                return name;
              }
            }

            return tag;
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/invariant.js':
        /*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = invariant;

          function invariant(condition, message) {
            var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

            if (!booleanCondition) {
              throw new Error(
                message != null ? message : 'Unexpected invariant triggered.'
              );
            }
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/isObjectLike.js':
        /*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/isObjectLike.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = isObjectLike;

          function _typeof(obj) {
            '@babel/helpers - typeof';
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          /**
           * Return true if `value` is object-like. A value is object-like if it's not
           * `null` and has a `typeof` result of "object".
           */
          function isObjectLike(value) {
            return _typeof(value) == 'object' && value !== null;
          }

          /***/
        },

      /***/ './node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js':
        /*!*******************************************************************!*\
  !*** ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.default = void 0;
          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
          var nodejsCustomInspectSymbol =
            typeof Symbol === 'function' && typeof Symbol.for === 'function'
              ? Symbol.for('nodejs.util.inspect.custom')
              : undefined;
          var _default = nodejsCustomInspectSymbol;
          exports.default = _default;

          /***/
        },

      /***/ './node_modules/graphql/language/ast.js':
        /*!**********************************************!*\
  !*** ./node_modules/graphql/language/ast.js ***!
  \**********************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.isNode = isNode;
          exports.Token = exports.Location = void 0;

          var _defineInspect = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/defineInspect */ './node_modules/graphql/jsutils/defineInspect.js'
            )
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Contains a range of UTF-8 character offsets and token references that
           * identify the region of the source from which the AST derived.
           */
          var Location = /*#__PURE__*/ (function () {
            /**
             * The character offset at which this Node begins.
             */

            /**
             * The character offset at which this Node ends.
             */

            /**
             * The Token at which this Node begins.
             */

            /**
             * The Token at which this Node ends.
             */

            /**
             * The Source document the AST represents.
             */
            function Location(startToken, endToken, source) {
              this.start = startToken.start;
              this.end = endToken.end;
              this.startToken = startToken;
              this.endToken = endToken;
              this.source = source;
            }

            var _proto = Location.prototype;

            _proto.toJSON = function toJSON() {
              return {
                start: this.start,
                end: this.end,
              };
            };

            return Location;
          })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

          exports.Location = Location;
          (0, _defineInspect.default)(Location);
          /**
           * Represents a range of characters represented by a lexical token
           * within a Source.
           */

          var Token = /*#__PURE__*/ (function () {
            /**
             * The kind of Token.
             */

            /**
             * The character offset at which this Node begins.
             */

            /**
             * The character offset at which this Node ends.
             */

            /**
             * The 1-indexed line number on which this Token appears.
             */

            /**
             * The 1-indexed column number at which this Token begins.
             */

            /**
             * For non-punctuation tokens, represents the interpreted value of the token.
             */

            /**
             * Tokens exist as nodes in a double-linked-list amongst all tokens
             * including ignored tokens. <SOF> is always the first node and <EOF>
             * the last.
             */
            function Token(kind, start, end, line, column, prev, value) {
              this.kind = kind;
              this.start = start;
              this.end = end;
              this.line = line;
              this.column = column;
              this.value = value;
              this.prev = prev;
              this.next = null;
            }

            var _proto2 = Token.prototype;

            _proto2.toJSON = function toJSON() {
              return {
                kind: this.kind,
                value: this.value,
                line: this.line,
                column: this.column,
              };
            };

            return Token;
          })(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

          exports.Token = Token;
          (0, _defineInspect.default)(Token);
          /**
           * @internal
           */

          function isNode(maybeNode) {
            return maybeNode != null && typeof maybeNode.kind === 'string';
          }
          /**
           * The list of all possible AST node types.
           */

          /***/
        },

      /***/ './node_modules/graphql/language/blockString.js':
        /*!******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.dedentBlockStringValue = dedentBlockStringValue;
          exports.getBlockStringIndentation = getBlockStringIndentation;
          exports.printBlockString = printBlockString;

          /**
           * Produces the value of a block string from its parsed raw value, similar to
           * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
           *
           * This implements the GraphQL spec's BlockStringValue() static algorithm.
           *
           * @internal
           */
          function dedentBlockStringValue(rawString) {
            // Expand a block string's raw value into independent lines.
            var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

            var commonIndent = getBlockStringIndentation(lines);

            if (commonIndent !== 0) {
              for (var i = 1; i < lines.length; i++) {
                lines[i] = lines[i].slice(commonIndent);
              }
            } // Remove leading and trailing blank lines.

            while (lines.length > 0 && isBlank(lines[0])) {
              lines.shift();
            }

            while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
              lines.pop();
            } // Return a string of the lines joined with U+000A.

            return lines.join('\n');
          }
          /**
           * @internal
           */

          function getBlockStringIndentation(lines) {
            var commonIndent = null;

            for (var i = 1; i < lines.length; i++) {
              var line = lines[i];
              var indent = leadingWhitespace(line);

              if (indent === line.length) {
                continue; // skip empty lines
              }

              if (commonIndent === null || indent < commonIndent) {
                commonIndent = indent;

                if (commonIndent === 0) {
                  break;
                }
              }
            }

            return commonIndent === null ? 0 : commonIndent;
          }

          function leadingWhitespace(str) {
            var i = 0;

            while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
              i++;
            }

            return i;
          }

          function isBlank(str) {
            return leadingWhitespace(str) === str.length;
          }
          /**
           * Print a block string in the indented block form by adding a leading and
           * trailing blank line. However, if a block string starts with whitespace and is
           * a single-line, adding a leading blank line would strip that whitespace.
           *
           * @internal
           */

          function printBlockString(value) {
            var indentation =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : '';
            var preferMultipleLines =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false;
            var isSingleLine = value.indexOf('\n') === -1;
            var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
            var hasTrailingQuote = value[value.length - 1] === '"';
            var hasTrailingSlash = value[value.length - 1] === '\\';
            var printAsMultipleLines =
              !isSingleLine ||
              hasTrailingQuote ||
              hasTrailingSlash ||
              preferMultipleLines;
            var result = ''; // Format a multi-line block quote to account for leading space.

            if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
              result += '\n' + indentation;
            }

            result += indentation
              ? value.replace(/\n/g, '\n' + indentation)
              : value;

            if (printAsMultipleLines) {
              result += '\n';
            }

            return '"""' + result.replace(/"""/g, '\\"""') + '"""';
          }

          /***/
        },

      /***/ './node_modules/graphql/language/directiveLocation.js':
        /*!************************************************************!*\
  !*** ./node_modules/graphql/language/directiveLocation.js ***!
  \************************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.DirectiveLocation = void 0;

          /**
           * The set of allowed directive location values.
           */
          var DirectiveLocation = Object.freeze({
            // Request Definitions
            QUERY: 'QUERY',
            MUTATION: 'MUTATION',
            SUBSCRIPTION: 'SUBSCRIPTION',
            FIELD: 'FIELD',
            FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
            FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
            INLINE_FRAGMENT: 'INLINE_FRAGMENT',
            VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
            // Type System Definitions
            SCHEMA: 'SCHEMA',
            SCALAR: 'SCALAR',
            OBJECT: 'OBJECT',
            FIELD_DEFINITION: 'FIELD_DEFINITION',
            ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
            INTERFACE: 'INTERFACE',
            UNION: 'UNION',
            ENUM: 'ENUM',
            ENUM_VALUE: 'ENUM_VALUE',
            INPUT_OBJECT: 'INPUT_OBJECT',
            INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION',
          });
          /**
           * The enum type representing the directive location values.
           */

          exports.DirectiveLocation = DirectiveLocation;

          /***/
        },

      /***/ './node_modules/graphql/language/kinds.js':
        /*!************************************************!*\
  !*** ./node_modules/graphql/language/kinds.js ***!
  \************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.Kind = void 0;

          /**
           * The set of allowed kind values for AST nodes.
           */
          var Kind = Object.freeze({
            // Name
            NAME: 'Name',
            // Document
            DOCUMENT: 'Document',
            OPERATION_DEFINITION: 'OperationDefinition',
            VARIABLE_DEFINITION: 'VariableDefinition',
            SELECTION_SET: 'SelectionSet',
            FIELD: 'Field',
            ARGUMENT: 'Argument',
            // Fragments
            FRAGMENT_SPREAD: 'FragmentSpread',
            INLINE_FRAGMENT: 'InlineFragment',
            FRAGMENT_DEFINITION: 'FragmentDefinition',
            // Values
            VARIABLE: 'Variable',
            INT: 'IntValue',
            FLOAT: 'FloatValue',
            STRING: 'StringValue',
            BOOLEAN: 'BooleanValue',
            NULL: 'NullValue',
            ENUM: 'EnumValue',
            LIST: 'ListValue',
            OBJECT: 'ObjectValue',
            OBJECT_FIELD: 'ObjectField',
            // Directives
            DIRECTIVE: 'Directive',
            // Types
            NAMED_TYPE: 'NamedType',
            LIST_TYPE: 'ListType',
            NON_NULL_TYPE: 'NonNullType',
            // Type System Definitions
            SCHEMA_DEFINITION: 'SchemaDefinition',
            OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
            // Type Definitions
            SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
            OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
            FIELD_DEFINITION: 'FieldDefinition',
            INPUT_VALUE_DEFINITION: 'InputValueDefinition',
            INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
            UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
            ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
            ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
            INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
            // Directive Definitions
            DIRECTIVE_DEFINITION: 'DirectiveDefinition',
            // Type System Extensions
            SCHEMA_EXTENSION: 'SchemaExtension',
            // Type Extensions
            SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
            OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
            INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
            UNION_TYPE_EXTENSION: 'UnionTypeExtension',
            ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
            INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',
          });
          /**
           * The enum type representing the possible kind values of AST nodes.
           */

          exports.Kind = Kind;

          /***/
        },

      /***/ './node_modules/graphql/language/lexer.js':
        /*!************************************************!*\
  !*** ./node_modules/graphql/language/lexer.js ***!
  \************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
          exports.Lexer = void 0;

          var _syntaxError = __webpack_require__(
            /*! ../error/syntaxError */ './node_modules/graphql/error/syntaxError.js'
          );

          var _ast = __webpack_require__(
            /*! ./ast */ './node_modules/graphql/language/ast.js'
          );

          var _tokenKind = __webpack_require__(
            /*! ./tokenKind */ './node_modules/graphql/language/tokenKind.js'
          );

          var _blockString = __webpack_require__(
            /*! ./blockString */ './node_modules/graphql/language/blockString.js'
          );

          /**
           * Given a Source object, creates a Lexer for that source.
           * A Lexer is a stateful stream generator in that every time
           * it is advanced, it returns the next token in the Source. Assuming the
           * source lexes, the final Token emitted by the lexer will be of kind
           * EOF, after which the lexer will repeatedly return the same EOF token
           * whenever called.
           */
          var Lexer = /*#__PURE__*/ (function () {
            /**
             * The previously focused non-ignored token.
             */

            /**
             * The currently focused non-ignored token.
             */

            /**
             * The (1-indexed) line containing the current token.
             */

            /**
             * The character offset at which the current line begins.
             */
            function Lexer(source) {
              var startOfFileToken = new _ast.Token(
                _tokenKind.TokenKind.SOF,
                0,
                0,
                0,
                0,
                null
              );
              this.source = source;
              this.lastToken = startOfFileToken;
              this.token = startOfFileToken;
              this.line = 1;
              this.lineStart = 0;
            }
            /**
             * Advances the token stream to the next non-ignored token.
             */

            var _proto = Lexer.prototype;

            _proto.advance = function advance() {
              this.lastToken = this.token;
              var token = (this.token = this.lookahead());
              return token;
            };
            /**
             * Looks ahead and returns the next non-ignored token, but does not change
             * the state of Lexer.
             */

            _proto.lookahead = function lookahead() {
              var token = this.token;

              if (token.kind !== _tokenKind.TokenKind.EOF) {
                do {
                  var _token$next;

                  // Note: next is only mutable during parsing, so we cast to allow this.
                  token =
                    (_token$next = token.next) !== null &&
                    _token$next !== void 0
                      ? _token$next
                      : (token.next = readToken(this, token));
                } while (token.kind === _tokenKind.TokenKind.COMMENT);
              }

              return token;
            };

            return Lexer;
          })();
          /**
           * @internal
           */

          exports.Lexer = Lexer;

          function isPunctuatorTokenKind(kind) {
            return (
              kind === _tokenKind.TokenKind.BANG ||
              kind === _tokenKind.TokenKind.DOLLAR ||
              kind === _tokenKind.TokenKind.AMP ||
              kind === _tokenKind.TokenKind.PAREN_L ||
              kind === _tokenKind.TokenKind.PAREN_R ||
              kind === _tokenKind.TokenKind.SPREAD ||
              kind === _tokenKind.TokenKind.COLON ||
              kind === _tokenKind.TokenKind.EQUALS ||
              kind === _tokenKind.TokenKind.AT ||
              kind === _tokenKind.TokenKind.BRACKET_L ||
              kind === _tokenKind.TokenKind.BRACKET_R ||
              kind === _tokenKind.TokenKind.BRACE_L ||
              kind === _tokenKind.TokenKind.PIPE ||
              kind === _tokenKind.TokenKind.BRACE_R
            );
          }

          function printCharCode(code) {
            return (
              // NaN/undefined represents access beyond the end of the file.
              isNaN(code)
                ? _tokenKind.TokenKind.EOF // Trust JSON for ASCII.
                : code < 0x007f
                ? JSON.stringify(String.fromCharCode(code)) // Otherwise print the escaped form.
                : '"\\u'.concat(
                    ('00' + code.toString(16).toUpperCase()).slice(-4),
                    '"'
                  )
            );
          }
          /**
           * Gets the next token from the source starting at the given position.
           *
           * This skips over whitespace until it finds the next lexable token, then lexes
           * punctuators immediately or calls the appropriate helper function for more
           * complicated tokens.
           */

          function readToken(lexer, prev) {
            var source = lexer.source;
            var body = source.body;
            var bodyLength = body.length;
            var pos = positionAfterWhitespace(body, prev.end, lexer);
            var line = lexer.line;
            var col = 1 + pos - lexer.lineStart;

            if (pos >= bodyLength) {
              return new _ast.Token(
                _tokenKind.TokenKind.EOF,
                bodyLength,
                bodyLength,
                line,
                col,
                prev
              );
            }

            var code = body.charCodeAt(pos); // SourceCharacter

            switch (code) {
              // !
              case 33:
                return new _ast.Token(
                  _tokenKind.TokenKind.BANG,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // #

              case 35:
                return readComment(source, pos, line, col, prev);
              // $

              case 36:
                return new _ast.Token(
                  _tokenKind.TokenKind.DOLLAR,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // &

              case 38:
                return new _ast.Token(
                  _tokenKind.TokenKind.AMP,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // (

              case 40:
                return new _ast.Token(
                  _tokenKind.TokenKind.PAREN_L,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // )

              case 41:
                return new _ast.Token(
                  _tokenKind.TokenKind.PAREN_R,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // .

              case 46:
                if (
                  body.charCodeAt(pos + 1) === 46 &&
                  body.charCodeAt(pos + 2) === 46
                ) {
                  return new _ast.Token(
                    _tokenKind.TokenKind.SPREAD,
                    pos,
                    pos + 3,
                    line,
                    col,
                    prev
                  );
                }

                break;
              // :

              case 58:
                return new _ast.Token(
                  _tokenKind.TokenKind.COLON,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // =

              case 61:
                return new _ast.Token(
                  _tokenKind.TokenKind.EQUALS,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // @

              case 64:
                return new _ast.Token(
                  _tokenKind.TokenKind.AT,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // [

              case 91:
                return new _ast.Token(
                  _tokenKind.TokenKind.BRACKET_L,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // ]

              case 93:
                return new _ast.Token(
                  _tokenKind.TokenKind.BRACKET_R,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // {

              case 123:
                return new _ast.Token(
                  _tokenKind.TokenKind.BRACE_L,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // |

              case 124:
                return new _ast.Token(
                  _tokenKind.TokenKind.PIPE,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // }

              case 125:
                return new _ast.Token(
                  _tokenKind.TokenKind.BRACE_R,
                  pos,
                  pos + 1,
                  line,
                  col,
                  prev
                );
              // A-Z _ a-z

              case 65:
              case 66:
              case 67:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
              case 81:
              case 82:
              case 83:
              case 84:
              case 85:
              case 86:
              case 87:
              case 88:
              case 89:
              case 90:
              case 95:
              case 97:
              case 98:
              case 99:
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
              case 108:
              case 109:
              case 110:
              case 111:
              case 112:
              case 113:
              case 114:
              case 115:
              case 116:
              case 117:
              case 118:
              case 119:
              case 120:
              case 121:
              case 122:
                return readName(source, pos, line, col, prev);
              // - 0-9

              case 45:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return readNumber(source, pos, code, line, col, prev);
              // "

              case 34:
                if (
                  body.charCodeAt(pos + 1) === 34 &&
                  body.charCodeAt(pos + 2) === 34
                ) {
                  return readBlockString(source, pos, line, col, prev, lexer);
                }

                return readString(source, pos, line, col, prev);
            }

            throw (0, _syntaxError.syntaxError)(
              source,
              pos,
              unexpectedCharacterMessage(code)
            );
          }
          /**
           * Report a message that an unexpected character was encountered.
           */

          function unexpectedCharacterMessage(code) {
            if (
              code < 0x0020 &&
              code !== 0x0009 &&
              code !== 0x000a &&
              code !== 0x000d
            ) {
              return 'Cannot contain the invalid character '.concat(
                printCharCode(code),
                '.'
              );
            }

            if (code === 39) {
              // '
              return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
            }

            return 'Cannot parse the unexpected character '.concat(
              printCharCode(code),
              '.'
            );
          }
          /**
           * Reads from body starting at startPosition until it finds a non-whitespace
           * character, then returns the position of that character for lexing.
           */

          function positionAfterWhitespace(body, startPosition, lexer) {
            var bodyLength = body.length;
            var position = startPosition;

            while (position < bodyLength) {
              var code = body.charCodeAt(position); // tab | space | comma | BOM

              if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
                ++position;
              } else if (code === 10) {
                // new line
                ++position;
                ++lexer.line;
                lexer.lineStart = position;
              } else if (code === 13) {
                // carriage return
                if (body.charCodeAt(position + 1) === 10) {
                  position += 2;
                } else {
                  ++position;
                }

                ++lexer.line;
                lexer.lineStart = position;
              } else {
                break;
              }
            }

            return position;
          }
          /**
           * Reads a comment token from the source file.
           *
           * #[\u0009\u0020-\uFFFF]*
           */

          function readComment(source, start, line, col, prev) {
            var body = source.body;
            var code;
            var position = start;

            do {
              code = body.charCodeAt(++position);
            } while (
              !isNaN(code) && // SourceCharacter but not LineTerminator
              (code > 0x001f || code === 0x0009)
            );

            return new _ast.Token(
              _tokenKind.TokenKind.COMMENT,
              start,
              position,
              line,
              col,
              prev,
              body.slice(start + 1, position)
            );
          }
          /**
           * Reads a number token from the source file, either a float
           * or an int depending on whether a decimal point appears.
           *
           * Int:   -?(0|[1-9][0-9]*)
           * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
           */

          function readNumber(source, start, firstCode, line, col, prev) {
            var body = source.body;
            var code = firstCode;
            var position = start;
            var isFloat = false;

            if (code === 45) {
              // -
              code = body.charCodeAt(++position);
            }

            if (code === 48) {
              // 0
              code = body.charCodeAt(++position);

              if (code >= 48 && code <= 57) {
                throw (0, _syntaxError.syntaxError)(
                  source,
                  position,
                  'Invalid number, unexpected digit after 0: '.concat(
                    printCharCode(code),
                    '.'
                  )
                );
              }
            } else {
              position = readDigits(source, position, code);
              code = body.charCodeAt(position);
            }

            if (code === 46) {
              // .
              isFloat = true;
              code = body.charCodeAt(++position);
              position = readDigits(source, position, code);
              code = body.charCodeAt(position);
            }

            if (code === 69 || code === 101) {
              // E e
              isFloat = true;
              code = body.charCodeAt(++position);

              if (code === 43 || code === 45) {
                // + -
                code = body.charCodeAt(++position);
              }

              position = readDigits(source, position, code);
              code = body.charCodeAt(position);
            } // Numbers cannot be followed by . or NameStart

            if (code === 46 || isNameStart(code)) {
              throw (0, _syntaxError.syntaxError)(
                source,
                position,
                'Invalid number, expected digit but got: '.concat(
                  printCharCode(code),
                  '.'
                )
              );
            }

            return new _ast.Token(
              isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
              start,
              position,
              line,
              col,
              prev,
              body.slice(start, position)
            );
          }
          /**
           * Returns the new position in the source after reading digits.
           */

          function readDigits(source, start, firstCode) {
            var body = source.body;
            var position = start;
            var code = firstCode;

            if (code >= 48 && code <= 57) {
              // 0 - 9
              do {
                code = body.charCodeAt(++position);
              } while (code >= 48 && code <= 57); // 0 - 9

              return position;
            }

            throw (0, _syntaxError.syntaxError)(
              source,
              position,
              'Invalid number, expected digit but got: '.concat(
                printCharCode(code),
                '.'
              )
            );
          }
          /**
           * Reads a string token from the source file.
           *
           * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
           */

          function readString(source, start, line, col, prev) {
            var body = source.body;
            var position = start + 1;
            var chunkStart = position;
            var code = 0;
            var value = '';

            while (
              position < body.length &&
              !isNaN((code = body.charCodeAt(position))) && // not LineTerminator
              code !== 0x000a &&
              code !== 0x000d
            ) {
              // Closing Quote (")
              if (code === 34) {
                value += body.slice(chunkStart, position);
                return new _ast.Token(
                  _tokenKind.TokenKind.STRING,
                  start,
                  position + 1,
                  line,
                  col,
                  prev,
                  value
                );
              } // SourceCharacter

              if (code < 0x0020 && code !== 0x0009) {
                throw (0, _syntaxError.syntaxError)(
                  source,
                  position,
                  'Invalid character within String: '.concat(
                    printCharCode(code),
                    '.'
                  )
                );
              }

              ++position;

              if (code === 92) {
                // \
                value += body.slice(chunkStart, position - 1);
                code = body.charCodeAt(position);

                switch (code) {
                  case 34:
                    value += '"';
                    break;

                  case 47:
                    value += '/';
                    break;

                  case 92:
                    value += '\\';
                    break;

                  case 98:
                    value += '\b';
                    break;

                  case 102:
                    value += '\f';
                    break;

                  case 110:
                    value += '\n';
                    break;

                  case 114:
                    value += '\r';
                    break;

                  case 116:
                    value += '\t';
                    break;

                  case 117: {
                    // uXXXX
                    var charCode = uniCharCode(
                      body.charCodeAt(position + 1),
                      body.charCodeAt(position + 2),
                      body.charCodeAt(position + 3),
                      body.charCodeAt(position + 4)
                    );

                    if (charCode < 0) {
                      var invalidSequence = body.slice(
                        position + 1,
                        position + 5
                      );
                      throw (0, _syntaxError.syntaxError)(
                        source,
                        position,
                        'Invalid character escape sequence: \\u'.concat(
                          invalidSequence,
                          '.'
                        )
                      );
                    }

                    value += String.fromCharCode(charCode);
                    position += 4;
                    break;
                  }

                  default:
                    throw (0, _syntaxError.syntaxError)(
                      source,
                      position,
                      'Invalid character escape sequence: \\'.concat(
                        String.fromCharCode(code),
                        '.'
                      )
                    );
                }

                ++position;
                chunkStart = position;
              }
            }

            throw (0, _syntaxError.syntaxError)(
              source,
              position,
              'Unterminated string.'
            );
          }
          /**
           * Reads a block string token from the source file.
           *
           * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
           */

          function readBlockString(source, start, line, col, prev, lexer) {
            var body = source.body;
            var position = start + 3;
            var chunkStart = position;
            var code = 0;
            var rawValue = '';

            while (
              position < body.length &&
              !isNaN((code = body.charCodeAt(position)))
            ) {
              // Closing Triple-Quote (""")
              if (
                code === 34 &&
                body.charCodeAt(position + 1) === 34 &&
                body.charCodeAt(position + 2) === 34
              ) {
                rawValue += body.slice(chunkStart, position);
                return new _ast.Token(
                  _tokenKind.TokenKind.BLOCK_STRING,
                  start,
                  position + 3,
                  line,
                  col,
                  prev,
                  (0, _blockString.dedentBlockStringValue)(rawValue)
                );
              } // SourceCharacter

              if (
                code < 0x0020 &&
                code !== 0x0009 &&
                code !== 0x000a &&
                code !== 0x000d
              ) {
                throw (0, _syntaxError.syntaxError)(
                  source,
                  position,
                  'Invalid character within String: '.concat(
                    printCharCode(code),
                    '.'
                  )
                );
              }

              if (code === 10) {
                // new line
                ++position;
                ++lexer.line;
                lexer.lineStart = position;
              } else if (code === 13) {
                // carriage return
                if (body.charCodeAt(position + 1) === 10) {
                  position += 2;
                } else {
                  ++position;
                }

                ++lexer.line;
                lexer.lineStart = position;
              } else if (
                // Escape Triple-Quote (\""")
                code === 92 &&
                body.charCodeAt(position + 1) === 34 &&
                body.charCodeAt(position + 2) === 34 &&
                body.charCodeAt(position + 3) === 34
              ) {
                rawValue += body.slice(chunkStart, position) + '"""';
                position += 4;
                chunkStart = position;
              } else {
                ++position;
              }
            }

            throw (0, _syntaxError.syntaxError)(
              source,
              position,
              'Unterminated string.'
            );
          }
          /**
           * Converts four hexadecimal chars to the integer that the
           * string represents. For example, uniCharCode('0','0','0','f')
           * will return 15, and uniCharCode('0','0','f','f') returns 255.
           *
           * Returns a negative number on error, if a char was invalid.
           *
           * This is implemented by noting that char2hex() returns -1 on error,
           * which means the result of ORing the char2hex() will also be negative.
           */

          function uniCharCode(a, b, c, d) {
            return (
              (char2hex(a) << 12) |
              (char2hex(b) << 8) |
              (char2hex(c) << 4) |
              char2hex(d)
            );
          }
          /**
           * Converts a hex character to its integer value.
           * '0' becomes 0, '9' becomes 9
           * 'A' becomes 10, 'F' becomes 15
           * 'a' becomes 10, 'f' becomes 15
           *
           * Returns -1 on error.
           */

          function char2hex(a) {
            return a >= 48 && a <= 57
              ? a - 48 // 0-9
              : a >= 65 && a <= 70
              ? a - 55 // A-F
              : a >= 97 && a <= 102
              ? a - 87 // a-f
              : -1;
          }
          /**
           * Reads an alphanumeric + underscore name from the source.
           *
           * [_A-Za-z][_0-9A-Za-z]*
           */

          function readName(source, start, line, col, prev) {
            var body = source.body;
            var bodyLength = body.length;
            var position = start + 1;
            var code = 0;

            while (
              position !== bodyLength &&
              !isNaN((code = body.charCodeAt(position))) &&
              (code === 95 || // _
              (code >= 48 && code <= 57) || // 0-9
              (code >= 65 && code <= 90) || // A-Z
                (code >= 97 && code <= 122)) // a-z
            ) {
              ++position;
            }

            return new _ast.Token(
              _tokenKind.TokenKind.NAME,
              start,
              position,
              line,
              col,
              prev,
              body.slice(start, position)
            );
          } // _ A-Z a-z

          function isNameStart(code) {
            return (
              code === 95 ||
              (code >= 65 && code <= 90) ||
              (code >= 97 && code <= 122)
            );
          }

          /***/
        },

      /***/ './node_modules/graphql/language/location.js':
        /*!***************************************************!*\
  !*** ./node_modules/graphql/language/location.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.getLocation = getLocation;

          /**
           * Represents a location in a Source.
           */

          /**
           * Takes a Source and a UTF-8 character offset, and returns the corresponding
           * line and column as a SourceLocation.
           */
          function getLocation(source, position) {
            var lineRegexp = /\r\n|[\n\r]/g;
            var line = 1;
            var column = position + 1;
            var match;

            while (
              (match = lineRegexp.exec(source.body)) &&
              match.index < position
            ) {
              line += 1;
              column = position + 1 - (match.index + match[0].length);
            }

            return {
              line: line,
              column: column,
            };
          }

          /***/
        },

      /***/ './node_modules/graphql/language/parser.js':
        /*!*************************************************!*\
  !*** ./node_modules/graphql/language/parser.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.parse = parse;
          exports.parseValue = parseValue;
          exports.parseType = parseType;

          var _inspect = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/inspect */ './node_modules/graphql/jsutils/inspect.js'
            )
          );

          var _devAssert = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/devAssert */ './node_modules/graphql/jsutils/devAssert.js'
            )
          );

          var _syntaxError = __webpack_require__(
            /*! ../error/syntaxError */ './node_modules/graphql/error/syntaxError.js'
          );

          var _kinds = __webpack_require__(
            /*! ./kinds */ './node_modules/graphql/language/kinds.js'
          );

          var _ast = __webpack_require__(
            /*! ./ast */ './node_modules/graphql/language/ast.js'
          );

          var _source = __webpack_require__(
            /*! ./source */ './node_modules/graphql/language/source.js'
          );

          var _tokenKind = __webpack_require__(
            /*! ./tokenKind */ './node_modules/graphql/language/tokenKind.js'
          );

          var _directiveLocation = __webpack_require__(
            /*! ./directiveLocation */ './node_modules/graphql/language/directiveLocation.js'
          );

          var _lexer = __webpack_require__(
            /*! ./lexer */ './node_modules/graphql/language/lexer.js'
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Given a GraphQL source, parses it into a Document.
           * Throws GraphQLError if a syntax error is encountered.
           */
          function parse(source, options) {
            var parser = new Parser(source, options);
            return parser.parseDocument();
          }
          /**
           * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
           * that value.
           * Throws GraphQLError if a syntax error is encountered.
           *
           * This is useful within tools that operate upon GraphQL Values directly and
           * in isolation of complete GraphQL documents.
           *
           * Consider providing the results to the utility function: valueFromAST().
           */

          function parseValue(source, options) {
            var parser = new Parser(source, options);
            parser.expectToken(_tokenKind.TokenKind.SOF);
            var value = parser.parseValueLiteral(false);
            parser.expectToken(_tokenKind.TokenKind.EOF);
            return value;
          }
          /**
           * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
           * that type.
           * Throws GraphQLError if a syntax error is encountered.
           *
           * This is useful within tools that operate upon GraphQL Types directly and
           * in isolation of complete GraphQL documents.
           *
           * Consider providing the results to the utility function: typeFromAST().
           */

          function parseType(source, options) {
            var parser = new Parser(source, options);
            parser.expectToken(_tokenKind.TokenKind.SOF);
            var type = parser.parseTypeReference();
            parser.expectToken(_tokenKind.TokenKind.EOF);
            return type;
          }

          var Parser = /*#__PURE__*/ (function () {
            function Parser(source, options) {
              var sourceObj =
                typeof source === 'string'
                  ? new _source.Source(source)
                  : source;
              sourceObj instanceof _source.Source ||
                (0, _devAssert.default)(
                  0,
                  'Must provide Source. Received: '.concat(
                    (0, _inspect.default)(sourceObj),
                    '.'
                  )
                );
              this._lexer = new _lexer.Lexer(sourceObj);
              this._options = options;
            }
            /**
             * Converts a name lex token into a name parse node.
             */

            var _proto = Parser.prototype;

            _proto.parseName = function parseName() {
              var token = this.expectToken(_tokenKind.TokenKind.NAME);
              return {
                kind: _kinds.Kind.NAME,
                value: token.value,
                loc: this.loc(token),
              };
            }; // Implements the parsing rules in the Document section.

            /**
             * Document : Definition+
             */

            _proto.parseDocument = function parseDocument() {
              var start = this._lexer.token;
              return {
                kind: _kinds.Kind.DOCUMENT,
                definitions: this.many(
                  _tokenKind.TokenKind.SOF,
                  this.parseDefinition,
                  _tokenKind.TokenKind.EOF
                ),
                loc: this.loc(start),
              };
            };
            /**
             * Definition :
             *   - ExecutableDefinition
             *   - TypeSystemDefinition
             *   - TypeSystemExtension
             *
             * ExecutableDefinition :
             *   - OperationDefinition
             *   - FragmentDefinition
             */

            _proto.parseDefinition = function parseDefinition() {
              if (this.peek(_tokenKind.TokenKind.NAME)) {
                switch (this._lexer.token.value) {
                  case 'query':
                  case 'mutation':
                  case 'subscription':
                    return this.parseOperationDefinition();

                  case 'fragment':
                    return this.parseFragmentDefinition();

                  case 'schema':
                  case 'scalar':
                  case 'type':
                  case 'interface':
                  case 'union':
                  case 'enum':
                  case 'input':
                  case 'directive':
                    return this.parseTypeSystemDefinition();

                  case 'extend':
                    return this.parseTypeSystemExtension();
                }
              } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
                return this.parseOperationDefinition();
              } else if (this.peekDescription()) {
                return this.parseTypeSystemDefinition();
              }

              throw this.unexpected();
            }; // Implements the parsing rules in the Operations section.

            /**
             * OperationDefinition :
             *  - SelectionSet
             *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
             */

            _proto.parseOperationDefinition = function parseOperationDefinition() {
              var start = this._lexer.token;

              if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
                return {
                  kind: _kinds.Kind.OPERATION_DEFINITION,
                  operation: 'query',
                  name: undefined,
                  variableDefinitions: [],
                  directives: [],
                  selectionSet: this.parseSelectionSet(),
                  loc: this.loc(start),
                };
              }

              var operation = this.parseOperationType();
              var name;

              if (this.peek(_tokenKind.TokenKind.NAME)) {
                name = this.parseName();
              }

              return {
                kind: _kinds.Kind.OPERATION_DEFINITION,
                operation: operation,
                name: name,
                variableDefinitions: this.parseVariableDefinitions(),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(start),
              };
            };
            /**
             * OperationType : one of query mutation subscription
             */

            _proto.parseOperationType = function parseOperationType() {
              var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);

              switch (operationToken.value) {
                case 'query':
                  return 'query';

                case 'mutation':
                  return 'mutation';

                case 'subscription':
                  return 'subscription';
              }

              throw this.unexpected(operationToken);
            };
            /**
             * VariableDefinitions : ( VariableDefinition+ )
             */

            _proto.parseVariableDefinitions = function parseVariableDefinitions() {
              return this.optionalMany(
                _tokenKind.TokenKind.PAREN_L,
                this.parseVariableDefinition,
                _tokenKind.TokenKind.PAREN_R
              );
            };
            /**
             * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
             */

            _proto.parseVariableDefinition = function parseVariableDefinition() {
              var start = this._lexer.token;
              return {
                kind: _kinds.Kind.VARIABLE_DEFINITION,
                variable: this.parseVariable(),
                type:
                  (this.expectToken(_tokenKind.TokenKind.COLON),
                  this.parseTypeReference()),
                defaultValue: this.expectOptionalToken(
                  _tokenKind.TokenKind.EQUALS
                )
                  ? this.parseValueLiteral(true)
                  : undefined,
                directives: this.parseDirectives(true),
                loc: this.loc(start),
              };
            };
            /**
             * Variable : $ Name
             */

            _proto.parseVariable = function parseVariable() {
              var start = this._lexer.token;
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              return {
                kind: _kinds.Kind.VARIABLE,
                name: this.parseName(),
                loc: this.loc(start),
              };
            };
            /**
             * SelectionSet : { Selection+ }
             */

            _proto.parseSelectionSet = function parseSelectionSet() {
              var start = this._lexer.token;
              return {
                kind: _kinds.Kind.SELECTION_SET,
                selections: this.many(
                  _tokenKind.TokenKind.BRACE_L,
                  this.parseSelection,
                  _tokenKind.TokenKind.BRACE_R
                ),
                loc: this.loc(start),
              };
            };
            /**
             * Selection :
             *   - Field
             *   - FragmentSpread
             *   - InlineFragment
             */

            _proto.parseSelection = function parseSelection() {
              return this.peek(_tokenKind.TokenKind.SPREAD)
                ? this.parseFragment()
                : this.parseField();
            };
            /**
             * Field : Alias? Name Arguments? Directives? SelectionSet?
             *
             * Alias : Name :
             */

            _proto.parseField = function parseField() {
              var start = this._lexer.token;
              var nameOrAlias = this.parseName();
              var alias;
              var name;

              if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
                alias = nameOrAlias;
                name = this.parseName();
              } else {
                name = nameOrAlias;
              }

              return {
                kind: _kinds.Kind.FIELD,
                alias: alias,
                name: name,
                arguments: this.parseArguments(false),
                directives: this.parseDirectives(false),
                selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L)
                  ? this.parseSelectionSet()
                  : undefined,
                loc: this.loc(start),
              };
            };
            /**
             * Arguments[Const] : ( Argument[?Const]+ )
             */

            _proto.parseArguments = function parseArguments(isConst) {
              var item = isConst ? this.parseConstArgument : this.parseArgument;
              return this.optionalMany(
                _tokenKind.TokenKind.PAREN_L,
                item,
                _tokenKind.TokenKind.PAREN_R
              );
            };
            /**
             * Argument[Const] : Name : Value[?Const]
             */

            _proto.parseArgument = function parseArgument() {
              var start = this._lexer.token;
              var name = this.parseName();
              this.expectToken(_tokenKind.TokenKind.COLON);
              return {
                kind: _kinds.Kind.ARGUMENT,
                name: name,
                value: this.parseValueLiteral(false),
                loc: this.loc(start),
              };
            };

            _proto.parseConstArgument = function parseConstArgument() {
              var start = this._lexer.token;
              return {
                kind: _kinds.Kind.ARGUMENT,
                name: this.parseName(),
                value:
                  (this.expectToken(_tokenKind.TokenKind.COLON),
                  this.parseValueLiteral(true)),
                loc: this.loc(start),
              };
            }; // Implements the parsing rules in the Fragments section.

            /**
             * Corresponds to both FragmentSpread and InlineFragment in the spec.
             *
             * FragmentSpread : ... FragmentName Directives?
             *
             * InlineFragment : ... TypeCondition? Directives? SelectionSet
             */

            _proto.parseFragment = function parseFragment() {
              var start = this._lexer.token;
              this.expectToken(_tokenKind.TokenKind.SPREAD);
              var hasTypeCondition = this.expectOptionalKeyword('on');

              if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
                return {
                  kind: _kinds.Kind.FRAGMENT_SPREAD,
                  name: this.parseFragmentName(),
                  directives: this.parseDirectives(false),
                  loc: this.loc(start),
                };
              }

              return {
                kind: _kinds.Kind.INLINE_FRAGMENT,
                typeCondition: hasTypeCondition
                  ? this.parseNamedType()
                  : undefined,
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(start),
              };
            };
            /**
             * FragmentDefinition :
             *   - fragment FragmentName on TypeCondition Directives? SelectionSet
             *
             * TypeCondition : NamedType
             */

            _proto.parseFragmentDefinition = function parseFragmentDefinition() {
              var _this$_options;

              var start = this._lexer.token;
              this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
              // the grammar of FragmentDefinition:
              //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

              if (
                ((_this$_options = this._options) === null ||
                _this$_options === void 0
                  ? void 0
                  : _this$_options.experimentalFragmentVariables) === true
              ) {
                return {
                  kind: _kinds.Kind.FRAGMENT_DEFINITION,
                  name: this.parseFragmentName(),
                  variableDefinitions: this.parseVariableDefinitions(),
                  typeCondition:
                    (this.expectKeyword('on'), this.parseNamedType()),
                  directives: this.parseDirectives(false),
                  selectionSet: this.parseSelectionSet(),
                  loc: this.loc(start),
                };
              }

              return {
                kind: _kinds.Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                typeCondition:
                  (this.expectKeyword('on'), this.parseNamedType()),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(start),
              };
            };
            /**
             * FragmentName : Name but not `on`
             */

            _proto.parseFragmentName = function parseFragmentName() {
              if (this._lexer.token.value === 'on') {
                throw this.unexpected();
              }

              return this.parseName();
            }; // Implements the parsing rules in the Values section.

            /**
             * Value[Const] :
             *   - [~Const] Variable
             *   - IntValue
             *   - FloatValue
             *   - StringValue
             *   - BooleanValue
             *   - NullValue
             *   - EnumValue
             *   - ListValue[?Const]
             *   - ObjectValue[?Const]
             *
             * BooleanValue : one of `true` `false`
             *
             * NullValue : `null`
             *
             * EnumValue : Name but not `true`, `false` or `null`
             */

            _proto.parseValueLiteral = function parseValueLiteral(isConst) {
              var token = this._lexer.token;

              switch (token.kind) {
                case _tokenKind.TokenKind.BRACKET_L:
                  return this.parseList(isConst);

                case _tokenKind.TokenKind.BRACE_L:
                  return this.parseObject(isConst);

                case _tokenKind.TokenKind.INT:
                  this._lexer.advance();

                  return {
                    kind: _kinds.Kind.INT,
                    value: token.value,
                    loc: this.loc(token),
                  };

                case _tokenKind.TokenKind.FLOAT:
                  this._lexer.advance();

                  return {
                    kind: _kinds.Kind.FLOAT,
                    value: token.value,
                    loc: this.loc(token),
                  };

                case _tokenKind.TokenKind.STRING:
                case _tokenKind.TokenKind.BLOCK_STRING:
                  return this.parseStringLiteral();

                case _tokenKind.TokenKind.NAME:
                  this._lexer.advance();

                  switch (token.value) {
                    case 'true':
                      return {
                        kind: _kinds.Kind.BOOLEAN,
                        value: true,
                        loc: this.loc(token),
                      };

                    case 'false':
                      return {
                        kind: _kinds.Kind.BOOLEAN,
                        value: false,
                        loc: this.loc(token),
                      };

                    case 'null':
                      return {
                        kind: _kinds.Kind.NULL,
                        loc: this.loc(token),
                      };

                    default:
                      return {
                        kind: _kinds.Kind.ENUM,
                        value: token.value,
                        loc: this.loc(token),
                      };
                  }

                case _tokenKind.TokenKind.DOLLAR:
                  if (!isConst) {
                    return this.parseVariable();
                  }

                  break;
              }

              throw this.unexpected();
            };

            _proto.parseStringLiteral = function parseStringLiteral() {
              var token = this._lexer.token;

              this._lexer.advance();

              return {
                kind: _kinds.Kind.STRING,
                value: token.value,
                block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
                loc: this.loc(token),
              };
            };
            /**
             * ListValue[Const] :
             *   - [ ]
             *   - [ Value[?Const]+ ]
             */

            _proto.parseList = function parseList(isConst) {
              var _this = this;

              var start = this._lexer.token;

              var item = function item() {
                return _this.parseValueLiteral(isConst);
              };

              return {
                kind: _kinds.Kind.LIST,
                values: this.any(
                  _tokenKind.TokenKind.BRACKET_L,
                  item,
                  _tokenKind.TokenKind.BRACKET_R
                ),
                loc: this.loc(start),
              };
            };
            /**
             * ObjectValue[Const] :
             *   - { }
             *   - { ObjectField[?Const]+ }
             */

            _proto.parseObject = function parseObject(isConst) {
              var _this2 = this;

              var start = this._lexer.token;

              var item = function item() {
                return _this2.parseObjectField(isConst);
              };

              return {
                kind: _kinds.Kind.OBJECT,
                fields: this.any(
                  _tokenKind.TokenKind.BRACE_L,
                  item,
                  _tokenKind.TokenKind.BRACE_R
                ),
                loc: this.loc(start),
              };
            };
            /**
             * ObjectField[Const] : Name : Value[?Const]
             */

            _proto.parseObjectField = function parseObjectField(isConst) {
              var start = this._lexer.token;
              var name = this.parseName();
              this.expectToken(_tokenKind.TokenKind.COLON);
              return {
                kind: _kinds.Kind.OBJECT_FIELD,
                name: name,
                value: this.parseValueLiteral(isConst),
                loc: this.loc(start),
              };
            }; // Implements the parsing rules in the Directives section.

            /**
             * Directives[Const] : Directive[?Const]+
             */

            _proto.parseDirectives = function parseDirectives(isConst) {
              var directives = [];

              while (this.peek(_tokenKind.TokenKind.AT)) {
                directives.push(this.parseDirective(isConst));
              }

              return directives;
            };
            /**
             * Directive[Const] : @ Name Arguments[?Const]?
             */

            _proto.parseDirective = function parseDirective(isConst) {
              var start = this._lexer.token;
              this.expectToken(_tokenKind.TokenKind.AT);
              return {
                kind: _kinds.Kind.DIRECTIVE,
                name: this.parseName(),
                arguments: this.parseArguments(isConst),
                loc: this.loc(start),
              };
            }; // Implements the parsing rules in the Types section.

            /**
             * Type :
             *   - NamedType
             *   - ListType
             *   - NonNullType
             */

            _proto.parseTypeReference = function parseTypeReference() {
              var start = this._lexer.token;
              var type;

              if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
                type = this.parseTypeReference();
                this.expectToken(_tokenKind.TokenKind.BRACKET_R);
                type = {
                  kind: _kinds.Kind.LIST_TYPE,
                  type: type,
                  loc: this.loc(start),
                };
              } else {
                type = this.parseNamedType();
              }

              if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
                return {
                  kind: _kinds.Kind.NON_NULL_TYPE,
                  type: type,
                  loc: this.loc(start),
                };
              }

              return type;
            };
            /**
             * NamedType : Name
             */

            _proto.parseNamedType = function parseNamedType() {
              var start = this._lexer.token;
              return {
                kind: _kinds.Kind.NAMED_TYPE,
                name: this.parseName(),
                loc: this.loc(start),
              };
            }; // Implements the parsing rules in the Type Definition section.

            /**
             * TypeSystemDefinition :
             *   - SchemaDefinition
             *   - TypeDefinition
             *   - DirectiveDefinition
             *
             * TypeDefinition :
             *   - ScalarTypeDefinition
             *   - ObjectTypeDefinition
             *   - InterfaceTypeDefinition
             *   - UnionTypeDefinition
             *   - EnumTypeDefinition
             *   - InputObjectTypeDefinition
             */

            _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
              // Many definitions begin with a description and require a lookahead.
              var keywordToken = this.peekDescription()
                ? this._lexer.lookahead()
                : this._lexer.token;

              if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
                switch (keywordToken.value) {
                  case 'schema':
                    return this.parseSchemaDefinition();

                  case 'scalar':
                    return this.parseScalarTypeDefinition();

                  case 'type':
                    return this.parseObjectTypeDefinition();

                  case 'interface':
                    return this.parseInterfaceTypeDefinition();

                  case 'union':
                    return this.parseUnionTypeDefinition();

                  case 'enum':
                    return this.parseEnumTypeDefinition();

                  case 'input':
                    return this.parseInputObjectTypeDefinition();

                  case 'directive':
                    return this.parseDirectiveDefinition();
                }
              }

              throw this.unexpected(keywordToken);
            };

            _proto.peekDescription = function peekDescription() {
              return (
                this.peek(_tokenKind.TokenKind.STRING) ||
                this.peek(_tokenKind.TokenKind.BLOCK_STRING)
              );
            };
            /**
             * Description : StringValue
             */

            _proto.parseDescription = function parseDescription() {
              if (this.peekDescription()) {
                return this.parseStringLiteral();
              }
            };
            /**
             * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
             */

            _proto.parseSchemaDefinition = function parseSchemaDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('schema');
              var directives = this.parseDirectives(true);
              var operationTypes = this.many(
                _tokenKind.TokenKind.BRACE_L,
                this.parseOperationTypeDefinition,
                _tokenKind.TokenKind.BRACE_R
              );
              return {
                kind: _kinds.Kind.SCHEMA_DEFINITION,
                description: description,
                directives: directives,
                operationTypes: operationTypes,
                loc: this.loc(start),
              };
            };
            /**
             * OperationTypeDefinition : OperationType : NamedType
             */

            _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
              var start = this._lexer.token;
              var operation = this.parseOperationType();
              this.expectToken(_tokenKind.TokenKind.COLON);
              var type = this.parseNamedType();
              return {
                kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
                operation: operation,
                type: type,
                loc: this.loc(start),
              };
            };
            /**
             * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
             */

            _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('scalar');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              return {
                kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
                description: description,
                name: name,
                directives: directives,
                loc: this.loc(start),
              };
            };
            /**
             * ObjectTypeDefinition :
             *   Description?
             *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
             */

            _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('type');
              var name = this.parseName();
              var interfaces = this.parseImplementsInterfaces();
              var directives = this.parseDirectives(true);
              var fields = this.parseFieldsDefinition();
              return {
                kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
                description: description,
                name: name,
                interfaces: interfaces,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * ImplementsInterfaces :
             *   - implements `&`? NamedType
             *   - ImplementsInterfaces & NamedType
             */

            _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
              var types = [];

              if (this.expectOptionalKeyword('implements')) {
                // Optional leading ampersand
                this.expectOptionalToken(_tokenKind.TokenKind.AMP);

                do {
                  var _this$_options2;

                  types.push(this.parseNamedType());
                } while (
                  this.expectOptionalToken(_tokenKind.TokenKind.AMP) || // Legacy support for the SDL?
                  (((_this$_options2 = this._options) === null ||
                  _this$_options2 === void 0
                    ? void 0
                    : _this$_options2.allowLegacySDLImplementsInterfaces) ===
                    true &&
                    this.peek(_tokenKind.TokenKind.NAME))
                );
              }

              return types;
            };
            /**
             * FieldsDefinition : { FieldDefinition+ }
             */

            _proto.parseFieldsDefinition = function parseFieldsDefinition() {
              var _this$_options3;

              // Legacy support for the SDL?
              if (
                ((_this$_options3 = this._options) === null ||
                _this$_options3 === void 0
                  ? void 0
                  : _this$_options3.allowLegacySDLEmptyFields) === true &&
                this.peek(_tokenKind.TokenKind.BRACE_L) &&
                this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R
              ) {
                this._lexer.advance();

                this._lexer.advance();

                return [];
              }

              return this.optionalMany(
                _tokenKind.TokenKind.BRACE_L,
                this.parseFieldDefinition,
                _tokenKind.TokenKind.BRACE_R
              );
            };
            /**
             * FieldDefinition :
             *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
             */

            _proto.parseFieldDefinition = function parseFieldDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              var name = this.parseName();
              var args = this.parseArgumentDefs();
              this.expectToken(_tokenKind.TokenKind.COLON);
              var type = this.parseTypeReference();
              var directives = this.parseDirectives(true);
              return {
                kind: _kinds.Kind.FIELD_DEFINITION,
                description: description,
                name: name,
                arguments: args,
                type: type,
                directives: directives,
                loc: this.loc(start),
              };
            };
            /**
             * ArgumentsDefinition : ( InputValueDefinition+ )
             */

            _proto.parseArgumentDefs = function parseArgumentDefs() {
              return this.optionalMany(
                _tokenKind.TokenKind.PAREN_L,
                this.parseInputValueDef,
                _tokenKind.TokenKind.PAREN_R
              );
            };
            /**
             * InputValueDefinition :
             *   - Description? Name : Type DefaultValue? Directives[Const]?
             */

            _proto.parseInputValueDef = function parseInputValueDef() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              var name = this.parseName();
              this.expectToken(_tokenKind.TokenKind.COLON);
              var type = this.parseTypeReference();
              var defaultValue;

              if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
                defaultValue = this.parseValueLiteral(true);
              }

              var directives = this.parseDirectives(true);
              return {
                kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
                description: description,
                name: name,
                type: type,
                defaultValue: defaultValue,
                directives: directives,
                loc: this.loc(start),
              };
            };
            /**
             * InterfaceTypeDefinition :
             *   - Description? interface Name Directives[Const]? FieldsDefinition?
             */

            _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('interface');
              var name = this.parseName();
              var interfaces = this.parseImplementsInterfaces();
              var directives = this.parseDirectives(true);
              var fields = this.parseFieldsDefinition();
              return {
                kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
                description: description,
                name: name,
                interfaces: interfaces,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * UnionTypeDefinition :
             *   - Description? union Name Directives[Const]? UnionMemberTypes?
             */

            _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('union');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var types = this.parseUnionMemberTypes();
              return {
                kind: _kinds.Kind.UNION_TYPE_DEFINITION,
                description: description,
                name: name,
                directives: directives,
                types: types,
                loc: this.loc(start),
              };
            };
            /**
             * UnionMemberTypes :
             *   - = `|`? NamedType
             *   - UnionMemberTypes | NamedType
             */

            _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
              var types = [];

              if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
                // Optional leading pipe
                this.expectOptionalToken(_tokenKind.TokenKind.PIPE);

                do {
                  types.push(this.parseNamedType());
                } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));
              }

              return types;
            };
            /**
             * EnumTypeDefinition :
             *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
             */

            _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('enum');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var values = this.parseEnumValuesDefinition();
              return {
                kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
                description: description,
                name: name,
                directives: directives,
                values: values,
                loc: this.loc(start),
              };
            };
            /**
             * EnumValuesDefinition : { EnumValueDefinition+ }
             */

            _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
              return this.optionalMany(
                _tokenKind.TokenKind.BRACE_L,
                this.parseEnumValueDefinition,
                _tokenKind.TokenKind.BRACE_R
              );
            };
            /**
             * EnumValueDefinition : Description? EnumValue Directives[Const]?
             *
             * EnumValue : Name
             */

            _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              return {
                kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
                description: description,
                name: name,
                directives: directives,
                loc: this.loc(start),
              };
            };
            /**
             * InputObjectTypeDefinition :
             *   - Description? input Name Directives[Const]? InputFieldsDefinition?
             */

            _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('input');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var fields = this.parseInputFieldsDefinition();
              return {
                kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
                description: description,
                name: name,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * InputFieldsDefinition : { InputValueDefinition+ }
             */

            _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
              return this.optionalMany(
                _tokenKind.TokenKind.BRACE_L,
                this.parseInputValueDef,
                _tokenKind.TokenKind.BRACE_R
              );
            };
            /**
             * TypeSystemExtension :
             *   - SchemaExtension
             *   - TypeExtension
             *
             * TypeExtension :
             *   - ScalarTypeExtension
             *   - ObjectTypeExtension
             *   - InterfaceTypeExtension
             *   - UnionTypeExtension
             *   - EnumTypeExtension
             *   - InputObjectTypeDefinition
             */

            _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
              var keywordToken = this._lexer.lookahead();

              if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
                switch (keywordToken.value) {
                  case 'schema':
                    return this.parseSchemaExtension();

                  case 'scalar':
                    return this.parseScalarTypeExtension();

                  case 'type':
                    return this.parseObjectTypeExtension();

                  case 'interface':
                    return this.parseInterfaceTypeExtension();

                  case 'union':
                    return this.parseUnionTypeExtension();

                  case 'enum':
                    return this.parseEnumTypeExtension();

                  case 'input':
                    return this.parseInputObjectTypeExtension();
                }
              }

              throw this.unexpected(keywordToken);
            };
            /**
             * SchemaExtension :
             *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
             *  - extend schema Directives[Const]
             */

            _proto.parseSchemaExtension = function parseSchemaExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('schema');
              var directives = this.parseDirectives(true);
              var operationTypes = this.optionalMany(
                _tokenKind.TokenKind.BRACE_L,
                this.parseOperationTypeDefinition,
                _tokenKind.TokenKind.BRACE_R
              );

              if (directives.length === 0 && operationTypes.length === 0) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.SCHEMA_EXTENSION,
                directives: directives,
                operationTypes: operationTypes,
                loc: this.loc(start),
              };
            };
            /**
             * ScalarTypeExtension :
             *   - extend scalar Name Directives[Const]
             */

            _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('scalar');
              var name = this.parseName();
              var directives = this.parseDirectives(true);

              if (directives.length === 0) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
                name: name,
                directives: directives,
                loc: this.loc(start),
              };
            };
            /**
             * ObjectTypeExtension :
             *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
             *  - extend type Name ImplementsInterfaces? Directives[Const]
             *  - extend type Name ImplementsInterfaces
             */

            _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('type');
              var name = this.parseName();
              var interfaces = this.parseImplementsInterfaces();
              var directives = this.parseDirectives(true);
              var fields = this.parseFieldsDefinition();

              if (
                interfaces.length === 0 &&
                directives.length === 0 &&
                fields.length === 0
              ) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
                name: name,
                interfaces: interfaces,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * InterfaceTypeExtension :
             *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
             *  - extend interface Name ImplementsInterfaces? Directives[Const]
             *  - extend interface Name ImplementsInterfaces
             */

            _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('interface');
              var name = this.parseName();
              var interfaces = this.parseImplementsInterfaces();
              var directives = this.parseDirectives(true);
              var fields = this.parseFieldsDefinition();

              if (
                interfaces.length === 0 &&
                directives.length === 0 &&
                fields.length === 0
              ) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
                name: name,
                interfaces: interfaces,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * UnionTypeExtension :
             *   - extend union Name Directives[Const]? UnionMemberTypes
             *   - extend union Name Directives[Const]
             */

            _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('union');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var types = this.parseUnionMemberTypes();

              if (directives.length === 0 && types.length === 0) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.UNION_TYPE_EXTENSION,
                name: name,
                directives: directives,
                types: types,
                loc: this.loc(start),
              };
            };
            /**
             * EnumTypeExtension :
             *   - extend enum Name Directives[Const]? EnumValuesDefinition
             *   - extend enum Name Directives[Const]
             */

            _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('enum');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var values = this.parseEnumValuesDefinition();

              if (directives.length === 0 && values.length === 0) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
                name: name,
                directives: directives,
                values: values,
                loc: this.loc(start),
              };
            };
            /**
             * InputObjectTypeExtension :
             *   - extend input Name Directives[Const]? InputFieldsDefinition
             *   - extend input Name Directives[Const]
             */

            _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
              var start = this._lexer.token;
              this.expectKeyword('extend');
              this.expectKeyword('input');
              var name = this.parseName();
              var directives = this.parseDirectives(true);
              var fields = this.parseInputFieldsDefinition();

              if (directives.length === 0 && fields.length === 0) {
                throw this.unexpected();
              }

              return {
                kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
                name: name,
                directives: directives,
                fields: fields,
                loc: this.loc(start),
              };
            };
            /**
             * DirectiveDefinition :
             *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
             */

            _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
              var start = this._lexer.token;
              var description = this.parseDescription();
              this.expectKeyword('directive');
              this.expectToken(_tokenKind.TokenKind.AT);
              var name = this.parseName();
              var args = this.parseArgumentDefs();
              var repeatable = this.expectOptionalKeyword('repeatable');
              this.expectKeyword('on');
              var locations = this.parseDirectiveLocations();
              return {
                kind: _kinds.Kind.DIRECTIVE_DEFINITION,
                description: description,
                name: name,
                arguments: args,
                repeatable: repeatable,
                locations: locations,
                loc: this.loc(start),
              };
            };
            /**
             * DirectiveLocations :
             *   - `|`? DirectiveLocation
             *   - DirectiveLocations | DirectiveLocation
             */

            _proto.parseDirectiveLocations = function parseDirectiveLocations() {
              // Optional leading pipe
              this.expectOptionalToken(_tokenKind.TokenKind.PIPE);
              var locations = [];

              do {
                locations.push(this.parseDirectiveLocation());
              } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));

              return locations;
            };
            /*
             * DirectiveLocation :
             *   - ExecutableDirectiveLocation
             *   - TypeSystemDirectiveLocation
             *
             * ExecutableDirectiveLocation : one of
             *   `QUERY`
             *   `MUTATION`
             *   `SUBSCRIPTION`
             *   `FIELD`
             *   `FRAGMENT_DEFINITION`
             *   `FRAGMENT_SPREAD`
             *   `INLINE_FRAGMENT`
             *
             * TypeSystemDirectiveLocation : one of
             *   `SCHEMA`
             *   `SCALAR`
             *   `OBJECT`
             *   `FIELD_DEFINITION`
             *   `ARGUMENT_DEFINITION`
             *   `INTERFACE`
             *   `UNION`
             *   `ENUM`
             *   `ENUM_VALUE`
             *   `INPUT_OBJECT`
             *   `INPUT_FIELD_DEFINITION`
             */

            _proto.parseDirectiveLocation = function parseDirectiveLocation() {
              var start = this._lexer.token;
              var name = this.parseName();

              if (
                _directiveLocation.DirectiveLocation[name.value] !== undefined
              ) {
                return name;
              }

              throw this.unexpected(start);
            }; // Core parsing utility functions

            /**
             * Returns a location object, used to identify the place in
             * the source that created a given parsed object.
             */

            _proto.loc = function loc(startToken) {
              var _this$_options4;

              if (
                ((_this$_options4 = this._options) === null ||
                _this$_options4 === void 0
                  ? void 0
                  : _this$_options4.noLocation) !== true
              ) {
                return new _ast.Location(
                  startToken,
                  this._lexer.lastToken,
                  this._lexer.source
                );
              }
            };
            /**
             * Determines if the next token is of a given kind
             */

            _proto.peek = function peek(kind) {
              return this._lexer.token.kind === kind;
            };
            /**
             * If the next token is of the given kind, return that token after advancing
             * the lexer. Otherwise, do not change the parser state and throw an error.
             */

            _proto.expectToken = function expectToken(kind) {
              var token = this._lexer.token;

              if (token.kind === kind) {
                this._lexer.advance();

                return token;
              }

              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token.start,
                'Expected '
                  .concat(getTokenKindDesc(kind), ', found ')
                  .concat(getTokenDesc(token), '.')
              );
            };
            /**
             * If the next token is of the given kind, return that token after advancing
             * the lexer. Otherwise, do not change the parser state and return undefined.
             */

            _proto.expectOptionalToken = function expectOptionalToken(kind) {
              var token = this._lexer.token;

              if (token.kind === kind) {
                this._lexer.advance();

                return token;
              }

              return undefined;
            };
            /**
             * If the next token is a given keyword, advance the lexer.
             * Otherwise, do not change the parser state and throw an error.
             */

            _proto.expectKeyword = function expectKeyword(value) {
              var token = this._lexer.token;

              if (
                token.kind === _tokenKind.TokenKind.NAME &&
                token.value === value
              ) {
                this._lexer.advance();
              } else {
                throw (0, _syntaxError.syntaxError)(
                  this._lexer.source,
                  token.start,
                  'Expected "'
                    .concat(value, '", found ')
                    .concat(getTokenDesc(token), '.')
                );
              }
            };
            /**
             * If the next token is a given keyword, return "true" after advancing
             * the lexer. Otherwise, do not change the parser state and return "false".
             */

            _proto.expectOptionalKeyword = function expectOptionalKeyword(
              value
            ) {
              var token = this._lexer.token;

              if (
                token.kind === _tokenKind.TokenKind.NAME &&
                token.value === value
              ) {
                this._lexer.advance();

                return true;
              }

              return false;
            };
            /**
             * Helper function for creating an error when an unexpected lexed token
             * is encountered.
             */

            _proto.unexpected = function unexpected(atToken) {
              var token =
                atToken !== null && atToken !== void 0
                  ? atToken
                  : this._lexer.token;
              return (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token.start,
                'Unexpected '.concat(getTokenDesc(token), '.')
              );
            };
            /**
             * Returns a possibly empty list of parse nodes, determined by
             * the parseFn. This list begins with a lex token of openKind
             * and ends with a lex token of closeKind. Advances the parser
             * to the next lex token after the closing token.
             */

            _proto.any = function any(openKind, parseFn, closeKind) {
              this.expectToken(openKind);
              var nodes = [];

              while (!this.expectOptionalToken(closeKind)) {
                nodes.push(parseFn.call(this));
              }

              return nodes;
            };
            /**
             * Returns a list of parse nodes, determined by the parseFn.
             * It can be empty only if open token is missing otherwise it will always
             * return non-empty list that begins with a lex token of openKind and ends
             * with a lex token of closeKind. Advances the parser to the next lex token
             * after the closing token.
             */

            _proto.optionalMany = function optionalMany(
              openKind,
              parseFn,
              closeKind
            ) {
              if (this.expectOptionalToken(openKind)) {
                var nodes = [];

                do {
                  nodes.push(parseFn.call(this));
                } while (!this.expectOptionalToken(closeKind));

                return nodes;
              }

              return [];
            };
            /**
             * Returns a non-empty list of parse nodes, determined by
             * the parseFn. This list begins with a lex token of openKind
             * and ends with a lex token of closeKind. Advances the parser
             * to the next lex token after the closing token.
             */

            _proto.many = function many(openKind, parseFn, closeKind) {
              this.expectToken(openKind);
              var nodes = [];

              do {
                nodes.push(parseFn.call(this));
              } while (!this.expectOptionalToken(closeKind));

              return nodes;
            };

            return Parser;
          })();
          /**
           * A helper function to describe a token as a string for debugging
           */

          function getTokenDesc(token) {
            var value = token.value;
            return (
              getTokenKindDesc(token.kind) +
              (value != null ? ' "'.concat(value, '"') : '')
            );
          }
          /**
           * A helper function to describe a token kind as a string for debugging
           */

          function getTokenKindDesc(kind) {
            return (0, _lexer.isPunctuatorTokenKind)(kind)
              ? '"'.concat(kind, '"')
              : kind;
          }

          /***/
        },

      /***/ './node_modules/graphql/language/printLocation.js':
        /*!********************************************************!*\
  !*** ./node_modules/graphql/language/printLocation.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.printLocation = printLocation;
          exports.printSourceLocation = printSourceLocation;

          var _location = __webpack_require__(
            /*! ./location */ './node_modules/graphql/language/location.js'
          );

          /**
           * Render a helpful description of the location in the GraphQL Source document.
           */
          function printLocation(location) {
            return printSourceLocation(
              location.source,
              (0, _location.getLocation)(location.source, location.start)
            );
          }
          /**
           * Render a helpful description of the location in the GraphQL Source document.
           */

          function printSourceLocation(source, sourceLocation) {
            var firstLineColumnOffset = source.locationOffset.column - 1;
            var body = whitespace(firstLineColumnOffset) + source.body;
            var lineIndex = sourceLocation.line - 1;
            var lineOffset = source.locationOffset.line - 1;
            var lineNum = sourceLocation.line + lineOffset;
            var columnOffset =
              sourceLocation.line === 1 ? firstLineColumnOffset : 0;
            var columnNum = sourceLocation.column + columnOffset;
            var locationStr = ''
              .concat(source.name, ':')
              .concat(lineNum, ':')
              .concat(columnNum, '\n');
            var lines = body.split(/\r\n|[\n\r]/g);
            var locationLine = lines[lineIndex]; // Special case for minified documents

            if (locationLine.length > 120) {
              var subLineIndex = Math.floor(columnNum / 80);
              var subLineColumnNum = columnNum % 80;
              var subLines = [];

              for (var i = 0; i < locationLine.length; i += 80) {
                subLines.push(locationLine.slice(i, i + 80));
              }

              return (
                locationStr +
                printPrefixedLines(
                  [[''.concat(lineNum), subLines[0]]].concat(
                    subLines.slice(1, subLineIndex + 1).map(function (subLine) {
                      return ['', subLine];
                    }),
                    [
                      [' ', whitespace(subLineColumnNum - 1) + '^'],
                      ['', subLines[subLineIndex + 1]],
                    ]
                  )
                )
              );
            }

            return (
              locationStr +
              printPrefixedLines([
                // Lines specified like this: ["prefix", "string"],
                [''.concat(lineNum - 1), lines[lineIndex - 1]],
                [''.concat(lineNum), locationLine],
                ['', whitespace(columnNum - 1) + '^'],
                [''.concat(lineNum + 1), lines[lineIndex + 1]],
              ])
            );
          }

          function printPrefixedLines(lines) {
            var existingLines = lines.filter(function (_ref) {
              var _ = _ref[0],
                line = _ref[1];
              return line !== undefined;
            });
            var padLen = Math.max.apply(
              Math,
              existingLines.map(function (_ref2) {
                var prefix = _ref2[0];
                return prefix.length;
              })
            );
            return existingLines
              .map(function (_ref3) {
                var prefix = _ref3[0],
                  line = _ref3[1];
                return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');
              })
              .join('\n');
          }

          function whitespace(len) {
            return Array(len + 1).join(' ');
          }

          function leftPad(len, str) {
            return whitespace(len - str.length) + str;
          }

          /***/
        },

      /***/ './node_modules/graphql/language/printer.js':
        /*!**************************************************!*\
  !*** ./node_modules/graphql/language/printer.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.print = print;

          var _visitor = __webpack_require__(
            /*! ./visitor */ './node_modules/graphql/language/visitor.js'
          );

          var _blockString = __webpack_require__(
            /*! ./blockString */ './node_modules/graphql/language/blockString.js'
          );

          /**
           * Converts an AST into a string, using one set of reasonable
           * formatting rules.
           */
          function print(ast) {
            return (0, _visitor.visit)(ast, {
              leave: printDocASTReducer,
            });
          } // TODO: provide better type coverage in future

          var printDocASTReducer = {
            Name: function Name(node) {
              return node.value;
            },
            Variable: function Variable(node) {
              return '$' + node.name;
            },
            // Document
            Document: function Document(node) {
              return join(node.definitions, '\n\n') + '\n';
            },
            OperationDefinition: function OperationDefinition(node) {
              var op = node.operation;
              var name = node.name;
              var varDefs = wrap(
                '(',
                join(node.variableDefinitions, ', '),
                ')'
              );
              var directives = join(node.directives, ' ');
              var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
              // the query short form.

              return !name && !directives && !varDefs && op === 'query'
                ? selectionSet
                : join(
                    [op, join([name, varDefs]), directives, selectionSet],
                    ' '
                  );
            },
            VariableDefinition: function VariableDefinition(_ref) {
              var variable = _ref.variable,
                type = _ref.type,
                defaultValue = _ref.defaultValue,
                directives = _ref.directives;
              return (
                variable +
                ': ' +
                type +
                wrap(' = ', defaultValue) +
                wrap(' ', join(directives, ' '))
              );
            },
            SelectionSet: function SelectionSet(_ref2) {
              var selections = _ref2.selections;
              return block(selections);
            },
            Field: function Field(_ref3) {
              var alias = _ref3.alias,
                name = _ref3.name,
                args = _ref3.arguments,
                directives = _ref3.directives,
                selectionSet = _ref3.selectionSet;
              return join(
                [
                  wrap('', alias, ': ') +
                    name +
                    wrap('(', join(args, ', '), ')'),
                  join(directives, ' '),
                  selectionSet,
                ],
                ' '
              );
            },
            Argument: function Argument(_ref4) {
              var name = _ref4.name,
                value = _ref4.value;
              return name + ': ' + value;
            },
            // Fragments
            FragmentSpread: function FragmentSpread(_ref5) {
              var name = _ref5.name,
                directives = _ref5.directives;
              return '...' + name + wrap(' ', join(directives, ' '));
            },
            InlineFragment: function InlineFragment(_ref6) {
              var typeCondition = _ref6.typeCondition,
                directives = _ref6.directives,
                selectionSet = _ref6.selectionSet;
              return join(
                [
                  '...',
                  wrap('on ', typeCondition),
                  join(directives, ' '),
                  selectionSet,
                ],
                ' '
              );
            },
            FragmentDefinition: function FragmentDefinition(_ref7) {
              var name = _ref7.name,
                typeCondition = _ref7.typeCondition,
                variableDefinitions = _ref7.variableDefinitions,
                directives = _ref7.directives,
                selectionSet = _ref7.selectionSet;
              return (
                // Note: fragment variable definitions are experimental and may be changed
                // or removed in the future.
                'fragment '
                  .concat(name)
                  .concat(
                    wrap('(', join(variableDefinitions, ', '), ')'),
                    ' '
                  ) +
                'on '
                  .concat(typeCondition, ' ')
                  .concat(wrap('', join(directives, ' '), ' ')) +
                selectionSet
              );
            },
            // Value
            IntValue: function IntValue(_ref8) {
              var value = _ref8.value;
              return value;
            },
            FloatValue: function FloatValue(_ref9) {
              var value = _ref9.value;
              return value;
            },
            StringValue: function StringValue(_ref10, key) {
              var value = _ref10.value,
                isBlockString = _ref10.block;
              return isBlockString
                ? (0, _blockString.printBlockString)(
                    value,
                    key === 'description' ? '' : '  '
                  )
                : JSON.stringify(value);
            },
            BooleanValue: function BooleanValue(_ref11) {
              var value = _ref11.value;
              return value ? 'true' : 'false';
            },
            NullValue: function NullValue() {
              return 'null';
            },
            EnumValue: function EnumValue(_ref12) {
              var value = _ref12.value;
              return value;
            },
            ListValue: function ListValue(_ref13) {
              var values = _ref13.values;
              return '[' + join(values, ', ') + ']';
            },
            ObjectValue: function ObjectValue(_ref14) {
              var fields = _ref14.fields;
              return '{' + join(fields, ', ') + '}';
            },
            ObjectField: function ObjectField(_ref15) {
              var name = _ref15.name,
                value = _ref15.value;
              return name + ': ' + value;
            },
            // Directive
            Directive: function Directive(_ref16) {
              var name = _ref16.name,
                args = _ref16.arguments;
              return '@' + name + wrap('(', join(args, ', '), ')');
            },
            // Type
            NamedType: function NamedType(_ref17) {
              var name = _ref17.name;
              return name;
            },
            ListType: function ListType(_ref18) {
              var type = _ref18.type;
              return '[' + type + ']';
            },
            NonNullType: function NonNullType(_ref19) {
              var type = _ref19.type;
              return type + '!';
            },
            // Type System Definitions
            SchemaDefinition: addDescription(function (_ref20) {
              var directives = _ref20.directives,
                operationTypes = _ref20.operationTypes;
              return join(
                ['schema', join(directives, ' '), block(operationTypes)],
                ' '
              );
            }),
            OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
              var operation = _ref21.operation,
                type = _ref21.type;
              return operation + ': ' + type;
            },
            ScalarTypeDefinition: addDescription(function (_ref22) {
              var name = _ref22.name,
                directives = _ref22.directives;
              return join(['scalar', name, join(directives, ' ')], ' ');
            }),
            ObjectTypeDefinition: addDescription(function (_ref23) {
              var name = _ref23.name,
                interfaces = _ref23.interfaces,
                directives = _ref23.directives,
                fields = _ref23.fields;
              return join(
                [
                  'type',
                  name,
                  wrap('implements ', join(interfaces, ' & ')),
                  join(directives, ' '),
                  block(fields),
                ],
                ' '
              );
            }),
            FieldDefinition: addDescription(function (_ref24) {
              var name = _ref24.name,
                args = _ref24.arguments,
                type = _ref24.type,
                directives = _ref24.directives;
              return (
                name +
                (hasMultilineItems(args)
                  ? wrap('(\n', indent(join(args, '\n')), '\n)')
                  : wrap('(', join(args, ', '), ')')) +
                ': ' +
                type +
                wrap(' ', join(directives, ' '))
              );
            }),
            InputValueDefinition: addDescription(function (_ref25) {
              var name = _ref25.name,
                type = _ref25.type,
                defaultValue = _ref25.defaultValue,
                directives = _ref25.directives;
              return join(
                [
                  name + ': ' + type,
                  wrap('= ', defaultValue),
                  join(directives, ' '),
                ],
                ' '
              );
            }),
            InterfaceTypeDefinition: addDescription(function (_ref26) {
              var name = _ref26.name,
                interfaces = _ref26.interfaces,
                directives = _ref26.directives,
                fields = _ref26.fields;
              return join(
                [
                  'interface',
                  name,
                  wrap('implements ', join(interfaces, ' & ')),
                  join(directives, ' '),
                  block(fields),
                ],
                ' '
              );
            }),
            UnionTypeDefinition: addDescription(function (_ref27) {
              var name = _ref27.name,
                directives = _ref27.directives,
                types = _ref27.types;
              return join(
                [
                  'union',
                  name,
                  join(directives, ' '),
                  types && types.length !== 0 ? '= ' + join(types, ' | ') : '',
                ],
                ' '
              );
            }),
            EnumTypeDefinition: addDescription(function (_ref28) {
              var name = _ref28.name,
                directives = _ref28.directives,
                values = _ref28.values;
              return join(
                ['enum', name, join(directives, ' '), block(values)],
                ' '
              );
            }),
            EnumValueDefinition: addDescription(function (_ref29) {
              var name = _ref29.name,
                directives = _ref29.directives;
              return join([name, join(directives, ' ')], ' ');
            }),
            InputObjectTypeDefinition: addDescription(function (_ref30) {
              var name = _ref30.name,
                directives = _ref30.directives,
                fields = _ref30.fields;
              return join(
                ['input', name, join(directives, ' '), block(fields)],
                ' '
              );
            }),
            DirectiveDefinition: addDescription(function (_ref31) {
              var name = _ref31.name,
                args = _ref31.arguments,
                repeatable = _ref31.repeatable,
                locations = _ref31.locations;
              return (
                'directive @' +
                name +
                (hasMultilineItems(args)
                  ? wrap('(\n', indent(join(args, '\n')), '\n)')
                  : wrap('(', join(args, ', '), ')')) +
                (repeatable ? ' repeatable' : '') +
                ' on ' +
                join(locations, ' | ')
              );
            }),
            SchemaExtension: function SchemaExtension(_ref32) {
              var directives = _ref32.directives,
                operationTypes = _ref32.operationTypes;
              return join(
                ['extend schema', join(directives, ' '), block(operationTypes)],
                ' '
              );
            },
            ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
              var name = _ref33.name,
                directives = _ref33.directives;
              return join(['extend scalar', name, join(directives, ' ')], ' ');
            },
            ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
              var name = _ref34.name,
                interfaces = _ref34.interfaces,
                directives = _ref34.directives,
                fields = _ref34.fields;
              return join(
                [
                  'extend type',
                  name,
                  wrap('implements ', join(interfaces, ' & ')),
                  join(directives, ' '),
                  block(fields),
                ],
                ' '
              );
            },
            InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
              var name = _ref35.name,
                interfaces = _ref35.interfaces,
                directives = _ref35.directives,
                fields = _ref35.fields;
              return join(
                [
                  'extend interface',
                  name,
                  wrap('implements ', join(interfaces, ' & ')),
                  join(directives, ' '),
                  block(fields),
                ],
                ' '
              );
            },
            UnionTypeExtension: function UnionTypeExtension(_ref36) {
              var name = _ref36.name,
                directives = _ref36.directives,
                types = _ref36.types;
              return join(
                [
                  'extend union',
                  name,
                  join(directives, ' '),
                  types && types.length !== 0 ? '= ' + join(types, ' | ') : '',
                ],
                ' '
              );
            },
            EnumTypeExtension: function EnumTypeExtension(_ref37) {
              var name = _ref37.name,
                directives = _ref37.directives,
                values = _ref37.values;
              return join(
                ['extend enum', name, join(directives, ' '), block(values)],
                ' '
              );
            },
            InputObjectTypeExtension: function InputObjectTypeExtension(
              _ref38
            ) {
              var name = _ref38.name,
                directives = _ref38.directives,
                fields = _ref38.fields;
              return join(
                ['extend input', name, join(directives, ' '), block(fields)],
                ' '
              );
            },
          };

          function addDescription(cb) {
            return function (node) {
              return join([node.description, cb(node)], '\n');
            };
          }
          /**
           * Given maybeArray, print an empty string if it is null or empty, otherwise
           * print all items together separated by separator if provided
           */

          function join(maybeArray) {
            var _maybeArray$filter$jo;

            var separator =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : '';
            return (_maybeArray$filter$jo =
              maybeArray === null || maybeArray === void 0
                ? void 0
                : maybeArray
                    .filter(function (x) {
                      return x;
                    })
                    .join(separator)) !== null &&
              _maybeArray$filter$jo !== void 0
              ? _maybeArray$filter$jo
              : '';
          }
          /**
           * Given array, print each item on its own line, wrapped in an
           * indented "{ }" block.
           */

          function block(array) {
            return array && array.length !== 0
              ? '{\n' + indent(join(array, '\n')) + '\n}'
              : '';
          }
          /**
           * If maybeString is not null or empty, then wrap with start and end, otherwise
           * print an empty string.
           */

          function wrap(start, maybeString) {
            var end =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : '';
            return maybeString ? start + maybeString + end : '';
          }

          function indent(maybeString) {
            return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
          }

          function isMultiline(string) {
            return string.indexOf('\n') !== -1;
          }

          function hasMultilineItems(maybeArray) {
            return maybeArray && maybeArray.some(isMultiline);
          }

          /***/
        },

      /***/ './node_modules/graphql/language/source.js':
        /*!*************************************************!*\
  !*** ./node_modules/graphql/language/source.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.Source = void 0;

          var _symbols = __webpack_require__(
            /*! ../polyfills/symbols */ './node_modules/graphql/polyfills/symbols.js'
          );

          var _devAssert = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/devAssert */ './node_modules/graphql/jsutils/devAssert.js'
            )
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          /**
           * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are
           * optional, but they are useful for clients who store GraphQL documents in source files.
           * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might
           * be useful for `name` to be `"Foo.graphql"` and location to be `{ line: 40, column: 1 }`.
           * The `line` and `column` properties in `locationOffset` are 1-indexed.
           */
          var Source = /*#__PURE__*/ (function () {
            function Source(body) {
              var name =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : 'GraphQL request';
              var locationOffset =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {
                      line: 1,
                      column: 1,
                    };
              this.body = body;
              this.name = name;
              this.locationOffset = locationOffset;
              this.locationOffset.line > 0 ||
                (0, _devAssert.default)(
                  0,
                  'line in locationOffset is 1-indexed and must be positive.'
                );
              this.locationOffset.column > 0 ||
                (0, _devAssert.default)(
                  0,
                  'column in locationOffset is 1-indexed and must be positive.'
                );
            } // $FlowFixMe Flow doesn't support computed properties yet

            _createClass(Source, [
              {
                key: _symbols.SYMBOL_TO_STRING_TAG,
                get: function get() {
                  return 'Source';
                },
              },
            ]);

            return Source;
          })();

          exports.Source = Source;

          /***/
        },

      /***/ './node_modules/graphql/language/tokenKind.js':
        /*!****************************************************!*\
  !*** ./node_modules/graphql/language/tokenKind.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.TokenKind = void 0;

          /**
           * An exported enum describing the different kinds of tokens that the
           * lexer emits.
           */
          var TokenKind = Object.freeze({
            SOF: '<SOF>',
            EOF: '<EOF>',
            BANG: '!',
            DOLLAR: '$',
            AMP: '&',
            PAREN_L: '(',
            PAREN_R: ')',
            SPREAD: '...',
            COLON: ':',
            EQUALS: '=',
            AT: '@',
            BRACKET_L: '[',
            BRACKET_R: ']',
            BRACE_L: '{',
            PIPE: '|',
            BRACE_R: '}',
            NAME: 'Name',
            INT: 'Int',
            FLOAT: 'Float',
            STRING: 'String',
            BLOCK_STRING: 'BlockString',
            COMMENT: 'Comment',
          });
          /**
           * The enum type representing the token kinds values.
           */

          exports.TokenKind = TokenKind;

          /***/
        },

      /***/ './node_modules/graphql/language/visitor.js':
        /*!**************************************************!*\
  !*** ./node_modules/graphql/language/visitor.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.visit = visit;
          exports.visitInParallel = visitInParallel;
          exports.getVisitFn = getVisitFn;
          exports.BREAK = exports.QueryDocumentKeys = void 0;

          var _inspect = _interopRequireDefault(
            __webpack_require__(
              /*! ../jsutils/inspect */ './node_modules/graphql/jsutils/inspect.js'
            )
          );

          var _ast = __webpack_require__(
            /*! ./ast */ './node_modules/graphql/language/ast.js'
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          var QueryDocumentKeys = {
            Name: [],
            Document: ['definitions'],
            OperationDefinition: [
              'name',
              'variableDefinitions',
              'directives',
              'selectionSet',
            ],
            VariableDefinition: [
              'variable',
              'type',
              'defaultValue',
              'directives',
            ],
            Variable: ['name'],
            SelectionSet: ['selections'],
            Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
            Argument: ['name', 'value'],
            FragmentSpread: ['name', 'directives'],
            InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
            FragmentDefinition: [
              'name', // Note: fragment variable definitions are experimental and may be changed
              // or removed in the future.
              'variableDefinitions',
              'typeCondition',
              'directives',
              'selectionSet',
            ],
            IntValue: [],
            FloatValue: [],
            StringValue: [],
            BooleanValue: [],
            NullValue: [],
            EnumValue: [],
            ListValue: ['values'],
            ObjectValue: ['fields'],
            ObjectField: ['name', 'value'],
            Directive: ['name', 'arguments'],
            NamedType: ['name'],
            ListType: ['type'],
            NonNullType: ['type'],
            SchemaDefinition: ['description', 'directives', 'operationTypes'],
            OperationTypeDefinition: ['type'],
            ScalarTypeDefinition: ['description', 'name', 'directives'],
            ObjectTypeDefinition: [
              'description',
              'name',
              'interfaces',
              'directives',
              'fields',
            ],
            FieldDefinition: [
              'description',
              'name',
              'arguments',
              'type',
              'directives',
            ],
            InputValueDefinition: [
              'description',
              'name',
              'type',
              'defaultValue',
              'directives',
            ],
            InterfaceTypeDefinition: [
              'description',
              'name',
              'interfaces',
              'directives',
              'fields',
            ],
            UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
            EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
            EnumValueDefinition: ['description', 'name', 'directives'],
            InputObjectTypeDefinition: [
              'description',
              'name',
              'directives',
              'fields',
            ],
            DirectiveDefinition: [
              'description',
              'name',
              'arguments',
              'locations',
            ],
            SchemaExtension: ['directives', 'operationTypes'],
            ScalarTypeExtension: ['name', 'directives'],
            ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
            InterfaceTypeExtension: [
              'name',
              'interfaces',
              'directives',
              'fields',
            ],
            UnionTypeExtension: ['name', 'directives', 'types'],
            EnumTypeExtension: ['name', 'directives', 'values'],
            InputObjectTypeExtension: ['name', 'directives', 'fields'],
          };
          exports.QueryDocumentKeys = QueryDocumentKeys;
          var BREAK = Object.freeze({});
          /**
           * visit() will walk through an AST using a depth-first traversal, calling
           * the visitor's enter function at each node in the traversal, and calling the
           * leave function after visiting that node and all of its child nodes.
           *
           * By returning different values from the enter and leave functions, the
           * behavior of the visitor can be altered, including skipping over a sub-tree of
           * the AST (by returning false), editing the AST by returning a value or null
           * to remove the value, or to stop the whole traversal by returning BREAK.
           *
           * When using visit() to edit an AST, the original AST will not be modified, and
           * a new version of the AST with the changes applied will be returned from the
           * visit function.
           *
           *     const editedAST = visit(ast, {
           *       enter(node, key, parent, path, ancestors) {
           *         // @return
           *         //   undefined: no action
           *         //   false: skip visiting this node
           *         //   visitor.BREAK: stop visiting altogether
           *         //   null: delete this node
           *         //   any value: replace this node with the returned value
           *       },
           *       leave(node, key, parent, path, ancestors) {
           *         // @return
           *         //   undefined: no action
           *         //   false: no action
           *         //   visitor.BREAK: stop visiting altogether
           *         //   null: delete this node
           *         //   any value: replace this node with the returned value
           *       }
           *     });
           *
           * Alternatively to providing enter() and leave() functions, a visitor can
           * instead provide functions named the same as the kinds of AST nodes, or
           * enter/leave visitors at a named key, leading to four permutations of the
           * visitor API:
           *
           * 1) Named visitors triggered when entering a node of a specific kind.
           *
           *     visit(ast, {
           *       Kind(node) {
           *         // enter the "Kind" node
           *       }
           *     })
           *
           * 2) Named visitors that trigger upon entering and leaving a node of
           *    a specific kind.
           *
           *     visit(ast, {
           *       Kind: {
           *         enter(node) {
           *           // enter the "Kind" node
           *         }
           *         leave(node) {
           *           // leave the "Kind" node
           *         }
           *       }
           *     })
           *
           * 3) Generic visitors that trigger upon entering and leaving any node.
           *
           *     visit(ast, {
           *       enter(node) {
           *         // enter any node
           *       },
           *       leave(node) {
           *         // leave any node
           *       }
           *     })
           *
           * 4) Parallel visitors for entering and leaving nodes of a specific kind.
           *
           *     visit(ast, {
           *       enter: {
           *         Kind(node) {
           *           // enter the "Kind" node
           *         }
           *       },
           *       leave: {
           *         Kind(node) {
           *           // leave the "Kind" node
           *         }
           *       }
           *     })
           */

          exports.BREAK = BREAK;

          function visit(root, visitor) {
            var visitorKeys =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : QueryDocumentKeys;

            /* eslint-disable no-undef-init */
            var stack = undefined;
            var inArray = Array.isArray(root);
            var keys = [root];
            var index = -1;
            var edits = [];
            var node = undefined;
            var key = undefined;
            var parent = undefined;
            var path = [];
            var ancestors = [];
            var newRoot = root;
            /* eslint-enable no-undef-init */

            do {
              index++;
              var isLeaving = index === keys.length;
              var isEdited = isLeaving && edits.length !== 0;

              if (isLeaving) {
                key =
                  ancestors.length === 0 ? undefined : path[path.length - 1];
                node = parent;
                parent = ancestors.pop();

                if (isEdited) {
                  if (inArray) {
                    node = node.slice();
                  } else {
                    var clone = {};

                    for (
                      var _i2 = 0, _Object$keys2 = Object.keys(node);
                      _i2 < _Object$keys2.length;
                      _i2++
                    ) {
                      var k = _Object$keys2[_i2];
                      clone[k] = node[k];
                    }

                    node = clone;
                  }

                  var editOffset = 0;

                  for (var ii = 0; ii < edits.length; ii++) {
                    var editKey = edits[ii][0];
                    var editValue = edits[ii][1];

                    if (inArray) {
                      editKey -= editOffset;
                    }

                    if (inArray && editValue === null) {
                      node.splice(editKey, 1);
                      editOffset++;
                    } else {
                      node[editKey] = editValue;
                    }
                  }
                }

                index = stack.index;
                keys = stack.keys;
                edits = stack.edits;
                inArray = stack.inArray;
                stack = stack.prev;
              } else {
                key = parent ? (inArray ? index : keys[index]) : undefined;
                node = parent ? parent[key] : newRoot;

                if (node === null || node === undefined) {
                  continue;
                }

                if (parent) {
                  path.push(key);
                }
              }

              var result = void 0;

              if (!Array.isArray(node)) {
                if (!(0, _ast.isNode)(node)) {
                  throw new Error(
                    'Invalid AST Node: '.concat(
                      (0, _inspect.default)(node),
                      '.'
                    )
                  );
                }

                var visitFn = getVisitFn(visitor, node.kind, isLeaving);

                if (visitFn) {
                  result = visitFn.call(
                    visitor,
                    node,
                    key,
                    parent,
                    path,
                    ancestors
                  );

                  if (result === BREAK) {
                    break;
                  }

                  if (result === false) {
                    if (!isLeaving) {
                      path.pop();
                      continue;
                    }
                  } else if (result !== undefined) {
                    edits.push([key, result]);

                    if (!isLeaving) {
                      if ((0, _ast.isNode)(result)) {
                        node = result;
                      } else {
                        path.pop();
                        continue;
                      }
                    }
                  }
                }
              }

              if (result === undefined && isEdited) {
                edits.push([key, node]);
              }

              if (isLeaving) {
                path.pop();
              } else {
                var _visitorKeys$node$kin;

                stack = {
                  inArray: inArray,
                  index: index,
                  keys: keys,
                  edits: edits,
                  prev: stack,
                };
                inArray = Array.isArray(node);
                keys = inArray
                  ? node
                  : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null &&
                    _visitorKeys$node$kin !== void 0
                  ? _visitorKeys$node$kin
                  : [];
                index = -1;
                edits = [];

                if (parent) {
                  ancestors.push(parent);
                }

                parent = node;
              }
            } while (stack !== undefined);

            if (edits.length !== 0) {
              newRoot = edits[edits.length - 1][1];
            }

            return newRoot;
          }
          /**
           * Creates a new visitor instance which delegates to many visitors to run in
           * parallel. Each visitor will be visited for each node before moving on.
           *
           * If a prior visitor edits a node, no following visitors will see that node.
           */

          function visitInParallel(visitors) {
            var skipping = new Array(visitors.length);
            return {
              enter: function enter(node) {
                for (var i = 0; i < visitors.length; i++) {
                  if (skipping[i] == null) {
                    var fn = getVisitFn(
                      visitors[i],
                      node.kind,
                      /* isLeaving */
                      false
                    );

                    if (fn) {
                      var result = fn.apply(visitors[i], arguments);

                      if (result === false) {
                        skipping[i] = node;
                      } else if (result === BREAK) {
                        skipping[i] = BREAK;
                      } else if (result !== undefined) {
                        return result;
                      }
                    }
                  }
                }
              },
              leave: function leave(node) {
                for (var i = 0; i < visitors.length; i++) {
                  if (skipping[i] == null) {
                    var fn = getVisitFn(
                      visitors[i],
                      node.kind,
                      /* isLeaving */
                      true
                    );

                    if (fn) {
                      var result = fn.apply(visitors[i], arguments);

                      if (result === BREAK) {
                        skipping[i] = BREAK;
                      } else if (result !== undefined && result !== false) {
                        return result;
                      }
                    }
                  } else if (skipping[i] === node) {
                    skipping[i] = null;
                  }
                }
              },
            };
          }
          /**
           * Given a visitor instance, if it is leaving or not, and a node kind, return
           * the function the visitor runtime should call.
           */

          function getVisitFn(visitor, kind, isLeaving) {
            var kindVisitor = visitor[kind];

            if (kindVisitor) {
              if (!isLeaving && typeof kindVisitor === 'function') {
                // { Kind() {} }
                return kindVisitor;
              }

              var kindSpecificVisitor = isLeaving
                ? kindVisitor.leave
                : kindVisitor.enter;

              if (typeof kindSpecificVisitor === 'function') {
                // { Kind: { enter() {}, leave() {} } }
                return kindSpecificVisitor;
              }
            } else {
              var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

              if (specificVisitor) {
                if (typeof specificVisitor === 'function') {
                  // { enter() {}, leave() {} }
                  return specificVisitor;
                }

                var specificKindVisitor = specificVisitor[kind];

                if (typeof specificKindVisitor === 'function') {
                  // { enter: { Kind() {} }, leave: { Kind() {} } }
                  return specificKindVisitor;
                }
              }
            }
          }

          /***/
        },

      /***/ './node_modules/graphql/polyfills/symbols.js':
        /*!***************************************************!*\
  !*** ./node_modules/graphql/polyfills/symbols.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = void 0;
          // In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
          var SYMBOL_ITERATOR =
            typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'; // In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator
          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

          exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
          var SYMBOL_ASYNC_ITERATOR = // $FlowFixMe Flow doesn't define `Symbol.asyncIterator` yet
            typeof Symbol === 'function'
              ? Symbol.asyncIterator
              : '@@asyncIterator'; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')

          exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
          var SYMBOL_TO_STRING_TAG = // $FlowFixMe Flow doesn't define `Symbol.toStringTag` yet
            typeof Symbol === 'function' ? Symbol.toStringTag : '@@toStringTag';
          exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;

          /***/
        },

      /***/ './node_modules/optimism/lib/bundle.esm.js':
        /*!*************************************************!*\
  !*** ./node_modules/optimism/lib/bundle.esm.js ***!
  \*************************************************/
        /*! exports provided: asyncFromGen, bindContext, noContext, setTimeout, KeyTrie, defaultMakeCacheKey, dep, wrap */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'KeyTrie',
            function () {
              return KeyTrie;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defaultMakeCacheKey',
            function () {
              return defaultMakeCacheKey;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'dep',
            function () {
              return dep;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'wrap',
            function () {
              return wrap;
            }
          );
          /* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! @wry/context */ './node_modules/@wry/context/lib/context.esm.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'asyncFromGen',
            function () {
              return _wry_context__WEBPACK_IMPORTED_MODULE_0__['asyncFromGen'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'bindContext',
            function () {
              return _wry_context__WEBPACK_IMPORTED_MODULE_0__['bind'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'noContext',
            function () {
              return _wry_context__WEBPACK_IMPORTED_MODULE_0__['noContext'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'setTimeout',
            function () {
              return _wry_context__WEBPACK_IMPORTED_MODULE_0__['setTimeout'];
            }
          );

          function defaultDispose() {}
          var Cache = /** @class */ (function () {
            function Cache(max, dispose) {
              if (max === void 0) {
                max = Infinity;
              }
              if (dispose === void 0) {
                dispose = defaultDispose;
              }
              this.max = max;
              this.dispose = dispose;
              this.map = new Map();
              this.newest = null;
              this.oldest = null;
            }
            Cache.prototype.has = function (key) {
              return this.map.has(key);
            };
            Cache.prototype.get = function (key) {
              var entry = this.getEntry(key);
              return entry && entry.value;
            };
            Cache.prototype.getEntry = function (key) {
              var entry = this.map.get(key);
              if (entry && entry !== this.newest) {
                var older = entry.older,
                  newer = entry.newer;
                if (newer) {
                  newer.older = older;
                }
                if (older) {
                  older.newer = newer;
                }
                entry.older = this.newest;
                entry.older.newer = entry;
                entry.newer = null;
                this.newest = entry;
                if (entry === this.oldest) {
                  this.oldest = newer;
                }
              }
              return entry;
            };
            Cache.prototype.set = function (key, value) {
              var entry = this.getEntry(key);
              if (entry) {
                return (entry.value = value);
              }
              entry = {
                key: key,
                value: value,
                newer: null,
                older: this.newest,
              };
              if (this.newest) {
                this.newest.newer = entry;
              }
              this.newest = entry;
              this.oldest = this.oldest || entry;
              this.map.set(key, entry);
              return entry.value;
            };
            Cache.prototype.clean = function () {
              while (this.oldest && this.map.size > this.max) {
                this.delete(this.oldest.key);
              }
            };
            Cache.prototype.delete = function (key) {
              var entry = this.map.get(key);
              if (entry) {
                if (entry === this.newest) {
                  this.newest = entry.older;
                }
                if (entry === this.oldest) {
                  this.oldest = entry.newer;
                }
                if (entry.newer) {
                  entry.newer.older = entry.older;
                }
                if (entry.older) {
                  entry.older.newer = entry.newer;
                }
                this.map.delete(key);
                this.dispose(entry.value, key);
                return true;
              }
              return false;
            };
            return Cache;
          })();

          var parentEntrySlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__[
            'Slot'
          ]();

          function maybeUnsubscribe(entryOrDep) {
            var unsubscribe = entryOrDep.unsubscribe;
            if (typeof unsubscribe === 'function') {
              entryOrDep.unsubscribe = void 0;
              unsubscribe();
            }
          }

          var emptySetPool = [];
          var POOL_TARGET_SIZE = 100;
          // Since this package might be used browsers, we should avoid using the
          // Node built-in assert module.
          function assert(condition, optionalMessage) {
            if (!condition) {
              throw new Error(optionalMessage || 'assertion failure');
            }
          }
          function valueIs(a, b) {
            var len = a.length;
            return (
              // Unknown values are not equal to each other.
              len > 0 &&
              // Both values must be ordinary (or both exceptional) to be equal.
              len === b.length &&
              // The underlying value or exception must be the same.
              a[len - 1] === b[len - 1]
            );
          }
          function valueGet(value) {
            switch (value.length) {
              case 0:
                throw new Error('unknown value');
              case 1:
                return value[0];
              case 2:
                throw value[1];
            }
          }
          function valueCopy(value) {
            return value.slice(0);
          }
          var Entry = /** @class */ (function () {
            function Entry(fn, args) {
              this.fn = fn;
              this.args = args;
              this.parents = new Set();
              this.childValues = new Map();
              // When this Entry has children that are dirty, this property becomes
              // a Set containing other Entry objects, borrowed from emptySetPool.
              // When the set becomes empty, it gets recycled back to emptySetPool.
              this.dirtyChildren = null;
              this.dirty = true;
              this.recomputing = false;
              this.value = [];
              this.deps = null;
              ++Entry.count;
            }
            Entry.prototype.peek = function () {
              if (this.value.length === 1 && !mightBeDirty(this)) {
                return this.value[0];
              }
            };
            // This is the most important method of the Entry API, because it
            // determines whether the cached this.value can be returned immediately,
            // or must be recomputed. The overall performance of the caching system
            // depends on the truth of the following observations: (1) this.dirty is
            // usually false, (2) this.dirtyChildren is usually null/empty, and thus
            // (3) valueGet(this.value) is usually returned without recomputation.
            Entry.prototype.recompute = function () {
              assert(!this.recomputing, 'already recomputing');
              rememberParent(this);
              return mightBeDirty(this)
                ? reallyRecompute(this)
                : valueGet(this.value);
            };
            Entry.prototype.setDirty = function () {
              if (this.dirty) return;
              this.dirty = true;
              this.value.length = 0;
              reportDirty(this);
              forgetChildren(this);
              // We can go ahead and unsubscribe here, since any further dirty
              // notifications we receive will be redundant, and unsubscribing may
              // free up some resources, e.g. file watchers.
              maybeUnsubscribe(this);
            };
            Entry.prototype.dispose = function () {
              var _this = this;
              forgetChildren(this);
              maybeUnsubscribe(this);
              // Because this entry has been kicked out of the cache (in index.js),
              // we've lost the ability to find out if/when this entry becomes dirty,
              // whether that happens through a subscription, because of a direct call
              // to entry.setDirty(), or because one of its children becomes dirty.
              // Because of this loss of future information, we have to assume the
              // worst (that this entry might have become dirty very soon), so we must
              // immediately mark this entry's parents as dirty. Normally we could
              // just call entry.setDirty() rather than calling parent.setDirty() for
              // each parent, but that would leave this entry in parent.childValues
              // and parent.dirtyChildren, which would prevent the child from being
              // truly forgotten.
              this.parents.forEach(function (parent) {
                parent.setDirty();
                forgetChild(parent, _this);
              });
            };
            Entry.prototype.dependOn = function (dep) {
              dep.add(this);
              if (!this.deps) {
                this.deps = emptySetPool.pop() || new Set();
              }
              this.deps.add(dep);
            };
            Entry.prototype.forgetDeps = function () {
              var _this = this;
              if (this.deps) {
                this.deps.forEach(function (dep) {
                  return dep.delete(_this);
                });
                this.deps.clear();
                emptySetPool.push(this.deps);
                this.deps = null;
              }
            };
            Entry.count = 0;
            return Entry;
          })();
          function rememberParent(child) {
            var parent = parentEntrySlot.getValue();
            if (parent) {
              child.parents.add(parent);
              if (!parent.childValues.has(child)) {
                parent.childValues.set(child, []);
              }
              if (mightBeDirty(child)) {
                reportDirtyChild(parent, child);
              } else {
                reportCleanChild(parent, child);
              }
              return parent;
            }
          }
          function reallyRecompute(entry) {
            forgetChildren(entry);
            // Set entry as the parent entry while calling recomputeNewValue(entry).
            parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
            if (maybeSubscribe(entry)) {
              // If we successfully recomputed entry.value and did not fail to
              // (re)subscribe, then this Entry is no longer explicitly dirty.
              setClean(entry);
            }
            return valueGet(entry.value);
          }
          function recomputeNewValue(entry) {
            entry.recomputing = true;
            // Set entry.value as unknown.
            entry.value.length = 0;
            try {
              // If entry.fn succeeds, entry.value will become a normal Value.
              entry.value[0] = entry.fn.apply(null, entry.args);
            } catch (e) {
              // If entry.fn throws, entry.value will become exceptional.
              entry.value[1] = e;
            }
            // Either way, this line is always reached.
            entry.recomputing = false;
          }
          function mightBeDirty(entry) {
            return (
              entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size)
            );
          }
          function setClean(entry) {
            entry.dirty = false;
            if (mightBeDirty(entry)) {
              // This Entry may still have dirty children, in which case we can't
              // let our parents know we're clean just yet.
              return;
            }
            reportClean(entry);
          }
          function reportDirty(child) {
            child.parents.forEach(function (parent) {
              return reportDirtyChild(parent, child);
            });
          }
          function reportClean(child) {
            child.parents.forEach(function (parent) {
              return reportCleanChild(parent, child);
            });
          }
          // Let a parent Entry know that one of its children may be dirty.
          function reportDirtyChild(parent, child) {
            // Must have called rememberParent(child) before calling
            // reportDirtyChild(parent, child).
            assert(parent.childValues.has(child));
            assert(mightBeDirty(child));
            if (!parent.dirtyChildren) {
              parent.dirtyChildren = emptySetPool.pop() || new Set();
            } else if (parent.dirtyChildren.has(child)) {
              // If we already know this child is dirty, then we must have already
              // informed our own parents that we are dirty, so we can terminate
              // the recursion early.
              return;
            }
            parent.dirtyChildren.add(child);
            reportDirty(parent);
          }
          // Let a parent Entry know that one of its children is no longer dirty.
          function reportCleanChild(parent, child) {
            // Must have called rememberChild(child) before calling
            // reportCleanChild(parent, child).
            assert(parent.childValues.has(child));
            assert(!mightBeDirty(child));
            var childValue = parent.childValues.get(child);
            if (childValue.length === 0) {
              parent.childValues.set(child, valueCopy(child.value));
            } else if (!valueIs(childValue, child.value)) {
              parent.setDirty();
            }
            removeDirtyChild(parent, child);
            if (mightBeDirty(parent)) {
              return;
            }
            reportClean(parent);
          }
          function removeDirtyChild(parent, child) {
            var dc = parent.dirtyChildren;
            if (dc) {
              dc.delete(child);
              if (dc.size === 0) {
                if (emptySetPool.length < POOL_TARGET_SIZE) {
                  emptySetPool.push(dc);
                }
                parent.dirtyChildren = null;
              }
            }
          }
          // Removes all children from this entry and returns an array of the
          // removed children.
          function forgetChildren(parent) {
            if (parent.childValues.size > 0) {
              parent.childValues.forEach(function (_value, child) {
                forgetChild(parent, child);
              });
            }
            // Remove this parent Entry from any sets to which it was added by the
            // addToSet method.
            parent.forgetDeps();
            // After we forget all our children, this.dirtyChildren must be empty
            // and therefore must have been reset to null.
            assert(parent.dirtyChildren === null);
          }
          function forgetChild(parent, child) {
            child.parents.delete(parent);
            parent.childValues.delete(child);
            removeDirtyChild(parent, child);
          }
          function maybeSubscribe(entry) {
            if (typeof entry.subscribe === 'function') {
              try {
                maybeUnsubscribe(entry); // Prevent double subscriptions.
                entry.unsubscribe = entry.subscribe.apply(null, entry.args);
              } catch (e) {
                // If this Entry has a subscribe function and it threw an exception
                // (or an unsubscribe function it previously returned now throws),
                // return false to indicate that we were not able to subscribe (or
                // unsubscribe), and this Entry should remain dirty.
                entry.setDirty();
                return false;
              }
            }
            // Returning true indicates either that there was no entry.subscribe
            // function or that it succeeded.
            return true;
          }

          // A trie data structure that holds object keys weakly, yet can also hold
          // non-object keys, unlike the native `WeakMap`.
          // If no makeData function is supplied, the looked-up data will be an empty,
          // no-prototype Object.
          var defaultMakeData = function () {
            return Object.create(null);
          };
          var KeyTrie = /** @class */ (function () {
            function KeyTrie(weakness, makeData) {
              if (makeData === void 0) {
                makeData = defaultMakeData;
              }
              this.weakness = weakness;
              this.makeData = makeData;
            }
            KeyTrie.prototype.lookup = function () {
              var array = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                array[_i] = arguments[_i];
              }
              return this.lookupArray(array);
            };
            KeyTrie.prototype.lookupArray = function (array) {
              var node = this;
              array.forEach(function (key) {
                return (node = node.getChildTrie(key));
              });
              return node.data || (node.data = this.makeData(array.slice(0)));
            };
            KeyTrie.prototype.getChildTrie = function (key) {
              var map =
                this.weakness && isObjRef(key)
                  ? this.weak || (this.weak = new WeakMap())
                  : this.strong || (this.strong = new Map());
              var child = map.get(key);
              if (!child)
                map.set(
                  key,
                  (child = new KeyTrie(this.weakness, this.makeData))
                );
              return child;
            };
            return KeyTrie;
          })();
          function isObjRef(value) {
            switch (typeof value) {
              case 'object':
                if (value === null) break;
              // Fall through to return true...
              case 'function':
                return true;
            }
            return false;
          }

          function dep(options) {
            var depsByKey = new Map();
            var subscribe = options && options.subscribe;
            function depend(key) {
              var parent = parentEntrySlot.getValue();
              if (parent) {
                var dep_1 = depsByKey.get(key);
                if (!dep_1) {
                  depsByKey.set(key, (dep_1 = new Set()));
                }
                parent.dependOn(dep_1);
                if (typeof subscribe === 'function') {
                  maybeUnsubscribe(dep_1);
                  dep_1.unsubscribe = subscribe(key);
                }
              }
            }
            depend.dirty = function dirty(key) {
              var dep = depsByKey.get(key);
              if (dep) {
                dep.forEach(function (entry) {
                  return entry.setDirty();
                });
                depsByKey.delete(key);
                maybeUnsubscribe(dep);
              }
            };
            return depend;
          }

          // The defaultMakeCacheKey function is remarkably powerful, because it gives
          // a unique object for any shallow-identical list of arguments. If you need
          // to implement a custom makeCacheKey function, you may find it helpful to
          // delegate the final work to defaultMakeCacheKey, which is why we export it
          // here. However, you may want to avoid defaultMakeCacheKey if your runtime
          // does not support WeakMap, or you have the ability to return a string key.
          // In those cases, just write your own custom makeCacheKey functions.
          var keyTrie = new KeyTrie(typeof WeakMap === 'function');
          function defaultMakeCacheKey() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return keyTrie.lookupArray(args);
          }
          var caches = new Set();
          function wrap(originalFunction, options) {
            if (options === void 0) {
              options = Object.create(null);
            }
            var cache = new Cache(options.max || Math.pow(2, 16), function (
              entry
            ) {
              return entry.dispose();
            });
            var keyArgs =
              options.keyArgs ||
              function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return args;
              };
            var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
            function optimistic() {
              var key = makeCacheKey.apply(
                null,
                keyArgs.apply(null, arguments)
              );
              if (key === void 0) {
                return originalFunction.apply(null, arguments);
              }
              var args = Array.prototype.slice.call(arguments);
              var entry = cache.get(key);
              if (entry) {
                entry.args = args;
              } else {
                entry = new Entry(originalFunction, args);
                cache.set(key, entry);
                entry.subscribe = options.subscribe;
              }
              var value = entry.recompute();
              // Move this entry to the front of the least-recently used queue,
              // since we just finished computing its value.
              cache.set(key, entry);
              caches.add(cache);
              // Clean up any excess entries in the cache, but only if there is no
              // active parent entry, meaning we're not in the middle of a larger
              // computation that might be flummoxed by the cleaning.
              if (!parentEntrySlot.hasValue()) {
                caches.forEach(function (cache) {
                  return cache.clean();
                });
                caches.clear();
              }
              return value;
            }
            function lookup() {
              var key = makeCacheKey.apply(null, arguments);
              if (key !== void 0) {
                return cache.get(key);
              }
            }
            optimistic.dirty = function () {
              var entry = lookup.apply(null, arguments);
              if (entry) {
                entry.setDirty();
              }
            };
            optimistic.peek = function () {
              var entry = lookup.apply(null, arguments);
              if (entry) {
                return entry.peek();
              }
            };
            return optimistic;
          }

          //# sourceMappingURL=bundle.esm.js.map

          /***/
        },

      /***/ './node_modules/process/browser.js':
        /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          // shim for using process in browser
          var process = (module.exports = {});

          // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.

          var cachedSetTimeout;
          var cachedClearTimeout;

          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
          }
          (function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0);
            }
            // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker);
            }
            // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }

          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }

          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };

          // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          process.title = 'browser';
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = ''; // empty string to avoid regexp issues
          process.versions = {};

          function noop() {}

          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;

          process.listeners = function (name) {
            return [];
          };

          process.binding = function (name) {
            throw new Error('process.binding is not supported');
          };

          process.cwd = function () {
            return '/';
          };
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
          };
          process.umask = function () {
            return 0;
          };

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/_virtual/_commonjsHelpers.js':
        /*!******************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/_virtual/_commonjsHelpers.js ***!
  \******************************************************************/
        /*! exports provided: commonjsRequire, createCommonjsModule */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'commonjsRequire',
            function () {
              return commonjsRequire;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createCommonjsModule',
            function () {
              return createCommonjsModule;
            }
          );
          function commonjsRequire() {
            throw new Error(
              'Dynamic requires are not currently supported by rollup-plugin-commonjs'
            );
          }

          function createCommonjsModule(fn, module) {
            return (
              (module = { exports: {} }),
              fn(module, module.exports),
              module.exports
            );
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/@xstate/fsm/es/index.js':
        /*!**************************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/@xstate/fsm/es/index.js ***!
  \**************************************************************************/
        /*! exports provided: InterpreterStatus, assign, createMachine, interpret */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'InterpreterStatus',
            function () {
              return t;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'assign',
            function () {
              return r;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createMachine',
            function () {
              return c;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'interpret',
            function () {
              return f;
            }
          );
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
          var t;
          !(function (t) {
            (t[(t.NotStarted = 0)] = 'NotStarted'),
              (t[(t.Running = 1)] = 'Running'),
              (t[(t.Stopped = 2)] = 'Stopped');
          })(t || (t = {}));
          var n = { type: 'xstate.init' };
          function e(t) {
            return void 0 === t ? [] : [].concat(t);
          }
          function r(t) {
            return { type: 'xstate.assign', assignment: t };
          }
          function i(t, n) {
            return 'string' ==
              typeof (t = 'string' == typeof t && n && n[t] ? n[t] : t)
              ? { type: t }
              : 'function' == typeof t
              ? { type: t.name, exec: t }
              : t;
          }
          function o(t) {
            return function (n) {
              return t === n;
            };
          }
          function a(t) {
            return 'string' == typeof t ? { type: t } : t;
          }
          function u(t, n) {
            return {
              value: t,
              context: n,
              actions: [],
              changed: !1,
              matches: o(t),
            };
          }
          function c(t, n) {
            void 0 === n && (n = {});
            var r = {
              config: t,
              _options: n,
              initialState: {
                value: t.initial,
                actions: e(t.states[t.initial].entry).map(function (t) {
                  return i(t, n.actions);
                }),
                context: t.context,
                matches: o(t.initial),
              },
              transition: function (n, c) {
                var s,
                  f,
                  l =
                    'string' == typeof n ? { value: n, context: t.context } : n,
                  v = l.value,
                  p = l.context,
                  g = a(c),
                  y = t.states[v];
                if (y.on) {
                  var d = e(y.on[g.type]),
                    x = function (n) {
                      if (void 0 === n) return { value: u(v, p) };
                      var e = 'string' == typeof n ? { target: n } : n,
                        a = e.target,
                        c = void 0 === a ? v : a,
                        s = e.actions,
                        f = void 0 === s ? [] : s,
                        l = e.cond,
                        d = p;
                      if (
                        (void 0 === l
                          ? function () {
                              return !0;
                            }
                          : l)(p, g)
                      ) {
                        var x = t.states[c],
                          m = !1,
                          h = []
                            .concat(y.exit, f, x.entry)
                            .filter(function (t) {
                              return t;
                            })
                            .map(function (t) {
                              return i(t, r._options.actions);
                            })
                            .filter(function (t) {
                              if ('xstate.assign' === t.type) {
                                m = !0;
                                var n = Object.assign({}, d);
                                return (
                                  'function' == typeof t.assignment
                                    ? (n = t.assignment(d, g))
                                    : Object.keys(t.assignment).forEach(
                                        function (e) {
                                          n[e] =
                                            'function' == typeof t.assignment[e]
                                              ? t.assignment[e](d, g)
                                              : t.assignment[e];
                                        }
                                      ),
                                  (d = n),
                                  !1
                                );
                              }
                              return !0;
                            });
                        return {
                          value: {
                            value: c,
                            context: d,
                            actions: h,
                            changed: c !== v || h.length > 0 || m,
                            matches: o(c),
                          },
                        };
                      }
                    };
                  try {
                    for (
                      var m = (function (t) {
                          var n =
                              'function' == typeof Symbol && t[Symbol.iterator],
                            e = 0;
                          return n
                            ? n.call(t)
                            : {
                                next: function () {
                                  return (
                                    t && e >= t.length && (t = void 0),
                                    { value: t && t[e++], done: !t }
                                  );
                                },
                              };
                        })(d),
                        h = m.next();
                      !h.done;
                      h = m.next()
                    ) {
                      var S = x(h.value);
                      if ('object' == typeof S) return S.value;
                    }
                  } catch (t) {
                    s = { error: t };
                  } finally {
                    try {
                      h && !h.done && (f = m.return) && f.call(m);
                    } finally {
                      if (s) throw s.error;
                    }
                  }
                }
                return u(v, p);
              },
            };
            return r;
          }
          var s = function (t, n) {
            return t.actions.forEach(function (e) {
              var r = e.exec;
              return r && r(t.context, n);
            });
          };
          function f(e) {
            var r = e.initialState,
              i = t.NotStarted,
              o = new Set(),
              u = {
                _machine: e,
                send: function (n) {
                  i === t.Running &&
                    ((r = e.transition(r, n)),
                    s(r, a(n)),
                    o.forEach(function (t) {
                      return t(r);
                    }));
                },
                subscribe: function (t) {
                  return (
                    o.add(t),
                    t(r),
                    {
                      unsubscribe: function () {
                        return o.delete(t);
                      },
                    }
                  );
                },
                start: function () {
                  return (i = t.Running), s(r, n), u;
                },
                stop: function () {
                  return (i = t.Stopped), o.clear(), u;
                },
                get state() {
                  return r;
                },
                get status() {
                  return i;
                },
              };
            return u;
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/mitt/dist/mitt.es.js':
        /*!***********************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/mitt/dist/mitt.es.js ***!
  \***********************************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          //
          // An event handler can take an optional event argument
          // and should not return a value

          // An array of all currently registered event handlers for a type

          // A map of event types and their corresponding event handlers.

          /** Mitt: Tiny (~200b) functional event emitter / pubsub.
           *  @name mitt
           *  @returns {Mitt}
           */
          function mitt(all) {
            all = all || Object.create(null);

            return {
              /**
               * Register an event handler for the given type.
               *
               * @param  {String} type	Type of event to listen for, or `"*"` for all events
               * @param  {Function} handler Function to call in response to given event
               * @memberOf mitt
               */
              on: function on(type, handler) {
                (all[type] || (all[type] = [])).push(handler);
              },

              /**
               * Remove an event handler for the given type.
               *
               * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
               * @param  {Function} handler Handler function to remove
               * @memberOf mitt
               */
              off: function off(type, handler) {
                if (all[type]) {
                  all[type].splice(all[type].indexOf(handler) >>> 0, 1);
                }
              },

              /**
               * Invoke all handlers for the given type.
               * If present, `"*"` handlers are invoked after type-matched handlers.
               *
               * @param {String} type  The event type to invoke
               * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
               * @memberOf mitt
               */
              emit: function emit(type, evt) {
                (all[type] || []).slice().map(function (handler) {
                  handler(evt);
                });
                (all['*'] || []).slice().map(function (handler) {
                  handler(type, evt);
                });
              },
            };
          }

          /* harmony default export */ __webpack_exports__['default'] = mitt;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_deflate.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_deflate.js ***!
  \****************************************************************************/
        /*! exports provided: __moduleExports, deflate */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__moduleExports',
            function () {
              return pako_deflate;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'deflate',
            function () {
              return pako_deflate_1;
            }
          );
          /* harmony import */ var _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../../_virtual/_commonjsHelpers.js */ './node_modules/rrweb/es/rrweb/_virtual/_commonjsHelpers.js'
          );

          var pako_deflate = Object(
            _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
              'createCommonjsModule'
            ]
          )(function (module, exports) {
            /* pako 1.0.11 nodeca/pako */ (function (f) {
              {
                module.exports = f();
              }
            })(function () {
              return (function () {
                function r(e, n, t) {
                  function o(i, f) {
                    if (!n[i]) {
                      if (!e[i]) {
                        var c =
                          'function' ==
                            typeof _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                              'commonjsRequire'
                            ] &&
                          _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                            'commonjsRequire'
                          ];
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw ((a.code = 'MODULE_NOT_FOUND'), a);
                      }
                      var p = (n[i] = { exports: {} });
                      e[i][0].call(
                        p.exports,
                        function (r) {
                          var n = e[i][1][r];
                          return o(n || r);
                        },
                        p,
                        p.exports,
                        r,
                        e,
                        n,
                        t
                      );
                    }
                    return n[i].exports;
                  }
                  for (
                    var u =
                        'function' ==
                          typeof _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                            'commonjsRequire'
                          ] &&
                        _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                          'commonjsRequire'
                        ],
                      i = 0;
                    i < t.length;
                    i++
                  )
                    o(t[i]);
                  return o;
                }
                return r;
              })()(
                {
                  1: [
                    function (require, module, exports) {
                      var TYPED_OK =
                        typeof Uint8Array !== 'undefined' &&
                        typeof Uint16Array !== 'undefined' &&
                        typeof Int32Array !== 'undefined';

                      function _has(obj, key) {
                        return Object.prototype.hasOwnProperty.call(obj, key);
                      }

                      exports.assign = function (
                        obj /*from1, from2, from3, ...*/
                      ) {
                        var sources = Array.prototype.slice.call(arguments, 1);
                        while (sources.length) {
                          var source = sources.shift();
                          if (!source) {
                            continue;
                          }

                          if (typeof source !== 'object') {
                            throw new TypeError(source + 'must be non-object');
                          }

                          for (var p in source) {
                            if (_has(source, p)) {
                              obj[p] = source[p];
                            }
                          }
                        }

                        return obj;
                      };

                      // reduce buffer size, avoiding mem copy
                      exports.shrinkBuf = function (buf, size) {
                        if (buf.length === size) {
                          return buf;
                        }
                        if (buf.subarray) {
                          return buf.subarray(0, size);
                        }
                        buf.length = size;
                        return buf;
                      };

                      var fnTyped = {
                        arraySet: function (
                          dest,
                          src,
                          src_offs,
                          len,
                          dest_offs
                        ) {
                          if (src.subarray && dest.subarray) {
                            dest.set(
                              src.subarray(src_offs, src_offs + len),
                              dest_offs
                            );
                            return;
                          }
                          // Fallback to ordinary array
                          for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                          }
                        },
                        // Join array of chunks to single array.
                        flattenChunks: function (chunks) {
                          var i, l, len, pos, chunk, result;

                          // calculate data length
                          len = 0;
                          for (i = 0, l = chunks.length; i < l; i++) {
                            len += chunks[i].length;
                          }

                          // join chunks
                          result = new Uint8Array(len);
                          pos = 0;
                          for (i = 0, l = chunks.length; i < l; i++) {
                            chunk = chunks[i];
                            result.set(chunk, pos);
                            pos += chunk.length;
                          }

                          return result;
                        },
                      };

                      var fnUntyped = {
                        arraySet: function (
                          dest,
                          src,
                          src_offs,
                          len,
                          dest_offs
                        ) {
                          for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                          }
                        },
                        // Join array of chunks to single array.
                        flattenChunks: function (chunks) {
                          return [].concat.apply([], chunks);
                        },
                      };

                      // Enable/Disable typed arrays use, for testing
                      //
                      exports.setTyped = function (on) {
                        if (on) {
                          exports.Buf8 = Uint8Array;
                          exports.Buf16 = Uint16Array;
                          exports.Buf32 = Int32Array;
                          exports.assign(exports, fnTyped);
                        } else {
                          exports.Buf8 = Array;
                          exports.Buf16 = Array;
                          exports.Buf32 = Array;
                          exports.assign(exports, fnUntyped);
                        }
                      };

                      exports.setTyped(TYPED_OK);
                    },
                    {},
                  ],
                  2: [
                    function (require, module, exports) {
                      var utils = require('./common');

                      // Quick check if we can use fast array to bin string conversion
                      //
                      // - apply(Array) can fail on Android 2.2
                      // - apply(Uint8Array) can fail on iOS 5.1 Safari
                      //
                      var STR_APPLY_OK = true;
                      var STR_APPLY_UIA_OK = true;

                      try {
                        String.fromCharCode.apply(null, [0]);
                      } catch (__) {
                        STR_APPLY_OK = false;
                      }
                      try {
                        String.fromCharCode.apply(null, new Uint8Array(1));
                      } catch (__) {
                        STR_APPLY_UIA_OK = false;
                      }

                      // Table with utf8 lengths (calculated by first byte of sequence)
                      // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
                      // because max possible codepoint is 0x10ffff
                      var _utf8len = new utils.Buf8(256);
                      for (var q = 0; q < 256; q++) {
                        _utf8len[q] =
                          q >= 252
                            ? 6
                            : q >= 248
                            ? 5
                            : q >= 240
                            ? 4
                            : q >= 224
                            ? 3
                            : q >= 192
                            ? 2
                            : 1;
                      }
                      _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

                      // convert string to array (typed, when possible)
                      exports.string2buf = function (str) {
                        var buf,
                          c,
                          c2,
                          m_pos,
                          i,
                          str_len = str.length,
                          buf_len = 0;

                        // count binary size
                        for (m_pos = 0; m_pos < str_len; m_pos++) {
                          c = str.charCodeAt(m_pos);
                          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                            c2 = str.charCodeAt(m_pos + 1);
                            if ((c2 & 0xfc00) === 0xdc00) {
                              c =
                                0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                              m_pos++;
                            }
                          }
                          buf_len +=
                            c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
                        }

                        // allocate buffer
                        buf = new utils.Buf8(buf_len);

                        // convert
                        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                          c = str.charCodeAt(m_pos);
                          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                            c2 = str.charCodeAt(m_pos + 1);
                            if ((c2 & 0xfc00) === 0xdc00) {
                              c =
                                0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                              m_pos++;
                            }
                          }
                          if (c < 0x80) {
                            /* one byte */
                            buf[i++] = c;
                          } else if (c < 0x800) {
                            /* two bytes */
                            buf[i++] = 0xc0 | (c >>> 6);
                            buf[i++] = 0x80 | (c & 0x3f);
                          } else if (c < 0x10000) {
                            /* three bytes */
                            buf[i++] = 0xe0 | (c >>> 12);
                            buf[i++] = 0x80 | ((c >>> 6) & 0x3f);
                            buf[i++] = 0x80 | (c & 0x3f);
                          } else {
                            /* four bytes */
                            buf[i++] = 0xf0 | (c >>> 18);
                            buf[i++] = 0x80 | ((c >>> 12) & 0x3f);
                            buf[i++] = 0x80 | ((c >>> 6) & 0x3f);
                            buf[i++] = 0x80 | (c & 0x3f);
                          }
                        }

                        return buf;
                      };

                      // Helper (used in 2 places)
                      function buf2binstring(buf, len) {
                        // On Chrome, the arguments in a function call that are allowed is `65534`.
                        // If the length of the buffer is smaller than that, we can use this optimization,
                        // otherwise we will take a slower path.
                        if (len < 65534) {
                          if (
                            (buf.subarray && STR_APPLY_UIA_OK) ||
                            (!buf.subarray && STR_APPLY_OK)
                          ) {
                            return String.fromCharCode.apply(
                              null,
                              utils.shrinkBuf(buf, len)
                            );
                          }
                        }

                        var result = '';
                        for (var i = 0; i < len; i++) {
                          result += String.fromCharCode(buf[i]);
                        }
                        return result;
                      }

                      // Convert byte array to binary string
                      exports.buf2binstring = function (buf) {
                        return buf2binstring(buf, buf.length);
                      };

                      // Convert binary string (typed, when possible)
                      exports.binstring2buf = function (str) {
                        var buf = new utils.Buf8(str.length);
                        for (var i = 0, len = buf.length; i < len; i++) {
                          buf[i] = str.charCodeAt(i);
                        }
                        return buf;
                      };

                      // convert array to string
                      exports.buf2string = function (buf, max) {
                        var i, out, c, c_len;
                        var len = max || buf.length;

                        // Reserve max possible length (2 words per char)
                        // NB: by unknown reasons, Array is significantly faster for
                        //     String.fromCharCode.apply than Uint16Array.
                        var utf16buf = new Array(len * 2);

                        for (out = 0, i = 0; i < len; ) {
                          c = buf[i++];
                          // quick process ascii
                          if (c < 0x80) {
                            utf16buf[out++] = c;
                            continue;
                          }

                          c_len = _utf8len[c];
                          // skip 5 & 6 byte codes
                          if (c_len > 4) {
                            utf16buf[out++] = 0xfffd;
                            i += c_len - 1;
                            continue;
                          }

                          // apply mask on first byte
                          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
                          // join the rest
                          while (c_len > 1 && i < len) {
                            c = (c << 6) | (buf[i++] & 0x3f);
                            c_len--;
                          }

                          // terminated by end of string?
                          if (c_len > 1) {
                            utf16buf[out++] = 0xfffd;
                            continue;
                          }

                          if (c < 0x10000) {
                            utf16buf[out++] = c;
                          } else {
                            c -= 0x10000;
                            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
                          }
                        }

                        return buf2binstring(utf16buf, out);
                      };

                      // Calculate max possible position in utf8 buffer,
                      // that will not break sequence. If that's not possible
                      // - (very small limits) return max size as is.
                      //
                      // buf[] - utf8 bytes array
                      // max   - length limit (mandatory);
                      exports.utf8border = function (buf, max) {
                        var pos;

                        max = max || buf.length;
                        if (max > buf.length) {
                          max = buf.length;
                        }

                        // go back from last position, until start of sequence found
                        pos = max - 1;
                        while (pos >= 0 && (buf[pos] & 0xc0) === 0x80) {
                          pos--;
                        }

                        // Very small and broken sequence,
                        // return max, because we should return something anyway.
                        if (pos < 0) {
                          return max;
                        }

                        // If we came to start of buffer - that means buffer is too small,
                        // return max too.
                        if (pos === 0) {
                          return max;
                        }

                        return pos + _utf8len[buf[pos]] > max ? pos : max;
                      };
                    },
                    { './common': 1 },
                  ],
                  3: [
                    function (require, module, exports) {
                      // Note: adler32 takes 12% for level 0 and 2% for level 6.
                      // It isn't worth it to make additional optimizations as in original.
                      // Small size is preferable.

                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      function adler32(adler, buf, len, pos) {
                        var s1 = (adler & 0xffff) | 0,
                          s2 = ((adler >>> 16) & 0xffff) | 0,
                          n = 0;

                        while (len !== 0) {
                          // Set limit ~ twice less than 5552, to keep
                          // s2 in 31-bits, because we force signed ints.
                          // in other case %= will fail.
                          n = len > 2000 ? 2000 : len;
                          len -= n;

                          do {
                            s1 = (s1 + buf[pos++]) | 0;
                            s2 = (s2 + s1) | 0;
                          } while (--n);

                          s1 %= 65521;
                          s2 %= 65521;
                        }

                        return s1 | (s2 << 16) | 0;
                      }

                      module.exports = adler32;
                    },
                    {},
                  ],
                  4: [
                    function (require, module, exports) {
                      // Note: we can't get significant speed boost here.
                      // So write code to minimize size - no pregenerated tables
                      // and array tools dependencies.

                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      // Use ordinary array, since untyped makes no boost here
                      function makeTable() {
                        var c,
                          table = [];

                        for (var n = 0; n < 256; n++) {
                          c = n;
                          for (var k = 0; k < 8; k++) {
                            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
                          }
                          table[n] = c;
                        }

                        return table;
                      }

                      // Create table on load. Just 255 signed longs. Not a problem.
                      var crcTable = makeTable();

                      function crc32(crc, buf, len, pos) {
                        var t = crcTable,
                          end = pos + len;

                        crc ^= -1;

                        for (var i = pos; i < end; i++) {
                          crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff];
                        }

                        return crc ^ -1; // >>> 0;
                      }

                      module.exports = crc32;
                    },
                    {},
                  ],
                  5: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      var utils = require('../utils/common');
                      var trees = require('./trees');
                      var adler32 = require('./adler32');
                      var crc32 = require('./crc32');
                      var msg = require('./messages');

                      /* Public constants ==========================================================*/
                      /* ===========================================================================*/

                      /* Allowed flush values; see deflate() and inflate() below for details */
                      var Z_NO_FLUSH = 0;
                      var Z_PARTIAL_FLUSH = 1;
                      //var Z_SYNC_FLUSH    = 2;
                      var Z_FULL_FLUSH = 3;
                      var Z_FINISH = 4;
                      var Z_BLOCK = 5;
                      //var Z_TREES         = 6;

                      /* Return codes for the compression/decompression functions. Negative values
                       * are errors, positive values are used for special but normal events.
                       */
                      var Z_OK = 0;
                      var Z_STREAM_END = 1;
                      //var Z_NEED_DICT     = 2;
                      //var Z_ERRNO         = -1;
                      var Z_STREAM_ERROR = -2;
                      var Z_DATA_ERROR = -3;
                      //var Z_MEM_ERROR     = -4;
                      var Z_BUF_ERROR = -5;
                      //var Z_VERSION_ERROR = -6;

                      /* compression levels */
                      //var Z_NO_COMPRESSION      = 0;
                      //var Z_BEST_SPEED          = 1;
                      //var Z_BEST_COMPRESSION    = 9;
                      var Z_DEFAULT_COMPRESSION = -1;

                      var Z_FILTERED = 1;
                      var Z_HUFFMAN_ONLY = 2;
                      var Z_RLE = 3;
                      var Z_FIXED = 4;
                      var Z_DEFAULT_STRATEGY = 0;

                      /* Possible values of the data_type field (though see inflate()) */
                      //var Z_BINARY              = 0;
                      //var Z_TEXT                = 1;
                      //var Z_ASCII               = 1; // = Z_TEXT
                      var Z_UNKNOWN = 2;

                      /* The deflate compression method */
                      var Z_DEFLATED = 8;

                      /*============================================================================*/

                      var MAX_MEM_LEVEL = 9;
                      /* Maximum value for memLevel in deflateInit2 */
                      var MAX_WBITS = 15;
                      /* 32K LZ77 window */
                      var DEF_MEM_LEVEL = 8;

                      var LENGTH_CODES = 29;
                      /* number of length codes, not counting the special END_BLOCK code */
                      var LITERALS = 256;
                      /* number of literal bytes 0..255 */
                      var L_CODES = LITERALS + 1 + LENGTH_CODES;
                      /* number of Literal or Length codes, including the END_BLOCK code */
                      var D_CODES = 30;
                      /* number of distance codes */
                      var BL_CODES = 19;
                      /* number of codes used to transfer the bit lengths */
                      var HEAP_SIZE = 2 * L_CODES + 1;
                      /* maximum heap size */
                      var MAX_BITS = 15;
                      /* All codes must not exceed MAX_BITS bits */

                      var MIN_MATCH = 3;
                      var MAX_MATCH = 258;
                      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

                      var PRESET_DICT = 0x20;

                      var INIT_STATE = 42;
                      var EXTRA_STATE = 69;
                      var NAME_STATE = 73;
                      var COMMENT_STATE = 91;
                      var HCRC_STATE = 103;
                      var BUSY_STATE = 113;
                      var FINISH_STATE = 666;

                      var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
                      var BS_BLOCK_DONE = 2; /* block flush performed */
                      var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
                      var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

                      var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

                      function err(strm, errorCode) {
                        strm.msg = msg[errorCode];
                        return errorCode;
                      }

                      function rank(f) {
                        return (f << 1) - (f > 4 ? 9 : 0);
                      }

                      function zero(buf) {
                        var len = buf.length;
                        while (--len >= 0) {
                          buf[len] = 0;
                        }
                      }

                      /* =========================================================================
                       * Flush as much pending output as possible. All deflate() output goes
                       * through this function so some applications may wish to modify it
                       * to avoid allocating a large strm->output buffer and copying into it.
                       * (See also read_buf()).
                       */
                      function flush_pending(strm) {
                        var s = strm.state;

                        //_tr_flush_bits(s);
                        var len = s.pending;
                        if (len > strm.avail_out) {
                          len = strm.avail_out;
                        }
                        if (len === 0) {
                          return;
                        }

                        utils.arraySet(
                          strm.output,
                          s.pending_buf,
                          s.pending_out,
                          len,
                          strm.next_out
                        );
                        strm.next_out += len;
                        s.pending_out += len;
                        strm.total_out += len;
                        strm.avail_out -= len;
                        s.pending -= len;
                        if (s.pending === 0) {
                          s.pending_out = 0;
                        }
                      }

                      function flush_block_only(s, last) {
                        trees._tr_flush_block(
                          s,
                          s.block_start >= 0 ? s.block_start : -1,
                          s.strstart - s.block_start,
                          last
                        );
                        s.block_start = s.strstart;
                        flush_pending(s.strm);
                      }

                      function put_byte(s, b) {
                        s.pending_buf[s.pending++] = b;
                      }

                      /* =========================================================================
                       * Put a short in the pending buffer. The 16-bit value is put in MSB order.
                       * IN assertion: the stream state is correct and there is enough room in
                       * pending_buf.
                       */
                      function putShortMSB(s, b) {
                        //  put_byte(s, (Byte)(b >> 8));
                        //  put_byte(s, (Byte)(b & 0xff));
                        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
                        s.pending_buf[s.pending++] = b & 0xff;
                      }

                      /* ===========================================================================
                       * Read a new buffer from the current input stream, update the adler32
                       * and total number of bytes read.  All deflate() input goes through
                       * this function so some applications may wish to modify it to avoid
                       * allocating a large strm->input buffer and copying from it.
                       * (See also flush_pending()).
                       */
                      function read_buf(strm, buf, start, size) {
                        var len = strm.avail_in;

                        if (len > size) {
                          len = size;
                        }
                        if (len === 0) {
                          return 0;
                        }

                        strm.avail_in -= len;

                        // zmemcpy(buf, strm->next_in, len);
                        utils.arraySet(
                          buf,
                          strm.input,
                          strm.next_in,
                          len,
                          start
                        );
                        if (strm.state.wrap === 1) {
                          strm.adler = adler32(strm.adler, buf, len, start);
                        } else if (strm.state.wrap === 2) {
                          strm.adler = crc32(strm.adler, buf, len, start);
                        }

                        strm.next_in += len;
                        strm.total_in += len;

                        return len;
                      }

                      /* ===========================================================================
                       * Set match_start to the longest match starting at the given string and
                       * return its length. Matches shorter or equal to prev_length are discarded,
                       * in which case the result is equal to prev_length and match_start is
                       * garbage.
                       * IN assertions: cur_match is the head of the hash chain for the current
                       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
                       * OUT assertion: the match length is not greater than s->lookahead.
                       */
                      function longest_match(s, cur_match) {
                        var chain_length =
                          s.max_chain_length; /* max hash chain length */
                        var scan = s.strstart; /* current string */
                        var match; /* matched string */
                        var len; /* length of current match */
                        var best_len =
                          s.prev_length; /* best match length so far */
                        var nice_match =
                          s.nice_match; /* stop if match long enough */
                        var limit =
                          s.strstart > s.w_size - MIN_LOOKAHEAD
                            ? s.strstart - (s.w_size - MIN_LOOKAHEAD)
                            : 0; /*NIL*/

                        var _win = s.window; // shortcut

                        var wmask = s.w_mask;
                        var prev = s.prev;

                        /* Stop when cur_match becomes <= limit. To simplify the code,
                         * we prevent matches with the string of window index 0.
                         */

                        var strend = s.strstart + MAX_MATCH;
                        var scan_end1 = _win[scan + best_len - 1];
                        var scan_end = _win[scan + best_len];

                        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
                         * It is easy to get rid of this optimization if necessary.
                         */
                        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

                        /* Do not waste too much time if we already have a good match: */
                        if (s.prev_length >= s.good_match) {
                          chain_length >>= 2;
                        }
                        /* Do not look for matches beyond the end of the input. This is necessary
                         * to make deflate deterministic.
                         */
                        if (nice_match > s.lookahead) {
                          nice_match = s.lookahead;
                        }

                        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

                        do {
                          // Assert(cur_match < s->strstart, "no future");
                          match = cur_match;

                          /* Skip to next match if the match length cannot increase
                           * or if the match length is less than 2.  Note that the checks below
                           * for insufficient lookahead only occur occasionally for performance
                           * reasons.  Therefore uninitialized memory will be accessed, and
                           * conditional jumps will be made that depend on those values.
                           * However the length of the match is limited to the lookahead, so
                           * the output of deflate is not affected by the uninitialized values.
                           */

                          if (
                            _win[match + best_len] !== scan_end ||
                            _win[match + best_len - 1] !== scan_end1 ||
                            _win[match] !== _win[scan] ||
                            _win[++match] !== _win[scan + 1]
                          ) {
                            continue;
                          }

                          /* The check at best_len-1 can be removed because it will be made
                           * again later. (This heuristic is not always a win.)
                           * It is not necessary to compare scan[2] and match[2] since they
                           * are always equal when the other bytes match, given that
                           * the hash keys are equal and that HASH_BITS >= 8.
                           */
                          scan += 2;
                          match++;
                          // Assert(*scan == *match, "match[2]?");

                          /* We check for insufficient lookahead only every 8th comparison;
                           * the 256th check will be made at strstart+258.
                           */
                          do {
                            /*jshint noempty:false*/
                          } while (
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] &&
                            scan < strend
                          );

                          // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

                          len = MAX_MATCH - (strend - scan);
                          scan = strend - MAX_MATCH;

                          if (len > best_len) {
                            s.match_start = cur_match;
                            best_len = len;
                            if (len >= nice_match) {
                              break;
                            }
                            scan_end1 = _win[scan + best_len - 1];
                            scan_end = _win[scan + best_len];
                          }
                        } while (
                          (cur_match = prev[cur_match & wmask]) > limit &&
                          --chain_length !== 0
                        );

                        if (best_len <= s.lookahead) {
                          return best_len;
                        }
                        return s.lookahead;
                      }

                      /* ===========================================================================
                       * Fill the window when the lookahead becomes insufficient.
                       * Updates strstart and lookahead.
                       *
                       * IN assertion: lookahead < MIN_LOOKAHEAD
                       * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
                       *    At least one byte has been read, or avail_in == 0; reads are
                       *    performed for at least two bytes (required for the zip translate_eol
                       *    option -- not supported here).
                       */
                      function fill_window(s) {
                        var _w_size = s.w_size;
                        var p, n, m, more, str;

                        //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

                        do {
                          more = s.window_size - s.lookahead - s.strstart;

                          // JS ints have 32 bit, block below not needed
                          /* Deal with !@#$% 64K limit: */
                          //if (sizeof(int) <= 2) {
                          //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                          //        more = wsize;
                          //
                          //  } else if (more == (unsigned)(-1)) {
                          //        /* Very unlikely, but possible on 16 bit machine if
                          //         * strstart == 0 && lookahead == 1 (input done a byte at time)
                          //         */
                          //        more--;
                          //    }
                          //}

                          /* If the window is almost full and there is insufficient lookahead,
                           * move the upper half to the lower one to make room in the upper half.
                           */
                          if (
                            s.strstart >=
                            _w_size + (_w_size - MIN_LOOKAHEAD)
                          ) {
                            utils.arraySet(
                              s.window,
                              s.window,
                              _w_size,
                              _w_size,
                              0
                            );
                            s.match_start -= _w_size;
                            s.strstart -= _w_size;
                            /* we now have strstart >= MAX_DIST */
                            s.block_start -= _w_size;

                            /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

                            n = s.hash_size;
                            p = n;
                            do {
                              m = s.head[--p];
                              s.head[p] = m >= _w_size ? m - _w_size : 0;
                            } while (--n);

                            n = _w_size;
                            p = n;
                            do {
                              m = s.prev[--p];
                              s.prev[p] = m >= _w_size ? m - _w_size : 0;
                              /* If n is not on any hash chain, prev[n] is garbage but
                               * its value will never be used.
                               */
                            } while (--n);

                            more += _w_size;
                          }
                          if (s.strm.avail_in === 0) {
                            break;
                          }

                          /* If there was no sliding:
                           *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
                           *    more == window_size - lookahead - strstart
                           * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
                           * => more >= window_size - 2*WSIZE + 2
                           * In the BIG_MEM or MMAP case (not yet supported),
                           *   window_size == input_size + MIN_LOOKAHEAD  &&
                           *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
                           * Otherwise, window_size == 2*WSIZE so more >= 2.
                           * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
                           */
                          //Assert(more >= 2, "more < 2");
                          n = read_buf(
                            s.strm,
                            s.window,
                            s.strstart + s.lookahead,
                            more
                          );
                          s.lookahead += n;

                          /* Initialize the hash value now that we have some input: */
                          if (s.lookahead + s.insert >= MIN_MATCH) {
                            str = s.strstart - s.insert;
                            s.ins_h = s.window[str];

                            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                            s.ins_h =
                              ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) &
                              s.hash_mask;
                            //#if MIN_MATCH != 3
                            //        Call update_hash() MIN_MATCH-3 more times
                            //#endif
                            while (s.insert) {
                              /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                              s.ins_h =
                                ((s.ins_h << s.hash_shift) ^
                                  s.window[str + MIN_MATCH - 1]) &
                                s.hash_mask;

                              s.prev[str & s.w_mask] = s.head[s.ins_h];
                              s.head[s.ins_h] = str;
                              str++;
                              s.insert--;
                              if (s.lookahead + s.insert < MIN_MATCH) {
                                break;
                              }
                            }
                          }
                          /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
                           * but this is not important since only literal bytes will be emitted.
                           */
                        } while (
                          s.lookahead < MIN_LOOKAHEAD &&
                          s.strm.avail_in !== 0
                        );

                        /* If the WIN_INIT bytes after the end of the current data have never been
                         * written, then zero those bytes in order to avoid memory check reports of
                         * the use of uninitialized (or uninitialised as Julian writes) bytes by
                         * the longest match routines.  Update the high water mark for the next
                         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
                         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
                         */
                        //  if (s.high_water < s.window_size) {
                        //    var curr = s.strstart + s.lookahead;
                        //    var init = 0;
                        //
                        //    if (s.high_water < curr) {
                        //      /* Previous high water mark below current data -- zero WIN_INIT
                        //       * bytes or up to end of window, whichever is less.
                        //       */
                        //      init = s.window_size - curr;
                        //      if (init > WIN_INIT)
                        //        init = WIN_INIT;
                        //      zmemzero(s->window + curr, (unsigned)init);
                        //      s->high_water = curr + init;
                        //    }
                        //    else if (s->high_water < (ulg)curr + WIN_INIT) {
                        //      /* High water mark at or above current data, but below current data
                        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
                        //       * to end of window, whichever is less.
                        //       */
                        //      init = (ulg)curr + WIN_INIT - s->high_water;
                        //      if (init > s->window_size - s->high_water)
                        //        init = s->window_size - s->high_water;
                        //      zmemzero(s->window + s->high_water, (unsigned)init);
                        //      s->high_water += init;
                        //    }
                        //  }
                        //
                        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
                        //    "not enough room for search");
                      }

                      /* ===========================================================================
                       * Copy without compression as much as possible from the input stream, return
                       * the current block state.
                       * This function does not insert new strings in the dictionary since
                       * uncompressible data is probably not useful. This function is used
                       * only for the level=0 compression option.
                       * NOTE: this function should be optimized to avoid extra copying from
                       * window to pending_buf.
                       */
                      function deflate_stored(s, flush) {
                        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
                         * to pending_buf_size, and each stored block has a 5 byte header:
                         */
                        var max_block_size = 0xffff;

                        if (max_block_size > s.pending_buf_size - 5) {
                          max_block_size = s.pending_buf_size - 5;
                        }

                        /* Copy as much as possible from input to output: */
                        for (;;) {
                          /* Fill the window as much as possible: */
                          if (s.lookahead <= 1) {
                            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                            //  s->block_start >= (long)s->w_size, "slide too late");
                            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
                            //        s.block_start >= s.w_size)) {
                            //        throw  new Error("slide too late");
                            //      }

                            fill_window(s);
                            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                              return BS_NEED_MORE;
                            }

                            if (s.lookahead === 0) {
                              break;
                            }
                            /* flush the current block */
                          }
                          //Assert(s->block_start >= 0L, "block gone");
                          //    if (s.block_start < 0) throw new Error("block gone");

                          s.strstart += s.lookahead;
                          s.lookahead = 0;

                          /* Emit a stored block if pending_buf will be full: */
                          var max_start = s.block_start + max_block_size;

                          if (s.strstart === 0 || s.strstart >= max_start) {
                            /* strstart == 0 is possible when wraparound on 16-bit machine */
                            s.lookahead = s.strstart - max_start;
                            s.strstart = max_start;
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                            /***/
                          }
                          /* Flush if we may have to slide, otherwise block_start may become
                           * negative and the data will be gone:
                           */
                          if (
                            s.strstart - s.block_start >=
                            s.w_size - MIN_LOOKAHEAD
                          ) {
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                            /***/
                          }
                        }

                        s.insert = 0;

                        if (flush === Z_FINISH) {
                          /*** FLUSH_BLOCK(s, 1); ***/
                          flush_block_only(s, true);
                          if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                          }
                          /***/
                          return BS_FINISH_DONE;
                        }

                        if (s.strstart > s.block_start) {
                          /*** FLUSH_BLOCK(s, 0); ***/
                          flush_block_only(s, false);
                          if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                          }
                          /***/
                        }

                        return BS_NEED_MORE;
                      }

                      /* ===========================================================================
                       * Compress as much as possible from the input stream, return the current
                       * block state.
                       * This function does not perform lazy evaluation of matches and inserts
                       * new strings in the dictionary only for unmatched strings or for short
                       * matches. It is used only for the fast compression options.
                       */
                      function deflate_fast(s, flush) {
                        var hash_head; /* head of the hash chain */
                        var bflush; /* set if current block must be flushed */

                        for (;;) {
                          /* Make sure that we always have enough lookahead, except
                           * at the end of the input file. We need MAX_MATCH bytes
                           * for the next match, plus MIN_MATCH bytes to insert the
                           * string following the next match.
                           */
                          if (s.lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (
                              s.lookahead < MIN_LOOKAHEAD &&
                              flush === Z_NO_FLUSH
                            ) {
                              return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                              break; /* flush the current block */
                            }
                          }

                          /* Insert the string window[strstart .. strstart+2] in the
                           * dictionary, and set hash_head to the head of the hash chain:
                           */
                          hash_head = 0 /*NIL*/;
                          if (s.lookahead >= MIN_MATCH) {
                            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                            s.ins_h =
                              ((s.ins_h << s.hash_shift) ^
                                s.window[s.strstart + MIN_MATCH - 1]) &
                              s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] =
                              s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                            /***/
                          }

                          /* Find the longest match, discarding those <= prev_length.
                           * At this point we have always match_length < MIN_MATCH
                           */
                          if (
                            hash_head !== 0 /*NIL*/ &&
                            s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
                          ) {
                            /* To simplify the code, we prevent matches with the string
                             * of window index 0 (in particular we have to avoid a match
                             * of the string with itself at the start of the input file).
                             */
                            s.match_length = longest_match(s, hash_head);
                            /* longest_match() sets match_start */
                          }
                          if (s.match_length >= MIN_MATCH) {
                            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                            /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
                            bflush = trees._tr_tally(
                              s,
                              s.strstart - s.match_start,
                              s.match_length - MIN_MATCH
                            );

                            s.lookahead -= s.match_length;

                            /* Insert new strings in the hash table only if the match length
                             * is not too large. This saves time but degrades compression.
                             */
                            if (
                              s.match_length <=
                                s.max_lazy_match /*max_insert_length*/ &&
                              s.lookahead >= MIN_MATCH
                            ) {
                              s.match_length--; /* string at strstart already in table */
                              do {
                                s.strstart++;
                                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                                s.ins_h =
                                  ((s.ins_h << s.hash_shift) ^
                                    s.window[s.strstart + MIN_MATCH - 1]) &
                                  s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] =
                                  s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                                /***/
                                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                                 * always MIN_MATCH bytes ahead.
                                 */
                              } while (--s.match_length !== 0);
                              s.strstart++;
                            } else {
                              s.strstart += s.match_length;
                              s.match_length = 0;
                              s.ins_h = s.window[s.strstart];
                              /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                              s.ins_h =
                                ((s.ins_h << s.hash_shift) ^
                                  s.window[s.strstart + 1]) &
                                s.hash_mask;

                              //#if MIN_MATCH != 3
                              //                Call UPDATE_HASH() MIN_MATCH-3 more times
                              //#endif
                              /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                               * matter since it will be recomputed at next deflate call.
                               */
                            }
                          } else {
                            /* No match, output a literal byte */
                            //Tracevv((stderr,"%c", s.window[s.strstart]));
                            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                            bflush = trees._tr_tally(
                              s,
                              0,
                              s.window[s.strstart]
                            );

                            s.lookahead--;
                            s.strstart++;
                          }
                          if (bflush) {
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                            /***/
                          }
                        }
                        s.insert =
                          s.strstart < MIN_MATCH - 1
                            ? s.strstart
                            : MIN_MATCH - 1;
                        if (flush === Z_FINISH) {
                          /*** FLUSH_BLOCK(s, 1); ***/
                          flush_block_only(s, true);
                          if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                          }
                          /***/
                          return BS_FINISH_DONE;
                        }
                        if (s.last_lit) {
                          /*** FLUSH_BLOCK(s, 0); ***/
                          flush_block_only(s, false);
                          if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                          }
                          /***/
                        }
                        return BS_BLOCK_DONE;
                      }

                      /* ===========================================================================
                       * Same as above, but achieves better compression. We use a lazy
                       * evaluation for matches: a match is finally adopted only if there is
                       * no better match at the next window position.
                       */
                      function deflate_slow(s, flush) {
                        var hash_head; /* head of hash chain */
                        var bflush; /* set if current block must be flushed */

                        var max_insert;

                        /* Process the input block. */
                        for (;;) {
                          /* Make sure that we always have enough lookahead, except
                           * at the end of the input file. We need MAX_MATCH bytes
                           * for the next match, plus MIN_MATCH bytes to insert the
                           * string following the next match.
                           */
                          if (s.lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (
                              s.lookahead < MIN_LOOKAHEAD &&
                              flush === Z_NO_FLUSH
                            ) {
                              return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                              break;
                            } /* flush the current block */
                          }

                          /* Insert the string window[strstart .. strstart+2] in the
                           * dictionary, and set hash_head to the head of the hash chain:
                           */
                          hash_head = 0 /*NIL*/;
                          if (s.lookahead >= MIN_MATCH) {
                            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                            s.ins_h =
                              ((s.ins_h << s.hash_shift) ^
                                s.window[s.strstart + MIN_MATCH - 1]) &
                              s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] =
                              s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                            /***/
                          }

                          /* Find the longest match, discarding those <= prev_length.
                           */
                          s.prev_length = s.match_length;
                          s.prev_match = s.match_start;
                          s.match_length = MIN_MATCH - 1;

                          if (
                            hash_head !== 0 /*NIL*/ &&
                            s.prev_length < s.max_lazy_match &&
                            s.strstart - hash_head <=
                              s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/
                          ) {
                            /* To simplify the code, we prevent matches with the string
                             * of window index 0 (in particular we have to avoid a match
                             * of the string with itself at the start of the input file).
                             */
                            s.match_length = longest_match(s, hash_head);
                            /* longest_match() sets match_start */

                            if (
                              s.match_length <= 5 &&
                              (s.strategy === Z_FILTERED ||
                                (s.match_length === MIN_MATCH &&
                                  s.strstart - s.match_start >
                                    4096)) /*TOO_FAR*/
                            ) {
                              /* If prev_match is also MIN_MATCH, match_start is garbage
                               * but we will ignore the current match anyway.
                               */
                              s.match_length = MIN_MATCH - 1;
                            }
                          }
                          /* If there was a match at the previous step and the current
                           * match is not better, output the previous match:
                           */
                          if (
                            s.prev_length >= MIN_MATCH &&
                            s.match_length <= s.prev_length
                          ) {
                            max_insert = s.strstart + s.lookahead - MIN_MATCH;
                            /* Do not insert strings in hash table beyond this. */

                            //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
                            bflush = trees._tr_tally(
                              s,
                              s.strstart - 1 - s.prev_match,
                              s.prev_length - MIN_MATCH
                            );
                            /* Insert in hash table all strings up to the end of the match.
                             * strstart-1 and strstart are already inserted. If there is not
                             * enough lookahead, the last two strings are not inserted in
                             * the hash table.
                             */
                            s.lookahead -= s.prev_length - 1;
                            s.prev_length -= 2;
                            do {
                              if (++s.strstart <= max_insert) {
                                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                                s.ins_h =
                                  ((s.ins_h << s.hash_shift) ^
                                    s.window[s.strstart + MIN_MATCH - 1]) &
                                  s.hash_mask;
                                hash_head = s.prev[s.strstart & s.w_mask] =
                                  s.head[s.ins_h];
                                s.head[s.ins_h] = s.strstart;
                                /***/
                              }
                            } while (--s.prev_length !== 0);
                            s.match_available = 0;
                            s.match_length = MIN_MATCH - 1;
                            s.strstart++;

                            if (bflush) {
                              /*** FLUSH_BLOCK(s, 0); ***/
                              flush_block_only(s, false);
                              if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                              }
                              /***/
                            }
                          } else if (s.match_available) {
                            /* If there was no match at the previous position, output a
                             * single literal. If there was a match but the current match
                             * is longer, truncate the previous match to a single literal.
                             */
                            //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                            bflush = trees._tr_tally(
                              s,
                              0,
                              s.window[s.strstart - 1]
                            );

                            if (bflush) {
                              /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                              flush_block_only(s, false);
                              /***/
                            }
                            s.strstart++;
                            s.lookahead--;
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                          } else {
                            /* There is no previous match to compare with, wait for
                             * the next step to decide.
                             */
                            s.match_available = 1;
                            s.strstart++;
                            s.lookahead--;
                          }
                        }
                        //Assert (flush != Z_NO_FLUSH, "no flush?");
                        if (s.match_available) {
                          //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                          bflush = trees._tr_tally(
                            s,
                            0,
                            s.window[s.strstart - 1]
                          );

                          s.match_available = 0;
                        }
                        s.insert =
                          s.strstart < MIN_MATCH - 1
                            ? s.strstart
                            : MIN_MATCH - 1;
                        if (flush === Z_FINISH) {
                          /*** FLUSH_BLOCK(s, 1); ***/
                          flush_block_only(s, true);
                          if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                          }
                          /***/
                          return BS_FINISH_DONE;
                        }
                        if (s.last_lit) {
                          /*** FLUSH_BLOCK(s, 0); ***/
                          flush_block_only(s, false);
                          if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                          }
                          /***/
                        }

                        return BS_BLOCK_DONE;
                      }

                      /* ===========================================================================
                       * For Z_RLE, simply look for runs of bytes, generate matches only of distance
                       * one.  Do not maintain a hash table.  (It will be regenerated if this run of
                       * deflate switches away from Z_RLE.)
                       */
                      function deflate_rle(s, flush) {
                        var bflush; /* set if current block must be flushed */
                        var prev; /* byte at distance one to match */
                        var scan,
                          strend; /* scan goes up to strend for length of run */

                        var _win = s.window;

                        for (;;) {
                          /* Make sure that we always have enough lookahead, except
                           * at the end of the input file. We need MAX_MATCH bytes
                           * for the longest run, plus one for the unrolled loop.
                           */
                          if (s.lookahead <= MAX_MATCH) {
                            fill_window(s);
                            if (
                              s.lookahead <= MAX_MATCH &&
                              flush === Z_NO_FLUSH
                            ) {
                              return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                              break;
                            } /* flush the current block */
                          }

                          /* See how many times the previous byte repeats */
                          s.match_length = 0;
                          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                            scan = s.strstart - 1;
                            prev = _win[scan];
                            if (
                              prev === _win[++scan] &&
                              prev === _win[++scan] &&
                              prev === _win[++scan]
                            ) {
                              strend = s.strstart + MAX_MATCH;
                              do {
                                /*jshint noempty:false*/
                              } while (
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                prev === _win[++scan] &&
                                scan < strend
                              );
                              s.match_length = MAX_MATCH - (strend - scan);
                              if (s.match_length > s.lookahead) {
                                s.match_length = s.lookahead;
                              }
                            }
                            //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
                          }

                          /* Emit match if have run of MIN_MATCH or longer, else emit literal */
                          if (s.match_length >= MIN_MATCH) {
                            //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                            bflush = trees._tr_tally(
                              s,
                              1,
                              s.match_length - MIN_MATCH
                            );

                            s.lookahead -= s.match_length;
                            s.strstart += s.match_length;
                            s.match_length = 0;
                          } else {
                            /* No match, output a literal byte */
                            //Tracevv((stderr,"%c", s->window[s->strstart]));
                            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                            bflush = trees._tr_tally(
                              s,
                              0,
                              s.window[s.strstart]
                            );

                            s.lookahead--;
                            s.strstart++;
                          }
                          if (bflush) {
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                            /***/
                          }
                        }
                        s.insert = 0;
                        if (flush === Z_FINISH) {
                          /*** FLUSH_BLOCK(s, 1); ***/
                          flush_block_only(s, true);
                          if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                          }
                          /***/
                          return BS_FINISH_DONE;
                        }
                        if (s.last_lit) {
                          /*** FLUSH_BLOCK(s, 0); ***/
                          flush_block_only(s, false);
                          if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                          }
                          /***/
                        }
                        return BS_BLOCK_DONE;
                      }

                      /* ===========================================================================
                       * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
                       * (It will be regenerated if this run of deflate switches away from Huffman.)
                       */
                      function deflate_huff(s, flush) {
                        var bflush; /* set if current block must be flushed */

                        for (;;) {
                          /* Make sure that we have a literal to write. */
                          if (s.lookahead === 0) {
                            fill_window(s);
                            if (s.lookahead === 0) {
                              if (flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                              }
                              break; /* flush the current block */
                            }
                          }

                          /* Output a literal byte */
                          s.match_length = 0;
                          //Tracevv((stderr,"%c", s->window[s->strstart]));
                          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                          s.lookahead--;
                          s.strstart++;
                          if (bflush) {
                            /*** FLUSH_BLOCK(s, 0); ***/
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                              return BS_NEED_MORE;
                            }
                            /***/
                          }
                        }
                        s.insert = 0;
                        if (flush === Z_FINISH) {
                          /*** FLUSH_BLOCK(s, 1); ***/
                          flush_block_only(s, true);
                          if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                          }
                          /***/
                          return BS_FINISH_DONE;
                        }
                        if (s.last_lit) {
                          /*** FLUSH_BLOCK(s, 0); ***/
                          flush_block_only(s, false);
                          if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                          }
                          /***/
                        }
                        return BS_BLOCK_DONE;
                      }

                      /* Values for max_lazy_match, good_match and max_chain_length, depending on
                       * the desired pack level (0..9). The values given below have been tuned to
                       * exclude worst case performance for pathological files. Better values may be
                       * found for specific files.
                       */
                      function Config(
                        good_length,
                        max_lazy,
                        nice_length,
                        max_chain,
                        func
                      ) {
                        this.good_length = good_length;
                        this.max_lazy = max_lazy;
                        this.nice_length = nice_length;
                        this.max_chain = max_chain;
                        this.func = func;
                      }

                      var configuration_table;

                      configuration_table = [
                        /*      good lazy nice chain */
                        new Config(
                          0,
                          0,
                          0,
                          0,
                          deflate_stored
                        ) /* 0 store only */,
                        new Config(
                          4,
                          4,
                          8,
                          4,
                          deflate_fast
                        ) /* 1 max speed, no lazy matches */,
                        new Config(4, 5, 16, 8, deflate_fast) /* 2 */,
                        new Config(4, 6, 32, 32, deflate_fast) /* 3 */,

                        new Config(
                          4,
                          4,
                          16,
                          16,
                          deflate_slow
                        ) /* 4 lazy matches */,
                        new Config(8, 16, 32, 32, deflate_slow) /* 5 */,
                        new Config(8, 16, 128, 128, deflate_slow) /* 6 */,
                        new Config(8, 32, 128, 256, deflate_slow) /* 7 */,
                        new Config(32, 128, 258, 1024, deflate_slow) /* 8 */,
                        new Config(
                          32,
                          258,
                          258,
                          4096,
                          deflate_slow
                        ) /* 9 max compression */,
                      ];

                      /* ===========================================================================
                       * Initialize the "longest match" routines for a new zlib stream
                       */
                      function lm_init(s) {
                        s.window_size = 2 * s.w_size;

                        /*** CLEAR_HASH(s); ***/
                        zero(s.head); // Fill with NIL (= 0);

                        /* Set the default configuration parameters:
                         */
                        s.max_lazy_match =
                          configuration_table[s.level].max_lazy;
                        s.good_match = configuration_table[s.level].good_length;
                        s.nice_match = configuration_table[s.level].nice_length;
                        s.max_chain_length =
                          configuration_table[s.level].max_chain;

                        s.strstart = 0;
                        s.block_start = 0;
                        s.lookahead = 0;
                        s.insert = 0;
                        s.match_length = s.prev_length = MIN_MATCH - 1;
                        s.match_available = 0;
                        s.ins_h = 0;
                      }

                      function DeflateState() {
                        this.strm = null; /* pointer back to this zlib stream */
                        this.status = 0; /* as the name implies */
                        this.pending_buf = null; /* output still pending */
                        this.pending_buf_size = 0; /* size of pending_buf */
                        this.pending_out = 0; /* next pending byte to output to the stream */
                        this.pending = 0; /* nb of bytes in the pending buffer */
                        this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
                        this.gzhead = null; /* gzip header information to write */
                        this.gzindex = 0; /* where in extra, name, or comment */
                        this.method = Z_DEFLATED; /* can only be DEFLATED */
                        this.last_flush = -1; /* value of flush param for previous deflate call */

                        this.w_size = 0; /* LZ77 window size (32K by default) */
                        this.w_bits = 0; /* log2(w_size)  (8..16) */
                        this.w_mask = 0; /* w_size - 1 */

                        this.window = null;
                        /* Sliding window. Input bytes are read into the second half of the window,
                         * and move to the first half later to keep a dictionary of at least wSize
                         * bytes. With this organization, matches are limited to a distance of
                         * wSize-MAX_MATCH bytes, but this ensures that IO is always
                         * performed with a length multiple of the block size.
                         */

                        this.window_size = 0;
                        /* Actual size of window: 2*wSize, except when the user input buffer
                         * is directly used as sliding window.
                         */

                        this.prev = null;
                        /* Link to older string with same hash index. To limit the size of this
                         * array to 64K, this link is maintained only for the last 32K strings.
                         * An index in this array is thus a window index modulo 32K.
                         */

                        this.head = null; /* Heads of the hash chains or NIL. */

                        this.ins_h = 0; /* hash index of string to be inserted */
                        this.hash_size = 0; /* number of elements in hash table */
                        this.hash_bits = 0; /* log2(hash_size) */
                        this.hash_mask = 0; /* hash_size-1 */

                        this.hash_shift = 0;
                        /* Number of bits by which ins_h must be shifted at each input
                         * step. It must be such that after MIN_MATCH steps, the oldest
                         * byte no longer takes part in the hash key, that is:
                         *   hash_shift * MIN_MATCH >= hash_bits
                         */

                        this.block_start = 0;
                        /* Window position at the beginning of the current output block. Gets
                         * negative when the window is moved backwards.
                         */

                        this.match_length = 0; /* length of best match */
                        this.prev_match = 0; /* previous match */
                        this.match_available = 0; /* set if previous match exists */
                        this.strstart = 0; /* start of string to insert */
                        this.match_start = 0; /* start of matching string */
                        this.lookahead = 0; /* number of valid bytes ahead in window */

                        this.prev_length = 0;
                        /* Length of the best match at previous step. Matches not greater than this
                         * are discarded. This is used in the lazy match evaluation.
                         */

                        this.max_chain_length = 0;
                        /* To speed up deflation, hash chains are never searched beyond this
                         * length.  A higher limit improves compression ratio but degrades the
                         * speed.
                         */

                        this.max_lazy_match = 0;
                        /* Attempt to find a better match only when the current match is strictly
                         * smaller than this value. This mechanism is used only for compression
                         * levels >= 4.
                         */
                        // That's alias to max_lazy_match, don't use directly
                        //this.max_insert_length = 0;
                        /* Insert new strings in the hash table only if the match length is not
                         * greater than this length. This saves time but degrades compression.
                         * max_insert_length is used only for compression levels <= 3.
                         */

                        this.level = 0; /* compression level (1..9) */
                        this.strategy = 0; /* favor or force Huffman coding*/

                        this.good_match = 0;
                        /* Use a faster search when the previous match is longer than this */

                        this.nice_match = 0; /* Stop searching when current match exceeds this */

                        /* used by trees.c: */

                        /* Didn't use ct_data typedef below to suppress compiler warning */

                        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
                        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
                        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

                        // Use flat array of DOUBLE size, with interleaved fata,
                        // because JS does not support effective
                        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                        zero(this.dyn_ltree);
                        zero(this.dyn_dtree);
                        zero(this.bl_tree);

                        this.l_desc = null; /* desc. for literal tree */
                        this.d_desc = null; /* desc. for distance tree */
                        this.bl_desc = null; /* desc. for bit length tree */

                        //ush bl_count[MAX_BITS+1];
                        this.bl_count = new utils.Buf16(MAX_BITS + 1);
                        /* number of codes at each bit length for an optimal tree */

                        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
                        this.heap = new utils.Buf16(
                          2 * L_CODES + 1
                        ); /* heap used to build the Huffman trees */
                        zero(this.heap);

                        this.heap_len = 0; /* number of elements in the heap */
                        this.heap_max = 0; /* element of largest frequency */
                        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
                         * The same heap array is used to build all trees.
                         */

                        this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
                        zero(this.depth);
                        /* Depth of each subtree used as tie breaker for trees of equal frequency
                         */

                        this.l_buf = 0; /* buffer index for literals or lengths */

                        this.lit_bufsize = 0;
                        /* Size of match buffer for literals/lengths.  There are 4 reasons for
                         * limiting lit_bufsize to 64K:
                         *   - frequencies can be kept in 16 bit counters
                         *   - if compression is not successful for the first block, all input
                         *     data is still in the window so we can still emit a stored block even
                         *     when input comes from standard input.  (This can also be done for
                         *     all blocks if lit_bufsize is not greater than 32K.)
                         *   - if compression is not successful for a file smaller than 64K, we can
                         *     even emit a stored file instead of a stored block (saving 5 bytes).
                         *     This is applicable only for zip (not gzip or zlib).
                         *   - creating new Huffman trees less frequently may not provide fast
                         *     adaptation to changes in the input data statistics. (Take for
                         *     example a binary file with poorly compressible code followed by
                         *     a highly compressible string table.) Smaller buffer sizes give
                         *     fast adaptation but have of course the overhead of transmitting
                         *     trees more frequently.
                         *   - I can't count above 4
                         */

                        this.last_lit = 0; /* running index in l_buf */

                        this.d_buf = 0;
                        /* Buffer index for distances. To simplify the code, d_buf and l_buf have
                         * the same number of elements. To use different lengths, an extra flag
                         * array would be necessary.
                         */

                        this.opt_len = 0; /* bit length of current block with optimal trees */
                        this.static_len = 0; /* bit length of current block with static trees */
                        this.matches = 0; /* number of string matches in current block */
                        this.insert = 0; /* bytes at end of window left to insert */

                        this.bi_buf = 0;
                        /* Output buffer. bits are inserted starting at the bottom (least
                         * significant bits).
                         */
                        this.bi_valid = 0;
                        /* Number of valid bits in bi_buf.  All bits above the last valid bit
                         * are always zero.
                         */

                        // Used for window memory init. We safely ignore it for JS. That makes
                        // sense only for pointers and memory check tools.
                        //this.high_water = 0;
                        /* High water mark offset in window for initialized bytes -- bytes above
                         * this are set to zero in order to avoid memory check warnings when
                         * longest match routines access bytes past the input.  This is then
                         * updated to the new high water mark.
                         */
                      }

                      function deflateResetKeep(strm) {
                        var s;

                        if (!strm || !strm.state) {
                          return err(strm, Z_STREAM_ERROR);
                        }

                        strm.total_in = strm.total_out = 0;
                        strm.data_type = Z_UNKNOWN;

                        s = strm.state;
                        s.pending = 0;
                        s.pending_out = 0;

                        if (s.wrap < 0) {
                          s.wrap = -s.wrap;
                          /* was made negative by deflate(..., Z_FINISH); */
                        }
                        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
                        strm.adler =
                          s.wrap === 2
                            ? 0 // crc32(0, Z_NULL, 0)
                            : 1; // adler32(0, Z_NULL, 0)
                        s.last_flush = Z_NO_FLUSH;
                        trees._tr_init(s);
                        return Z_OK;
                      }

                      function deflateReset(strm) {
                        var ret = deflateResetKeep(strm);
                        if (ret === Z_OK) {
                          lm_init(strm.state);
                        }
                        return ret;
                      }

                      function deflateSetHeader(strm, head) {
                        if (!strm || !strm.state) {
                          return Z_STREAM_ERROR;
                        }
                        if (strm.state.wrap !== 2) {
                          return Z_STREAM_ERROR;
                        }
                        strm.state.gzhead = head;
                        return Z_OK;
                      }

                      function deflateInit2(
                        strm,
                        level,
                        method,
                        windowBits,
                        memLevel,
                        strategy
                      ) {
                        if (!strm) {
                          // === Z_NULL
                          return Z_STREAM_ERROR;
                        }
                        var wrap = 1;

                        if (level === Z_DEFAULT_COMPRESSION) {
                          level = 6;
                        }

                        if (windowBits < 0) {
                          /* suppress zlib wrapper */
                          wrap = 0;
                          windowBits = -windowBits;
                        } else if (windowBits > 15) {
                          wrap = 2; /* write gzip wrapper instead */
                          windowBits -= 16;
                        }

                        if (
                          memLevel < 1 ||
                          memLevel > MAX_MEM_LEVEL ||
                          method !== Z_DEFLATED ||
                          windowBits < 8 ||
                          windowBits > 15 ||
                          level < 0 ||
                          level > 9 ||
                          strategy < 0 ||
                          strategy > Z_FIXED
                        ) {
                          return err(strm, Z_STREAM_ERROR);
                        }

                        if (windowBits === 8) {
                          windowBits = 9;
                        }
                        /* until 256-byte window bug fixed */

                        var s = new DeflateState();

                        strm.state = s;
                        s.strm = strm;

                        s.wrap = wrap;
                        s.gzhead = null;
                        s.w_bits = windowBits;
                        s.w_size = 1 << s.w_bits;
                        s.w_mask = s.w_size - 1;

                        s.hash_bits = memLevel + 7;
                        s.hash_size = 1 << s.hash_bits;
                        s.hash_mask = s.hash_size - 1;
                        s.hash_shift = ~~(
                          (s.hash_bits + MIN_MATCH - 1) /
                          MIN_MATCH
                        );

                        s.window = new utils.Buf8(s.w_size * 2);
                        s.head = new utils.Buf16(s.hash_size);
                        s.prev = new utils.Buf16(s.w_size);

                        // Don't need mem init magic for JS.
                        //s.high_water = 0;  /* nothing written to s->window yet */

                        s.lit_bufsize =
                          1 << (memLevel + 6); /* 16K elements by default */

                        s.pending_buf_size = s.lit_bufsize * 4;

                        //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
                        //s->pending_buf = (uchf *) overlay;
                        s.pending_buf = new utils.Buf8(s.pending_buf_size);

                        // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
                        //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
                        s.d_buf = 1 * s.lit_bufsize;

                        //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
                        s.l_buf = (1 + 2) * s.lit_bufsize;

                        s.level = level;
                        s.strategy = strategy;
                        s.method = method;

                        return deflateReset(strm);
                      }

                      function deflateInit(strm, level) {
                        return deflateInit2(
                          strm,
                          level,
                          Z_DEFLATED,
                          MAX_WBITS,
                          DEF_MEM_LEVEL,
                          Z_DEFAULT_STRATEGY
                        );
                      }

                      function deflate(strm, flush) {
                        var old_flush, s;
                        var beg, val; // for gzip header write only

                        if (
                          !strm ||
                          !strm.state ||
                          flush > Z_BLOCK ||
                          flush < 0
                        ) {
                          return strm
                            ? err(strm, Z_STREAM_ERROR)
                            : Z_STREAM_ERROR;
                        }

                        s = strm.state;

                        if (
                          !strm.output ||
                          (!strm.input && strm.avail_in !== 0) ||
                          (s.status === FINISH_STATE && flush !== Z_FINISH)
                        ) {
                          return err(
                            strm,
                            strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR
                          );
                        }

                        s.strm = strm; /* just in case */
                        old_flush = s.last_flush;
                        s.last_flush = flush;

                        /* Write the header */
                        if (s.status === INIT_STATE) {
                          if (s.wrap === 2) {
                            // GZIP header
                            strm.adler = 0; //crc32(0L, Z_NULL, 0);
                            put_byte(s, 31);
                            put_byte(s, 139);
                            put_byte(s, 8);
                            if (!s.gzhead) {
                              // s->gzhead == Z_NULL
                              put_byte(s, 0);
                              put_byte(s, 0);
                              put_byte(s, 0);
                              put_byte(s, 0);
                              put_byte(s, 0);
                              put_byte(
                                s,
                                s.level === 9
                                  ? 2
                                  : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                                  ? 4
                                  : 0
                              );
                              put_byte(s, OS_CODE);
                              s.status = BUSY_STATE;
                            } else {
                              put_byte(
                                s,
                                (s.gzhead.text ? 1 : 0) +
                                  (s.gzhead.hcrc ? 2 : 0) +
                                  (!s.gzhead.extra ? 0 : 4) +
                                  (!s.gzhead.name ? 0 : 8) +
                                  (!s.gzhead.comment ? 0 : 16)
                              );
                              put_byte(s, s.gzhead.time & 0xff);
                              put_byte(s, (s.gzhead.time >> 8) & 0xff);
                              put_byte(s, (s.gzhead.time >> 16) & 0xff);
                              put_byte(s, (s.gzhead.time >> 24) & 0xff);
                              put_byte(
                                s,
                                s.level === 9
                                  ? 2
                                  : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                                  ? 4
                                  : 0
                              );
                              put_byte(s, s.gzhead.os & 0xff);
                              if (s.gzhead.extra && s.gzhead.extra.length) {
                                put_byte(s, s.gzhead.extra.length & 0xff);
                                put_byte(
                                  s,
                                  (s.gzhead.extra.length >> 8) & 0xff
                                );
                              }
                              if (s.gzhead.hcrc) {
                                strm.adler = crc32(
                                  strm.adler,
                                  s.pending_buf,
                                  s.pending,
                                  0
                                );
                              }
                              s.gzindex = 0;
                              s.status = EXTRA_STATE;
                            }
                          } // DEFLATE header
                          else {
                            var header =
                              (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                            var level_flags = -1;

                            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                              level_flags = 0;
                            } else if (s.level < 6) {
                              level_flags = 1;
                            } else if (s.level === 6) {
                              level_flags = 2;
                            } else {
                              level_flags = 3;
                            }
                            header |= level_flags << 6;
                            if (s.strstart !== 0) {
                              header |= PRESET_DICT;
                            }
                            header += 31 - (header % 31);

                            s.status = BUSY_STATE;
                            putShortMSB(s, header);

                            /* Save the adler32 of the preset dictionary: */
                            if (s.strstart !== 0) {
                              putShortMSB(s, strm.adler >>> 16);
                              putShortMSB(s, strm.adler & 0xffff);
                            }
                            strm.adler = 1; // adler32(0L, Z_NULL, 0);
                          }
                        }

                        //#ifdef GZIP
                        if (s.status === EXTRA_STATE) {
                          if (s.gzhead.extra /* != Z_NULL*/) {
                            beg = s.pending; /* start of bytes to update crc */

                            while (
                              s.gzindex <
                              (s.gzhead.extra.length & 0xffff)
                            ) {
                              if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                  strm.adler = crc32(
                                    strm.adler,
                                    s.pending_buf,
                                    s.pending - beg,
                                    beg
                                  );
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                  break;
                                }
                              }
                              put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                              s.gzindex++;
                            }
                            if (s.gzhead.hcrc && s.pending > beg) {
                              strm.adler = crc32(
                                strm.adler,
                                s.pending_buf,
                                s.pending - beg,
                                beg
                              );
                            }
                            if (s.gzindex === s.gzhead.extra.length) {
                              s.gzindex = 0;
                              s.status = NAME_STATE;
                            }
                          } else {
                            s.status = NAME_STATE;
                          }
                        }
                        if (s.status === NAME_STATE) {
                          if (s.gzhead.name /* != Z_NULL*/) {
                            beg = s.pending; /* start of bytes to update crc */
                            //int val;

                            do {
                              if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                  strm.adler = crc32(
                                    strm.adler,
                                    s.pending_buf,
                                    s.pending - beg,
                                    beg
                                  );
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                  val = 1;
                                  break;
                                }
                              }
                              // JS specific: little magic to add zero terminator to end of string
                              if (s.gzindex < s.gzhead.name.length) {
                                val =
                                  s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                              } else {
                                val = 0;
                              }
                              put_byte(s, val);
                            } while (val !== 0);

                            if (s.gzhead.hcrc && s.pending > beg) {
                              strm.adler = crc32(
                                strm.adler,
                                s.pending_buf,
                                s.pending - beg,
                                beg
                              );
                            }
                            if (val === 0) {
                              s.gzindex = 0;
                              s.status = COMMENT_STATE;
                            }
                          } else {
                            s.status = COMMENT_STATE;
                          }
                        }
                        if (s.status === COMMENT_STATE) {
                          if (s.gzhead.comment /* != Z_NULL*/) {
                            beg = s.pending; /* start of bytes to update crc */
                            //int val;

                            do {
                              if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg) {
                                  strm.adler = crc32(
                                    strm.adler,
                                    s.pending_buf,
                                    s.pending - beg,
                                    beg
                                  );
                                }
                                flush_pending(strm);
                                beg = s.pending;
                                if (s.pending === s.pending_buf_size) {
                                  val = 1;
                                  break;
                                }
                              }
                              // JS specific: little magic to add zero terminator to end of string
                              if (s.gzindex < s.gzhead.comment.length) {
                                val =
                                  s.gzhead.comment.charCodeAt(s.gzindex++) &
                                  0xff;
                              } else {
                                val = 0;
                              }
                              put_byte(s, val);
                            } while (val !== 0);

                            if (s.gzhead.hcrc && s.pending > beg) {
                              strm.adler = crc32(
                                strm.adler,
                                s.pending_buf,
                                s.pending - beg,
                                beg
                              );
                            }
                            if (val === 0) {
                              s.status = HCRC_STATE;
                            }
                          } else {
                            s.status = HCRC_STATE;
                          }
                        }
                        if (s.status === HCRC_STATE) {
                          if (s.gzhead.hcrc) {
                            if (s.pending + 2 > s.pending_buf_size) {
                              flush_pending(strm);
                            }
                            if (s.pending + 2 <= s.pending_buf_size) {
                              put_byte(s, strm.adler & 0xff);
                              put_byte(s, (strm.adler >> 8) & 0xff);
                              strm.adler = 0; //crc32(0L, Z_NULL, 0);
                              s.status = BUSY_STATE;
                            }
                          } else {
                            s.status = BUSY_STATE;
                          }
                        }
                        //#endif

                        /* Flush as much pending output as possible */
                        if (s.pending !== 0) {
                          flush_pending(strm);
                          if (strm.avail_out === 0) {
                            /* Since avail_out is 0, deflate will be called again with
                             * more output space, but possibly with both pending and
                             * avail_in equal to zero. There won't be anything to do,
                             * but this is not an error situation so make sure we
                             * return OK instead of BUF_ERROR at next call of deflate:
                             */
                            s.last_flush = -1;
                            return Z_OK;
                          }

                          /* Make sure there is something to do and avoid duplicate consecutive
                           * flushes. For repeated and useless calls with Z_FINISH, we keep
                           * returning Z_STREAM_END instead of Z_BUF_ERROR.
                           */
                        } else if (
                          strm.avail_in === 0 &&
                          rank(flush) <= rank(old_flush) &&
                          flush !== Z_FINISH
                        ) {
                          return err(strm, Z_BUF_ERROR);
                        }

                        /* User must not provide more input after the first FINISH: */
                        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                          return err(strm, Z_BUF_ERROR);
                        }

                        /* Start a new block or continue the current one.
                         */
                        if (
                          strm.avail_in !== 0 ||
                          s.lookahead !== 0 ||
                          (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)
                        ) {
                          var bstate =
                            s.strategy === Z_HUFFMAN_ONLY
                              ? deflate_huff(s, flush)
                              : s.strategy === Z_RLE
                              ? deflate_rle(s, flush)
                              : configuration_table[s.level].func(s, flush);

                          if (
                            bstate === BS_FINISH_STARTED ||
                            bstate === BS_FINISH_DONE
                          ) {
                            s.status = FINISH_STATE;
                          }
                          if (
                            bstate === BS_NEED_MORE ||
                            bstate === BS_FINISH_STARTED
                          ) {
                            if (strm.avail_out === 0) {
                              s.last_flush = -1;
                              /* avoid BUF_ERROR next call, see above */
                            }
                            return Z_OK;
                            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                             * of deflate should use the same flush parameter to make sure
                             * that the flush is complete. So we don't have to output an
                             * empty block here, this will be done at next call. This also
                             * ensures that for a very small output buffer, we emit at most
                             * one empty block.
                             */
                          }
                          if (bstate === BS_BLOCK_DONE) {
                            if (flush === Z_PARTIAL_FLUSH) {
                              trees._tr_align(s);
                            } else if (flush !== Z_BLOCK) {
                              /* FULL_FLUSH or SYNC_FLUSH */

                              trees._tr_stored_block(s, 0, 0, false);
                              /* For a full flush, this empty block will be recognized
                               * as a special marker by inflate_sync().
                               */
                              if (flush === Z_FULL_FLUSH) {
                                /*** CLEAR_HASH(s); ***/ /* forget history */
                                zero(s.head); // Fill with NIL (= 0);

                                if (s.lookahead === 0) {
                                  s.strstart = 0;
                                  s.block_start = 0;
                                  s.insert = 0;
                                }
                              }
                            }
                            flush_pending(strm);
                            if (strm.avail_out === 0) {
                              s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                              return Z_OK;
                            }
                          }
                        }
                        //Assert(strm->avail_out > 0, "bug2");
                        //if (strm.avail_out <= 0) { throw new Error("bug2");}

                        if (flush !== Z_FINISH) {
                          return Z_OK;
                        }
                        if (s.wrap <= 0) {
                          return Z_STREAM_END;
                        }

                        /* Write the trailer */
                        if (s.wrap === 2) {
                          put_byte(s, strm.adler & 0xff);
                          put_byte(s, (strm.adler >> 8) & 0xff);
                          put_byte(s, (strm.adler >> 16) & 0xff);
                          put_byte(s, (strm.adler >> 24) & 0xff);
                          put_byte(s, strm.total_in & 0xff);
                          put_byte(s, (strm.total_in >> 8) & 0xff);
                          put_byte(s, (strm.total_in >> 16) & 0xff);
                          put_byte(s, (strm.total_in >> 24) & 0xff);
                        } else {
                          putShortMSB(s, strm.adler >>> 16);
                          putShortMSB(s, strm.adler & 0xffff);
                        }

                        flush_pending(strm);
                        /* If avail_out is zero, the application will call deflate again
                         * to flush the rest.
                         */
                        if (s.wrap > 0) {
                          s.wrap = -s.wrap;
                        }
                        /* write the trailer only once! */
                        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
                      }

                      function deflateEnd(strm) {
                        var status;

                        if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
                          return Z_STREAM_ERROR;
                        }

                        status = strm.state.status;
                        if (
                          status !== INIT_STATE &&
                          status !== EXTRA_STATE &&
                          status !== NAME_STATE &&
                          status !== COMMENT_STATE &&
                          status !== HCRC_STATE &&
                          status !== BUSY_STATE &&
                          status !== FINISH_STATE
                        ) {
                          return err(strm, Z_STREAM_ERROR);
                        }

                        strm.state = null;

                        return status === BUSY_STATE
                          ? err(strm, Z_DATA_ERROR)
                          : Z_OK;
                      }

                      /* =========================================================================
                       * Initializes the compression dictionary from the given byte
                       * sequence without producing any compressed output.
                       */
                      function deflateSetDictionary(strm, dictionary) {
                        var dictLength = dictionary.length;

                        var s;
                        var str, n;
                        var wrap;
                        var avail;
                        var next;
                        var input;
                        var tmpDict;

                        if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
                          return Z_STREAM_ERROR;
                        }

                        s = strm.state;
                        wrap = s.wrap;

                        if (
                          wrap === 2 ||
                          (wrap === 1 && s.status !== INIT_STATE) ||
                          s.lookahead
                        ) {
                          return Z_STREAM_ERROR;
                        }

                        /* when using zlib wrappers, compute Adler-32 for provided dictionary */
                        if (wrap === 1) {
                          /* adler32(strm->adler, dictionary, dictLength); */
                          strm.adler = adler32(
                            strm.adler,
                            dictionary,
                            dictLength,
                            0
                          );
                        }

                        s.wrap = 0; /* avoid computing Adler-32 in read_buf */

                        /* if dictionary would fill window, just replace the history */
                        if (dictLength >= s.w_size) {
                          if (wrap === 0) {
                            /* already empty otherwise */
                            /*** CLEAR_HASH(s); ***/
                            zero(s.head); // Fill with NIL (= 0);
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                          }
                          /* use the tail */
                          // dictionary = dictionary.slice(dictLength - s.w_size);
                          tmpDict = new utils.Buf8(s.w_size);
                          utils.arraySet(
                            tmpDict,
                            dictionary,
                            dictLength - s.w_size,
                            s.w_size,
                            0
                          );
                          dictionary = tmpDict;
                          dictLength = s.w_size;
                        }
                        /* insert dictionary into window and hash */
                        avail = strm.avail_in;
                        next = strm.next_in;
                        input = strm.input;
                        strm.avail_in = dictLength;
                        strm.next_in = 0;
                        strm.input = dictionary;
                        fill_window(s);
                        while (s.lookahead >= MIN_MATCH) {
                          str = s.strstart;
                          n = s.lookahead - (MIN_MATCH - 1);
                          do {
                            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                            s.ins_h =
                              ((s.ins_h << s.hash_shift) ^
                                s.window[str + MIN_MATCH - 1]) &
                              s.hash_mask;

                            s.prev[str & s.w_mask] = s.head[s.ins_h];

                            s.head[s.ins_h] = str;
                            str++;
                          } while (--n);
                          s.strstart = str;
                          s.lookahead = MIN_MATCH - 1;
                          fill_window(s);
                        }
                        s.strstart += s.lookahead;
                        s.block_start = s.strstart;
                        s.insert = s.lookahead;
                        s.lookahead = 0;
                        s.match_length = s.prev_length = MIN_MATCH - 1;
                        s.match_available = 0;
                        strm.next_in = next;
                        strm.input = input;
                        strm.avail_in = avail;
                        s.wrap = wrap;
                        return Z_OK;
                      }

                      exports.deflateInit = deflateInit;
                      exports.deflateInit2 = deflateInit2;
                      exports.deflateReset = deflateReset;
                      exports.deflateResetKeep = deflateResetKeep;
                      exports.deflateSetHeader = deflateSetHeader;
                      exports.deflate = deflate;
                      exports.deflateEnd = deflateEnd;
                      exports.deflateSetDictionary = deflateSetDictionary;
                      exports.deflateInfo =
                        'pako deflate (from Nodeca project)';

                      /* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/
                    },
                    {
                      '../utils/common': 1,
                      './adler32': 3,
                      './crc32': 4,
                      './messages': 6,
                      './trees': 7,
                    },
                  ],
                  6: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      module.exports = {
                        2: 'need dictionary' /* Z_NEED_DICT       2  */,
                        1: 'stream end' /* Z_STREAM_END      1  */,
                        0: '' /* Z_OK              0  */,
                        '-1': 'file error' /* Z_ERRNO         (-1) */,
                        '-2': 'stream error' /* Z_STREAM_ERROR  (-2) */,
                        '-3': 'data error' /* Z_DATA_ERROR    (-3) */,
                        '-4': 'insufficient memory' /* Z_MEM_ERROR     (-4) */,
                        '-5': 'buffer error' /* Z_BUF_ERROR     (-5) */,
                        '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */,
                      };
                    },
                    {},
                  ],
                  7: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      /* eslint-disable space-unary-ops */

                      var utils = require('../utils/common');

                      /* Public constants ==========================================================*/
                      /* ===========================================================================*/

                      //var Z_FILTERED          = 1;
                      //var Z_HUFFMAN_ONLY      = 2;
                      //var Z_RLE               = 3;
                      var Z_FIXED = 4;
                      //var Z_DEFAULT_STRATEGY  = 0;

                      /* Possible values of the data_type field (though see inflate()) */
                      var Z_BINARY = 0;
                      var Z_TEXT = 1;
                      //var Z_ASCII             = 1; // = Z_TEXT
                      var Z_UNKNOWN = 2;

                      /*============================================================================*/

                      function zero(buf) {
                        var len = buf.length;
                        while (--len >= 0) {
                          buf[len] = 0;
                        }
                      }

                      // From zutil.h

                      var STORED_BLOCK = 0;
                      var STATIC_TREES = 1;
                      var DYN_TREES = 2;
                      /* The three kinds of block type */

                      var MIN_MATCH = 3;
                      var MAX_MATCH = 258;
                      /* The minimum and maximum match lengths */

                      // From deflate.h
                      /* ===========================================================================
                       * Internal compression state.
                       */

                      var LENGTH_CODES = 29;
                      /* number of length codes, not counting the special END_BLOCK code */

                      var LITERALS = 256;
                      /* number of literal bytes 0..255 */

                      var L_CODES = LITERALS + 1 + LENGTH_CODES;
                      /* number of Literal or Length codes, including the END_BLOCK code */

                      var D_CODES = 30;
                      /* number of distance codes */

                      var BL_CODES = 19;
                      /* number of codes used to transfer the bit lengths */

                      var HEAP_SIZE = 2 * L_CODES + 1;
                      /* maximum heap size */

                      var MAX_BITS = 15;
                      /* All codes must not exceed MAX_BITS bits */

                      var Buf_size = 16;
                      /* size of bit buffer in bi_buf */

                      /* ===========================================================================
                       * Constants
                       */

                      var MAX_BL_BITS = 7;
                      /* Bit length codes must not exceed MAX_BL_BITS bits */

                      var END_BLOCK = 256;
                      /* end of block literal code */

                      var REP_3_6 = 16;
                      /* repeat previous bit length 3-6 times (2 bits of repeat count) */

                      var REPZ_3_10 = 17;
                      /* repeat a zero length 3-10 times  (3 bits of repeat count) */

                      var REPZ_11_138 = 18;
                      /* repeat a zero length 11-138 times  (7 bits of repeat count) */

                      /* eslint-disable comma-spacing,array-bracket-spacing */
                      var extra_lbits =
                        /* extra bits for each length code */
                        [
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          1,
                          1,
                          1,
                          1,
                          2,
                          2,
                          2,
                          2,
                          3,
                          3,
                          3,
                          3,
                          4,
                          4,
                          4,
                          4,
                          5,
                          5,
                          5,
                          5,
                          0,
                        ];

                      var extra_dbits =
                        /* extra bits for each distance code */
                        [
                          0,
                          0,
                          0,
                          0,
                          1,
                          1,
                          2,
                          2,
                          3,
                          3,
                          4,
                          4,
                          5,
                          5,
                          6,
                          6,
                          7,
                          7,
                          8,
                          8,
                          9,
                          9,
                          10,
                          10,
                          11,
                          11,
                          12,
                          12,
                          13,
                          13,
                        ];

                      var extra_blbits =
                        /* extra bits for each bit length code */
                        [
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          2,
                          3,
                          7,
                        ];

                      var bl_order = [
                        16,
                        17,
                        18,
                        0,
                        8,
                        7,
                        9,
                        6,
                        10,
                        5,
                        11,
                        4,
                        12,
                        3,
                        13,
                        2,
                        14,
                        1,
                        15,
                      ];
                      /* eslint-enable comma-spacing,array-bracket-spacing */

                      /* The lengths of the bit length codes are sent in order of decreasing
                       * probability, to avoid transmitting the lengths for unused bit length codes.
                       */

                      /* ===========================================================================
                       * Local data. These are initialized only once.
                       */

                      // We pre-fill arrays with 0 to avoid uninitialized gaps

                      var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

                      // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
                      var static_ltree = new Array((L_CODES + 2) * 2);
                      zero(static_ltree);
                      /* The static literal tree. Since the bit lengths are imposed, there is no
                       * need for the L_CODES extra codes used during heap construction. However
                       * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
                       * below).
                       */

                      var static_dtree = new Array(D_CODES * 2);
                      zero(static_dtree);
                      /* The static distance tree. (Actually a trivial tree since all codes use
                       * 5 bits.)
                       */

                      var _dist_code = new Array(DIST_CODE_LEN);
                      zero(_dist_code);
                      /* Distance codes. The first 256 values correspond to the distances
                       * 3 .. 258, the last 256 values correspond to the top 8 bits of
                       * the 15 bit distances.
                       */

                      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
                      zero(_length_code);
                      /* length code for each normalized match length (0 == MIN_MATCH) */

                      var base_length = new Array(LENGTH_CODES);
                      zero(base_length);
                      /* First normalized length for each code (0 = MIN_MATCH) */

                      var base_dist = new Array(D_CODES);
                      zero(base_dist);
                      /* First normalized distance for each code (0 = distance of 1) */

                      function StaticTreeDesc(
                        static_tree,
                        extra_bits,
                        extra_base,
                        elems,
                        max_length
                      ) {
                        this.static_tree = static_tree; /* static tree or NULL */
                        this.extra_bits = extra_bits; /* extra bits for each code or NULL */
                        this.extra_base = extra_base; /* base index for extra_bits */
                        this.elems = elems; /* max number of elements in the tree */
                        this.max_length = max_length; /* max bit length for the codes */

                        // show if `static_tree` has data or dummy - needed for monomorphic objects
                        this.has_stree = static_tree && static_tree.length;
                      }

                      var static_l_desc;
                      var static_d_desc;
                      var static_bl_desc;

                      function TreeDesc(dyn_tree, stat_desc) {
                        this.dyn_tree = dyn_tree; /* the dynamic tree */
                        this.max_code = 0; /* largest code with non zero frequency */
                        this.stat_desc = stat_desc; /* the corresponding static tree */
                      }

                      function d_code(dist) {
                        return dist < 256
                          ? _dist_code[dist]
                          : _dist_code[256 + (dist >>> 7)];
                      }

                      /* ===========================================================================
                       * Output a short LSB first on the stream.
                       * IN assertion: there is enough room in pendingBuf.
                       */
                      function put_short(s, w) {
                        //    put_byte(s, (uch)((w) & 0xff));
                        //    put_byte(s, (uch)((ush)(w) >> 8));
                        s.pending_buf[s.pending++] = w & 0xff;
                        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
                      }

                      /* ===========================================================================
                       * Send a value on a given number of bits.
                       * IN assertion: length <= 16 and value fits in length bits.
                       */
                      function send_bits(s, value, length) {
                        if (s.bi_valid > Buf_size - length) {
                          s.bi_buf |= (value << s.bi_valid) & 0xffff;
                          put_short(s, s.bi_buf);
                          s.bi_buf = value >> (Buf_size - s.bi_valid);
                          s.bi_valid += length - Buf_size;
                        } else {
                          s.bi_buf |= (value << s.bi_valid) & 0xffff;
                          s.bi_valid += length;
                        }
                      }

                      function send_code(s, c, tree) {
                        send_bits(
                          s,
                          tree[c * 2] /*.Code*/,
                          tree[c * 2 + 1] /*.Len*/
                        );
                      }

                      /* ===========================================================================
                       * Reverse the first len bits of a code, using straightforward code (a faster
                       * method would use a table)
                       * IN assertion: 1 <= len <= 15
                       */
                      function bi_reverse(code, len) {
                        var res = 0;
                        do {
                          res |= code & 1;
                          code >>>= 1;
                          res <<= 1;
                        } while (--len > 0);
                        return res >>> 1;
                      }

                      /* ===========================================================================
                       * Flush the bit buffer, keeping at most 7 bits in it.
                       */
                      function bi_flush(s) {
                        if (s.bi_valid === 16) {
                          put_short(s, s.bi_buf);
                          s.bi_buf = 0;
                          s.bi_valid = 0;
                        } else if (s.bi_valid >= 8) {
                          s.pending_buf[s.pending++] = s.bi_buf & 0xff;
                          s.bi_buf >>= 8;
                          s.bi_valid -= 8;
                        }
                      }

                      /* ===========================================================================
                       * Compute the optimal bit lengths for a tree and update the total bit length
                       * for the current block.
                       * IN assertion: the fields freq and dad are set, heap[heap_max] and
                       *    above are the tree nodes sorted by increasing frequency.
                       * OUT assertions: the field len is set to the optimal bit length, the
                       *     array bl_count contains the frequencies for each bit length.
                       *     The length opt_len is updated; static_len is also updated if stree is
                       *     not null.
                       */
                      function gen_bitlen(s, desc) {
                        //    deflate_state *s;
                        //    tree_desc *desc;    /* the tree descriptor */
                        var tree = desc.dyn_tree;
                        var max_code = desc.max_code;
                        var stree = desc.stat_desc.static_tree;
                        var has_stree = desc.stat_desc.has_stree;
                        var extra = desc.stat_desc.extra_bits;
                        var base = desc.stat_desc.extra_base;
                        var max_length = desc.stat_desc.max_length;
                        var h; /* heap index */
                        var n, m; /* iterate over the tree elements */
                        var bits; /* bit length */
                        var xbits; /* extra bits */
                        var f; /* frequency */
                        var overflow = 0; /* number of elements with bit length too large */

                        for (bits = 0; bits <= MAX_BITS; bits++) {
                          s.bl_count[bits] = 0;
                        }

                        /* In a first pass, compute the optimal bit lengths (which may
                         * overflow in the case of the bit length tree).
                         */
                        tree[
                          s.heap[s.heap_max] * 2 + 1
                        ] /*.Len*/ = 0; /* root of the heap */

                        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                          n = s.heap[h];
                          bits =
                            tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
                          if (bits > max_length) {
                            bits = max_length;
                            overflow++;
                          }
                          tree[n * 2 + 1] /*.Len*/ = bits;
                          /* We overwrite tree[n].Dad which is no longer needed */

                          if (n > max_code) {
                            continue;
                          } /* not a leaf node */

                          s.bl_count[bits]++;
                          xbits = 0;
                          if (n >= base) {
                            xbits = extra[n - base];
                          }
                          f = tree[n * 2] /*.Freq*/;
                          s.opt_len += f * (bits + xbits);
                          if (has_stree) {
                            s.static_len +=
                              f * (stree[n * 2 + 1] /*.Len*/ + xbits);
                          }
                        }
                        if (overflow === 0) {
                          return;
                        }

                        // Trace((stderr,"\nbit length overflow\n"));
                        /* This happens for example on obj2 and pic of the Calgary corpus */

                        /* Find the first bit length which could increase: */
                        do {
                          bits = max_length - 1;
                          while (s.bl_count[bits] === 0) {
                            bits--;
                          }
                          s.bl_count[bits]--; /* move one leaf down the tree */
                          s.bl_count[
                            bits + 1
                          ] += 2; /* move one overflow item as its brother */
                          s.bl_count[max_length]--;
                          /* The brother of the overflow item also moves one step up,
                           * but this does not affect bl_count[max_length]
                           */
                          overflow -= 2;
                        } while (overflow > 0);

                        /* Now recompute all bit lengths, scanning in increasing frequency.
                         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
                         * lengths instead of fixing only the wrong ones. This idea is taken
                         * from 'ar' written by Haruhiko Okumura.)
                         */
                        for (bits = max_length; bits !== 0; bits--) {
                          n = s.bl_count[bits];
                          while (n !== 0) {
                            m = s.heap[--h];
                            if (m > max_code) {
                              continue;
                            }
                            if (tree[m * 2 + 1] /*.Len*/ !== bits) {
                              // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                              s.opt_len +=
                                (bits - tree[m * 2 + 1]) /*.Len*/ *
                                tree[m * 2] /*.Freq*/;
                              tree[m * 2 + 1] /*.Len*/ = bits;
                            }
                            n--;
                          }
                        }
                      }

                      /* ===========================================================================
                       * Generate the codes for a given tree and bit counts (which need not be
                       * optimal).
                       * IN assertion: the array bl_count contains the bit length statistics for
                       * the given tree and the field len is set for all tree elements.
                       * OUT assertion: the field code is set for all tree elements of non
                       *     zero code length.
                       */
                      function gen_codes(tree, max_code, bl_count) {
                        //    ct_data *tree;             /* the tree to decorate */
                        //    int max_code;              /* largest code with non zero frequency */
                        //    ushf *bl_count;            /* number of codes at each bit length */
                        var next_code = new Array(
                          MAX_BITS + 1
                        ); /* next code value for each bit length */
                        var code = 0; /* running code value */
                        var bits; /* bit index */
                        var n; /* code index */

                        /* The distribution counts are first used to generate the code values
                         * without bit reversal.
                         */
                        for (bits = 1; bits <= MAX_BITS; bits++) {
                          next_code[bits] = code =
                            (code + bl_count[bits - 1]) << 1;
                        }
                        /* Check that the bit counts in bl_count are consistent. The last code
                         * must be all ones.
                         */
                        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
                        //        "inconsistent bit counts");
                        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

                        for (n = 0; n <= max_code; n++) {
                          var len = tree[n * 2 + 1]; /*.Len*/
                          if (len === 0) {
                            continue;
                          }
                          /* Now reverse the bits */
                          tree[n * 2] /*.Code*/ = bi_reverse(
                            next_code[len]++,
                            len
                          );

                          //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
                          //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
                        }
                      }

                      /* ===========================================================================
                       * Initialize the various 'constant' tables.
                       */
                      function tr_static_init() {
                        var n; /* iterates over tree elements */
                        var bits; /* bit counter */
                        var length; /* length value */
                        var code; /* code value */
                        var dist; /* distance index */
                        var bl_count = new Array(MAX_BITS + 1);
                        /* number of codes at each bit length for an optimal tree */

                        // do check in _tr_init()
                        //if (static_init_done) return;

                        /* For some embedded targets, global variables are not initialized: */
                        /*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

                        /* Initialize the mapping length (0..255) -> length code (0..28) */
                        length = 0;
                        for (code = 0; code < LENGTH_CODES - 1; code++) {
                          base_length[code] = length;
                          for (n = 0; n < 1 << extra_lbits[code]; n++) {
                            _length_code[length++] = code;
                          }
                        }
                        //Assert (length == 256, "tr_static_init: length != 256");
                        /* Note that the length 255 (match length 258) can be represented
                         * in two different ways: code 284 + 5 bits or code 285, so we
                         * overwrite length_code[255] to use the best encoding:
                         */
                        _length_code[length - 1] = code;

                        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
                        dist = 0;
                        for (code = 0; code < 16; code++) {
                          base_dist[code] = dist;
                          for (n = 0; n < 1 << extra_dbits[code]; n++) {
                            _dist_code[dist++] = code;
                          }
                        }
                        //Assert (dist == 256, "tr_static_init: dist != 256");
                        dist >>= 7; /* from now on, all distances are divided by 128 */
                        for (; code < D_CODES; code++) {
                          base_dist[code] = dist << 7;
                          for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {
                            _dist_code[256 + dist++] = code;
                          }
                        }
                        //Assert (dist == 256, "tr_static_init: 256+dist != 512");

                        /* Construct the codes of the static literal tree */
                        for (bits = 0; bits <= MAX_BITS; bits++) {
                          bl_count[bits] = 0;
                        }

                        n = 0;
                        while (n <= 143) {
                          static_ltree[n * 2 + 1] /*.Len*/ = 8;
                          n++;
                          bl_count[8]++;
                        }
                        while (n <= 255) {
                          static_ltree[n * 2 + 1] /*.Len*/ = 9;
                          n++;
                          bl_count[9]++;
                        }
                        while (n <= 279) {
                          static_ltree[n * 2 + 1] /*.Len*/ = 7;
                          n++;
                          bl_count[7]++;
                        }
                        while (n <= 287) {
                          static_ltree[n * 2 + 1] /*.Len*/ = 8;
                          n++;
                          bl_count[8]++;
                        }
                        /* Codes 286 and 287 do not exist, but we must include them in the
                         * tree construction to get a canonical Huffman tree (longest code
                         * all ones)
                         */
                        gen_codes(static_ltree, L_CODES + 1, bl_count);

                        /* The static distance tree is trivial: */
                        for (n = 0; n < D_CODES; n++) {
                          static_dtree[n * 2 + 1] /*.Len*/ = 5;
                          static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
                        }

                        // Now data ready and we can init static trees
                        static_l_desc = new StaticTreeDesc(
                          static_ltree,
                          extra_lbits,
                          LITERALS + 1,
                          L_CODES,
                          MAX_BITS
                        );
                        static_d_desc = new StaticTreeDesc(
                          static_dtree,
                          extra_dbits,
                          0,
                          D_CODES,
                          MAX_BITS
                        );
                        static_bl_desc = new StaticTreeDesc(
                          new Array(0),
                          extra_blbits,
                          0,
                          BL_CODES,
                          MAX_BL_BITS
                        );

                        //static_init_done = true;
                      }

                      /* ===========================================================================
                       * Initialize a new block.
                       */
                      function init_block(s) {
                        var n; /* iterates over tree elements */

                        /* Initialize the trees. */
                        for (n = 0; n < L_CODES; n++) {
                          s.dyn_ltree[n * 2] /*.Freq*/ = 0;
                        }
                        for (n = 0; n < D_CODES; n++) {
                          s.dyn_dtree[n * 2] /*.Freq*/ = 0;
                        }
                        for (n = 0; n < BL_CODES; n++) {
                          s.bl_tree[n * 2] /*.Freq*/ = 0;
                        }

                        s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
                        s.opt_len = s.static_len = 0;
                        s.last_lit = s.matches = 0;
                      }

                      /* ===========================================================================
                       * Flush the bit buffer and align the output on a byte boundary
                       */
                      function bi_windup(s) {
                        if (s.bi_valid > 8) {
                          put_short(s, s.bi_buf);
                        } else if (s.bi_valid > 0) {
                          //put_byte(s, (Byte)s->bi_buf);
                          s.pending_buf[s.pending++] = s.bi_buf;
                        }
                        s.bi_buf = 0;
                        s.bi_valid = 0;
                      }

                      /* ===========================================================================
                       * Copy a stored block, storing first the length and its
                       * one's complement if requested.
                       */
                      function copy_block(s, buf, len, header) {
                        //DeflateState *s;
                        //charf    *buf;    /* the input data */
                        //unsigned len;     /* its length */
                        //int      header;  /* true if block header must be written */
                        bi_windup(s); /* align on byte boundary */

                        if (header) {
                          put_short(s, len);
                          put_short(s, ~len);
                        }
                        //  while (len--) {
                        //    put_byte(s, *buf++);
                        //  }
                        utils.arraySet(
                          s.pending_buf,
                          s.window,
                          buf,
                          len,
                          s.pending
                        );
                        s.pending += len;
                      }

                      /* ===========================================================================
                       * Compares to subtrees, using the tree depth as tie breaker when
                       * the subtrees have equal frequency. This minimizes the worst case length.
                       */
                      function smaller(tree, n, m, depth) {
                        var _n2 = n * 2;
                        var _m2 = m * 2;
                        return (
                          tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||
                          (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ &&
                            depth[n] <= depth[m])
                        );
                      }

                      /* ===========================================================================
                       * Restore the heap property by moving down the tree starting at node k,
                       * exchanging a node with the smallest of its two sons if necessary, stopping
                       * when the heap property is re-established (each father smaller than its
                       * two sons).
                       */
                      function pqdownheap(s, tree, k) {
                        //    deflate_state *s;
                        //    ct_data *tree;  /* the tree to restore */
                        //    int k;               /* node to move down */
                        var v = s.heap[k];
                        var j = k << 1; /* left son of k */
                        while (j <= s.heap_len) {
                          /* Set j to the smallest of the two sons: */
                          if (
                            j < s.heap_len &&
                            smaller(tree, s.heap[j + 1], s.heap[j], s.depth)
                          ) {
                            j++;
                          }
                          /* Exit if v is smaller than both sons */
                          if (smaller(tree, v, s.heap[j], s.depth)) {
                            break;
                          }

                          /* Exchange v with the smallest son */
                          s.heap[k] = s.heap[j];
                          k = j;

                          /* And continue down the tree, setting j to the left son of k */
                          j <<= 1;
                        }
                        s.heap[k] = v;
                      }

                      // inlined manually
                      // var SMALLEST = 1;

                      /* ===========================================================================
                       * Send the block data compressed using the given Huffman trees
                       */
                      function compress_block(s, ltree, dtree) {
                        //    deflate_state *s;
                        //    const ct_data *ltree; /* literal tree */
                        //    const ct_data *dtree; /* distance tree */
                        var dist; /* distance of matched string */
                        var lc; /* match length or unmatched char (if dist == 0) */
                        var lx = 0; /* running index in l_buf */
                        var code; /* the code to send */
                        var extra; /* number of extra bits to send */

                        if (s.last_lit !== 0) {
                          do {
                            dist =
                              (s.pending_buf[s.d_buf + lx * 2] << 8) |
                              s.pending_buf[s.d_buf + lx * 2 + 1];
                            lc = s.pending_buf[s.l_buf + lx];
                            lx++;

                            if (dist === 0) {
                              send_code(s, lc, ltree); /* send a literal byte */
                              //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                            } else {
                              /* Here, lc is the match length - MIN_MATCH */
                              code = _length_code[lc];
                              send_code(
                                s,
                                code + LITERALS + 1,
                                ltree
                              ); /* send the length code */
                              extra = extra_lbits[code];
                              if (extra !== 0) {
                                lc -= base_length[code];
                                send_bits(
                                  s,
                                  lc,
                                  extra
                                ); /* send the extra length bits */
                              }
                              dist--; /* dist is now the match distance - 1 */
                              code = d_code(dist);
                              //Assert (code < D_CODES, "bad d_code");

                              send_code(
                                s,
                                code,
                                dtree
                              ); /* send the distance code */
                              extra = extra_dbits[code];
                              if (extra !== 0) {
                                dist -= base_dist[code];
                                send_bits(
                                  s,
                                  dist,
                                  extra
                                ); /* send the extra distance bits */
                              }
                            } /* literal or match pair ? */

                            /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                            //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                            //       "pendingBuf overflow");
                          } while (lx < s.last_lit);
                        }

                        send_code(s, END_BLOCK, ltree);
                      }

                      /* ===========================================================================
                       * Construct one Huffman tree and assigns the code bit strings and lengths.
                       * Update the total bit length for the current block.
                       * IN assertion: the field freq is set for all tree elements.
                       * OUT assertions: the fields len and code are set to the optimal bit length
                       *     and corresponding code. The length opt_len is updated; static_len is
                       *     also updated if stree is not null. The field max_code is set.
                       */
                      function build_tree(s, desc) {
                        //    deflate_state *s;
                        //    tree_desc *desc; /* the tree descriptor */
                        var tree = desc.dyn_tree;
                        var stree = desc.stat_desc.static_tree;
                        var has_stree = desc.stat_desc.has_stree;
                        var elems = desc.stat_desc.elems;
                        var n, m; /* iterate over heap elements */
                        var max_code = -1; /* largest code with non zero frequency */
                        var node; /* new node being created */

                        /* Construct the initial heap, with least frequent element in
                         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
                         * heap[0] is not used.
                         */
                        s.heap_len = 0;
                        s.heap_max = HEAP_SIZE;

                        for (n = 0; n < elems; n++) {
                          if (tree[n * 2] /*.Freq*/ !== 0) {
                            s.heap[++s.heap_len] = max_code = n;
                            s.depth[n] = 0;
                          } else {
                            tree[n * 2 + 1] /*.Len*/ = 0;
                          }
                        }

                        /* The pkzip format requires that at least one distance code exists,
                         * and that at least one bit should be sent even if there is only one
                         * possible code. So to avoid special checks later on we force at least
                         * two codes of non zero frequency.
                         */
                        while (s.heap_len < 2) {
                          node = s.heap[++s.heap_len] =
                            max_code < 2 ? ++max_code : 0;
                          tree[node * 2] /*.Freq*/ = 1;
                          s.depth[node] = 0;
                          s.opt_len--;

                          if (has_stree) {
                            s.static_len -= stree[node * 2 + 1] /*.Len*/;
                          }
                          /* node is 0 or 1 so it does not have extra bits */
                        }
                        desc.max_code = max_code;

                        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
                         * establish sub-heaps of increasing lengths:
                         */
                        for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
                          pqdownheap(s, tree, n);
                        }

                        /* Construct the Huffman tree by repeatedly combining the least two
                         * frequent nodes.
                         */
                        node = elems; /* next internal node of the tree */
                        do {
                          //pqremove(s, tree, n);  /* n = node of least frequency */
                          /*** pqremove ***/
                          n = s.heap[1 /*SMALLEST*/];
                          s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
                          pqdownheap(s, tree, 1 /*SMALLEST*/);
                          /***/

                          m =
                            s
                              .heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

                          s.heap[
                            --s.heap_max
                          ] = n; /* keep the nodes sorted by frequency */
                          s.heap[--s.heap_max] = m;

                          /* Create a new node father of n and m */
                          tree[node * 2] /*.Freq*/ =
                            tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
                          s.depth[node] =
                            (s.depth[n] >= s.depth[m]
                              ? s.depth[n]
                              : s.depth[m]) + 1;
                          tree[n * 2 + 1] /*.Dad*/ = tree[
                            m * 2 + 1
                          ] /*.Dad*/ = node;

                          /* and insert the new node in the heap */
                          s.heap[1 /*SMALLEST*/] = node++;
                          pqdownheap(s, tree, 1 /*SMALLEST*/);
                        } while (s.heap_len >= 2);

                        s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

                        /* At this point, the fields freq and dad are set. We can now
                         * generate the bit lengths.
                         */
                        gen_bitlen(s, desc);

                        /* The field len is now set, we can generate the bit codes */
                        gen_codes(tree, max_code, s.bl_count);
                      }

                      /* ===========================================================================
                       * Scan a literal or distance tree to determine the frequencies of the codes
                       * in the bit length tree.
                       */
                      function scan_tree(s, tree, max_code) {
                        //    deflate_state *s;
                        //    ct_data *tree;   /* the tree to be scanned */
                        //    int max_code;    /* and its largest code of non zero frequency */
                        var n; /* iterates over all tree elements */
                        var prevlen = -1; /* last emitted length */
                        var curlen; /* length of current code */

                        var nextlen =
                          tree[0 * 2 + 1]; /*.Len*/ /* length of next code */

                        var count = 0; /* repeat count of the current code */
                        var max_count = 7; /* max repeat count */
                        var min_count = 4; /* min repeat count */

                        if (nextlen === 0) {
                          max_count = 138;
                          min_count = 3;
                        }
                        tree[
                          (max_code + 1) * 2 + 1
                        ] /*.Len*/ = 0xffff; /* guard */

                        for (n = 0; n <= max_code; n++) {
                          curlen = nextlen;
                          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

                          if (++count < max_count && curlen === nextlen) {
                            continue;
                          } else if (count < min_count) {
                            s.bl_tree[curlen * 2] /*.Freq*/ += count;
                          } else if (curlen !== 0) {
                            if (curlen !== prevlen) {
                              s.bl_tree[curlen * 2] /*.Freq*/++;
                            }
                            s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
                          } else if (count <= 10) {
                            s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
                          } else {
                            s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
                          }

                          count = 0;
                          prevlen = curlen;

                          if (nextlen === 0) {
                            max_count = 138;
                            min_count = 3;
                          } else if (curlen === nextlen) {
                            max_count = 6;
                            min_count = 3;
                          } else {
                            max_count = 7;
                            min_count = 4;
                          }
                        }
                      }

                      /* ===========================================================================
                       * Send a literal or distance tree in compressed form, using the codes in
                       * bl_tree.
                       */
                      function send_tree(s, tree, max_code) {
                        //    deflate_state *s;
                        //    ct_data *tree; /* the tree to be scanned */
                        //    int max_code;       /* and its largest code of non zero frequency */
                        var n; /* iterates over all tree elements */
                        var prevlen = -1; /* last emitted length */
                        var curlen; /* length of current code */

                        var nextlen =
                          tree[0 * 2 + 1]; /*.Len*/ /* length of next code */

                        var count = 0; /* repeat count of the current code */
                        var max_count = 7; /* max repeat count */
                        var min_count = 4; /* guard already set */ /* min repeat count */

                        /* tree[max_code+1].Len = -1; */ if (nextlen === 0) {
                          max_count = 138;
                          min_count = 3;
                        }

                        for (n = 0; n <= max_code; n++) {
                          curlen = nextlen;
                          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

                          if (++count < max_count && curlen === nextlen) {
                            continue;
                          } else if (count < min_count) {
                            do {
                              send_code(s, curlen, s.bl_tree);
                            } while (--count !== 0);
                          } else if (curlen !== 0) {
                            if (curlen !== prevlen) {
                              send_code(s, curlen, s.bl_tree);
                              count--;
                            }
                            //Assert(count >= 3 && count <= 6, " 3_6?");
                            send_code(s, REP_3_6, s.bl_tree);
                            send_bits(s, count - 3, 2);
                          } else if (count <= 10) {
                            send_code(s, REPZ_3_10, s.bl_tree);
                            send_bits(s, count - 3, 3);
                          } else {
                            send_code(s, REPZ_11_138, s.bl_tree);
                            send_bits(s, count - 11, 7);
                          }

                          count = 0;
                          prevlen = curlen;
                          if (nextlen === 0) {
                            max_count = 138;
                            min_count = 3;
                          } else if (curlen === nextlen) {
                            max_count = 6;
                            min_count = 3;
                          } else {
                            max_count = 7;
                            min_count = 4;
                          }
                        }
                      }

                      /* ===========================================================================
                       * Construct the Huffman tree for the bit lengths and return the index in
                       * bl_order of the last bit length code to send.
                       */
                      function build_bl_tree(s) {
                        var max_blindex; /* index of last bit length code of non zero freq */

                        /* Determine the bit length frequencies for literal and distance trees */
                        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

                        /* Build the bit length tree: */
                        build_tree(s, s.bl_desc);
                        /* opt_len now includes the length of the tree representations, except
                         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
                         */

                        /* Determine the number of bit length codes to send. The pkzip format
                         * requires that at least 4 bit length codes be sent. (appnote.txt says
                         * 3 but the actual value used is 4.)
                         */
                        for (
                          max_blindex = BL_CODES - 1;
                          max_blindex >= 3;
                          max_blindex--
                        ) {
                          if (
                            s.bl_tree[
                              bl_order[max_blindex] * 2 + 1
                            ] /*.Len*/ !== 0
                          ) {
                            break;
                          }
                        }
                        /* Update opt_len to include the bit length tree and counts */
                        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                        //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
                        //        s->opt_len, s->static_len));

                        return max_blindex;
                      }

                      /* ===========================================================================
                       * Send the header for a block using dynamic Huffman trees: the counts, the
                       * lengths of the bit length codes, the literal tree and the distance tree.
                       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
                       */
                      function send_all_trees(s, lcodes, dcodes, blcodes) {
                        //    deflate_state *s;
                        //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
                        var rank; /* index in bl_order */

                        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
                        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
                        //        "too many codes");
                        //Tracev((stderr, "\nbl counts: "));
                        send_bits(
                          s,
                          lcodes - 257,
                          5
                        ); /* not +255 as stated in appnote.txt */
                        send_bits(s, dcodes - 1, 5);
                        send_bits(
                          s,
                          blcodes - 4,
                          4
                        ); /* not -3 as stated in appnote.txt */
                        for (rank = 0; rank < blcodes; rank++) {
                          //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
                          send_bits(
                            s,
                            s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/,
                            3
                          );
                        }
                        //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

                        send_tree(
                          s,
                          s.dyn_ltree,
                          lcodes - 1
                        ); /* literal tree */
                        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

                        send_tree(
                          s,
                          s.dyn_dtree,
                          dcodes - 1
                        ); /* distance tree */
                        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
                      }

                      /* ===========================================================================
                       * Check if the data type is TEXT or BINARY, using the following algorithm:
                       * - TEXT if the two conditions below are satisfied:
                       *    a) There are no non-portable control characters belonging to the
                       *       "black list" (0..6, 14..25, 28..31).
                       *    b) There is at least one printable character belonging to the
                       *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
                       * - BINARY otherwise.
                       * - The following partially-portable control characters form a
                       *   "gray list" that is ignored in this detection algorithm:
                       *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
                       * IN assertion: the fields Freq of dyn_ltree are set.
                       */
                      function detect_data_type(s) {
                        /* black_mask is the bit mask of black-listed bytes
                         * set bits 0..6, 14..25, and 28..31
                         * 0xf3ffc07f = binary 11110011111111111100000001111111
                         */
                        var black_mask = 0xf3ffc07f;
                        var n;

                        /* Check for non-textual ("black-listed") bytes. */
                        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                          if (
                            black_mask & 1 &&
                            s.dyn_ltree[n * 2] /*.Freq*/ !== 0
                          ) {
                            return Z_BINARY;
                          }
                        }

                        /* Check for textual ("white-listed") bytes. */
                        if (
                          s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 ||
                          s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||
                          s.dyn_ltree[13 * 2] /*.Freq*/ !== 0
                        ) {
                          return Z_TEXT;
                        }
                        for (n = 32; n < LITERALS; n++) {
                          if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
                            return Z_TEXT;
                          }
                        }

                        /* There are no "black-listed" or "white-listed" bytes:
                         * this stream either is empty or has tolerated ("gray-listed") bytes only.
                         */
                        return Z_BINARY;
                      }

                      var static_init_done = false;

                      /* ===========================================================================
                       * Initialize the tree data structures for a new zlib stream.
                       */
                      function _tr_init(s) {
                        if (!static_init_done) {
                          tr_static_init();
                          static_init_done = true;
                        }

                        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

                        s.bi_buf = 0;
                        s.bi_valid = 0;

                        /* Initialize the first block of the first file: */
                        init_block(s);
                      }

                      /* ===========================================================================
                       * Send a stored block
                       */
                      function _tr_stored_block(s, buf, stored_len, last) {
                        //DeflateState *s;
                        //charf *buf;       /* input block */
                        //ulg stored_len;   /* length of input block */
                        //int last;         /* one if this is the last block for a file */
                        send_bits(
                          s,
                          (STORED_BLOCK << 1) + (last ? 1 : 0),
                          3
                        ); /* send block type */
                        copy_block(s, buf, stored_len, true); /* with header */
                      }

                      /* ===========================================================================
                       * Send one empty static block to give enough lookahead for inflate.
                       * This takes 10 bits, of which 7 may remain in the bit buffer.
                       */
                      function _tr_align(s) {
                        send_bits(s, STATIC_TREES << 1, 3);
                        send_code(s, END_BLOCK, static_ltree);
                        bi_flush(s);
                      }

                      /* ===========================================================================
                       * Determine the best encoding for the current block: dynamic trees, static
                       * trees or store, and output the encoded block to the zip file.
                       */
                      function _tr_flush_block(s, buf, stored_len, last) {
                        //DeflateState *s;
                        //charf *buf;       /* input block, or NULL if too old */
                        //ulg stored_len;   /* length of input block */
                        //int last;         /* one if this is the last block for a file */
                        var opt_lenb,
                          static_lenb; /* opt_len and static_len in bytes */
                        var max_blindex = 0; /* index of last bit length code of non zero freq */

                        /* Build the Huffman trees unless a stored block is forced */
                        if (s.level > 0) {
                          /* Check if the file is binary or text */
                          if (s.strm.data_type === Z_UNKNOWN) {
                            s.strm.data_type = detect_data_type(s);
                          }

                          /* Construct the literal and distance trees */
                          build_tree(s, s.l_desc);
                          // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                          //        s->static_len));

                          build_tree(s, s.d_desc);
                          // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                          //        s->static_len));
                          /* At this point, opt_len and static_len are the total bit lengths of
                           * the compressed block data, excluding the tree representations.
                           */

                          /* Build the bit length tree for the above two trees, and get the index
                           * in bl_order of the last bit length code to send.
                           */
                          max_blindex = build_bl_tree(s);

                          /* Determine the best encoding. Compute the block lengths in bytes. */
                          opt_lenb = (s.opt_len + 3 + 7) >>> 3;
                          static_lenb = (s.static_len + 3 + 7) >>> 3;

                          // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                          //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                          //        s->last_lit));

                          if (static_lenb <= opt_lenb) {
                            opt_lenb = static_lenb;
                          }
                        } else {
                          // Assert(buf != (char*)0, "lost buf");
                          opt_lenb = static_lenb =
                            stored_len + 5; /* force a stored block */
                        }

                        if (stored_len + 4 <= opt_lenb && buf !== -1) {
                          /* 4: two words for the lengths */

                          /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
                           * Otherwise we can't have processed more than WSIZE input bytes since
                           * the last block flush, because compression would have been
                           * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
                           * transform a block into a stored block.
                           */
                          _tr_stored_block(s, buf, stored_len, last);
                        } else if (
                          s.strategy === Z_FIXED ||
                          static_lenb === opt_lenb
                        ) {
                          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                          compress_block(s, static_ltree, static_dtree);
                        } else {
                          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                          send_all_trees(
                            s,
                            s.l_desc.max_code + 1,
                            s.d_desc.max_code + 1,
                            max_blindex + 1
                          );
                          compress_block(s, s.dyn_ltree, s.dyn_dtree);
                        }
                        // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
                        /* The above check is made mod 2^32, for files larger than 512 MB
                         * and uLong implemented on 32 bits.
                         */
                        init_block(s);

                        if (last) {
                          bi_windup(s);
                        }
                        // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
                        //       s->compressed_len-7*last));
                      }

                      /* ===========================================================================
                       * Save the match info and tally the frequency counts. Return true if
                       * the current block must be flushed.
                       */
                      function _tr_tally(s, dist, lc) {
                        //    deflate_state *s;
                        //    unsigned dist;  /* distance of matched string */
                        //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
                        //var out_length, in_length, dcode;

                        s.pending_buf[s.d_buf + s.last_lit * 2] =
                          (dist >>> 8) & 0xff;
                        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] =
                          dist & 0xff;

                        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
                        s.last_lit++;

                        if (dist === 0) {
                          /* lc is the unmatched char */
                          s.dyn_ltree[lc * 2] /*.Freq*/++;
                        } else {
                          s.matches++;
                          /* Here, lc is the match length - MIN_MATCH */
                          dist--; /* dist = match distance - 1 */
                          //Assert((ush)dist < (ush)MAX_DIST(s) &&
                          //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
                          //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

                          s.dyn_ltree[
                            (_length_code[lc] + LITERALS + 1) * 2
                          ] /*.Freq*/++;
                          s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
                        }

                        // (!) This block is disabled in zlib defaults,
                        // don't enable it for binary compatibility

                        //#ifdef TRUNCATE_BLOCK
                        //  /* Try to guess if it is profitable to stop the current block here */
                        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
                        //    /* Compute an upper bound for the compressed length */
                        //    out_length = s.last_lit*8;
                        //    in_length = s.strstart - s.block_start;
                        //
                        //    for (dcode = 0; dcode < D_CODES; dcode++) {
                        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
                        //    }
                        //    out_length >>>= 3;
                        //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
                        //    //       s->last_lit, in_length, out_length,
                        //    //       100L - out_length*100L/in_length));
                        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
                        //      return true;
                        //    }
                        //  }
                        //#endif

                        return s.last_lit === s.lit_bufsize - 1;
                        /* We avoid equality with lit_bufsize because of wraparound at 64K
                         * on 16 bit machines and because stored blocks are restricted to
                         * 64K-1 bytes.
                         */
                      }

                      exports._tr_init = _tr_init;
                      exports._tr_stored_block = _tr_stored_block;
                      exports._tr_flush_block = _tr_flush_block;
                      exports._tr_tally = _tr_tally;
                      exports._tr_align = _tr_align;
                    },
                    { '../utils/common': 1 },
                  ],
                  8: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      function ZStream() {
                        /* next input byte */
                        this.input = null; // JS specific, because we have no pointers
                        this.next_in = 0;
                        /* number of bytes available at input */
                        this.avail_in = 0;
                        /* total number of input bytes read so far */
                        this.total_in = 0;
                        /* next output byte should be put there */
                        this.output = null; // JS specific, because we have no pointers
                        this.next_out = 0;
                        /* remaining free space at output */
                        this.avail_out = 0;
                        /* total number of bytes output so far */
                        this.total_out = 0;
                        /* last error message, NULL if no error */
                        this.msg = '' /*Z_NULL*/;
                        /* not visible by applications */
                        this.state = null;
                        /* best guess about the data type: binary or text */
                        this.data_type = 2 /*Z_UNKNOWN*/;
                        /* adler32 value of the uncompressed data */
                        this.adler = 0;
                      }

                      module.exports = ZStream;
                    },
                    {},
                  ],
                  '/lib/deflate.js': [
                    function (require, module, exports) {
                      var zlib_deflate = require('./zlib/deflate');
                      var utils = require('./utils/common');
                      var strings = require('./utils/strings');
                      var msg = require('./zlib/messages');
                      var ZStream = require('./zlib/zstream');

                      var toString = Object.prototype.toString;

                      /* Public constants ==========================================================*/
                      /* ===========================================================================*/

                      var Z_NO_FLUSH = 0;
                      var Z_FINISH = 4;

                      var Z_OK = 0;
                      var Z_STREAM_END = 1;
                      var Z_SYNC_FLUSH = 2;

                      var Z_DEFAULT_COMPRESSION = -1;

                      var Z_DEFAULT_STRATEGY = 0;

                      var Z_DEFLATED = 8;

                      /* ===========================================================================*/

                      /**
                       * class Deflate
                       *
                       * Generic JS-style wrapper for zlib calls. If you don't need
                       * streaming behaviour - use more simple functions: [[deflate]],
                       * [[deflateRaw]] and [[gzip]].
                       **/

                      /* internal
                       * Deflate.chunks -> Array
                       *
                       * Chunks of output data, if [[Deflate#onData]] not overridden.
                       **/

                      /**
                       * Deflate.result -> Uint8Array|Array
                       *
                       * Compressed result, generated by default [[Deflate#onData]]
                       * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
                       * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
                       * push a chunk with explicit flush (call [[Deflate#push]] with
                       * `Z_SYNC_FLUSH` param).
                       **/

                      /**
                       * Deflate.err -> Number
                       *
                       * Error code after deflate finished. 0 (Z_OK) on success.
                       * You will not need it in real life, because deflate errors
                       * are possible only on wrong options or bad `onData` / `onEnd`
                       * custom handlers.
                       **/

                      /**
                       * Deflate.msg -> String
                       *
                       * Error message, if [[Deflate.err]] != 0
                       **/

                      /**
                       * new Deflate(options)
                       * - options (Object): zlib deflate options.
                       *
                       * Creates new deflator instance with specified params. Throws exception
                       * on bad params. Supported options:
                       *
                       * - `level`
                       * - `windowBits`
                       * - `memLevel`
                       * - `strategy`
                       * - `dictionary`
                       *
                       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
                       * for more information on these.
                       *
                       * Additional options, for internal needs:
                       *
                       * - `chunkSize` - size of generated data chunks (16K by default)
                       * - `raw` (Boolean) - do raw deflate
                       * - `gzip` (Boolean) - create gzip wrapper
                       * - `to` (String) - if equal to 'string', then result will be "binary string"
                       *    (each char code [0..255])
                       * - `header` (Object) - custom header for gzip
                       *   - `text` (Boolean) - true if compressed data believed to be text
                       *   - `time` (Number) - modification time, unix timestamp
                       *   - `os` (Number) - operation system code
                       *   - `extra` (Array) - array of bytes with extra data (max 65536)
                       *   - `name` (String) - file name (binary string)
                       *   - `comment` (String) - comment (binary string)
                       *   - `hcrc` (Boolean) - true if header crc should be added
                       *
                       * ##### Example:
                       *
                       * ```javascript
                       * var pako = require('pako')
                       *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
                       *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
                       *
                       * var deflate = new pako.Deflate({ level: 3});
                       *
                       * deflate.push(chunk1, false);
                       * deflate.push(chunk2, true);  // true -> last chunk
                       *
                       * if (deflate.err) { throw new Error(deflate.err); }
                       *
                       * console.log(deflate.result);
                       * ```
                       **/
                      function Deflate(options) {
                        if (!(this instanceof Deflate))
                          return new Deflate(options);

                        this.options = utils.assign(
                          {
                            level: Z_DEFAULT_COMPRESSION,
                            method: Z_DEFLATED,
                            chunkSize: 16384,
                            windowBits: 15,
                            memLevel: 8,
                            strategy: Z_DEFAULT_STRATEGY,
                            to: '',
                          },
                          options || {}
                        );

                        var opt = this.options;

                        if (opt.raw && opt.windowBits > 0) {
                          opt.windowBits = -opt.windowBits;
                        } else if (
                          opt.gzip &&
                          opt.windowBits > 0 &&
                          opt.windowBits < 16
                        ) {
                          opt.windowBits += 16;
                        }

                        this.err = 0; // error code, if happens (0 = Z_OK)
                        this.msg = ''; // error message
                        this.ended = false; // used to avoid multiple onEnd() calls
                        this.chunks = []; // chunks of compressed data

                        this.strm = new ZStream();
                        this.strm.avail_out = 0;

                        var status = zlib_deflate.deflateInit2(
                          this.strm,
                          opt.level,
                          opt.method,
                          opt.windowBits,
                          opt.memLevel,
                          opt.strategy
                        );

                        if (status !== Z_OK) {
                          throw new Error(msg[status]);
                        }

                        if (opt.header) {
                          zlib_deflate.deflateSetHeader(this.strm, opt.header);
                        }

                        if (opt.dictionary) {
                          var dict;
                          // Convert data if needed
                          if (typeof opt.dictionary === 'string') {
                            // If we need to compress text, change encoding to utf8.
                            dict = strings.string2buf(opt.dictionary);
                          } else if (
                            toString.call(opt.dictionary) ===
                            '[object ArrayBuffer]'
                          ) {
                            dict = new Uint8Array(opt.dictionary);
                          } else {
                            dict = opt.dictionary;
                          }

                          status = zlib_deflate.deflateSetDictionary(
                            this.strm,
                            dict
                          );

                          if (status !== Z_OK) {
                            throw new Error(msg[status]);
                          }

                          this._dict_set = true;
                        }
                      }

                      /**
                       * Deflate#push(data[, mode]) -> Boolean
                       * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
                       *   converted to utf8 byte sequence.
                       * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
                       *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
                       *
                       * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
                       * new compressed chunks. Returns `true` on success. The last data block must have
                       * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
                       * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
                       * can use mode Z_SYNC_FLUSH, keeping the compression context.
                       *
                       * On fail call [[Deflate#onEnd]] with error code and return false.
                       *
                       * We strongly recommend to use `Uint8Array` on input for best speed (output
                       * array format is detected automatically). Also, don't skip last param and always
                       * use the same type in your code (boolean or number). That will improve JS speed.
                       *
                       * For regular `Array`-s make sure all elements are [0..255].
                       *
                       * ##### Example
                       *
                       * ```javascript
                       * push(chunk, false); // push one of data chunks
                       * ...
                       * push(chunk, true);  // push last chunk
                       * ```
                       **/
                      Deflate.prototype.push = function (data, mode) {
                        var strm = this.strm;
                        var chunkSize = this.options.chunkSize;
                        var status, _mode;

                        if (this.ended) {
                          return false;
                        }

                        _mode =
                          mode === ~~mode
                            ? mode
                            : mode === true
                            ? Z_FINISH
                            : Z_NO_FLUSH;

                        // Convert data if needed
                        if (typeof data === 'string') {
                          // If we need to compress text, change encoding to utf8.
                          strm.input = strings.string2buf(data);
                        } else if (
                          toString.call(data) === '[object ArrayBuffer]'
                        ) {
                          strm.input = new Uint8Array(data);
                        } else {
                          strm.input = data;
                        }

                        strm.next_in = 0;
                        strm.avail_in = strm.input.length;

                        do {
                          if (strm.avail_out === 0) {
                            strm.output = new utils.Buf8(chunkSize);
                            strm.next_out = 0;
                            strm.avail_out = chunkSize;
                          }
                          status = zlib_deflate.deflate(
                            strm,
                            _mode
                          ); /* no bad return value */

                          if (status !== Z_STREAM_END && status !== Z_OK) {
                            this.onEnd(status);
                            this.ended = true;
                            return false;
                          }
                          if (
                            strm.avail_out === 0 ||
                            (strm.avail_in === 0 &&
                              (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))
                          ) {
                            if (this.options.to === 'string') {
                              this.onData(
                                strings.buf2binstring(
                                  utils.shrinkBuf(strm.output, strm.next_out)
                                )
                              );
                            } else {
                              this.onData(
                                utils.shrinkBuf(strm.output, strm.next_out)
                              );
                            }
                          }
                        } while (
                          (strm.avail_in > 0 || strm.avail_out === 0) &&
                          status !== Z_STREAM_END
                        );

                        // Finalize on the last chunk.
                        if (_mode === Z_FINISH) {
                          status = zlib_deflate.deflateEnd(this.strm);
                          this.onEnd(status);
                          this.ended = true;
                          return status === Z_OK;
                        }

                        // callback interim results if Z_SYNC_FLUSH.
                        if (_mode === Z_SYNC_FLUSH) {
                          this.onEnd(Z_OK);
                          strm.avail_out = 0;
                          return true;
                        }

                        return true;
                      };

                      /**
                       * Deflate#onData(chunk) -> Void
                       * - chunk (Uint8Array|Array|String): output data. Type of array depends
                       *   on js engine support. When string output requested, each chunk
                       *   will be string.
                       *
                       * By default, stores data blocks in `chunks[]` property and glue
                       * those in `onEnd`. Override this handler, if you need another behaviour.
                       **/
                      Deflate.prototype.onData = function (chunk) {
                        this.chunks.push(chunk);
                      };

                      /**
                       * Deflate#onEnd(status) -> Void
                       * - status (Number): deflate status. 0 (Z_OK) on success,
                       *   other if not.
                       *
                       * Called once after you tell deflate that the input stream is
                       * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
                       * or if an error happened. By default - join collected chunks,
                       * free memory and fill `results` / `err` properties.
                       **/
                      Deflate.prototype.onEnd = function (status) {
                        // On success - join
                        if (status === Z_OK) {
                          if (this.options.to === 'string') {
                            this.result = this.chunks.join('');
                          } else {
                            this.result = utils.flattenChunks(this.chunks);
                          }
                        }
                        this.chunks = [];
                        this.err = status;
                        this.msg = this.strm.msg;
                      };

                      /**
                       * deflate(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to compress.
                       * - options (Object): zlib deflate options.
                       *
                       * Compress `data` with deflate algorithm and `options`.
                       *
                       * Supported options are:
                       *
                       * - level
                       * - windowBits
                       * - memLevel
                       * - strategy
                       * - dictionary
                       *
                       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
                       * for more information on these.
                       *
                       * Sugar (options):
                       *
                       * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
                       *   negative windowBits implicitly.
                       * - `to` (String) - if equal to 'string', then result will be "binary string"
                       *    (each char code [0..255])
                       *
                       * ##### Example:
                       *
                       * ```javascript
                       * var pako = require('pako')
                       *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
                       *
                       * console.log(pako.deflate(data));
                       * ```
                       **/
                      function deflate(input, options) {
                        var deflator = new Deflate(options);

                        deflator.push(input, true);

                        // That will never happens, if you don't cheat with options :)
                        if (deflator.err) {
                          throw deflator.msg || msg[deflator.err];
                        }

                        return deflator.result;
                      }

                      /**
                       * deflateRaw(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to compress.
                       * - options (Object): zlib deflate options.
                       *
                       * The same as [[deflate]], but creates raw data, without wrapper
                       * (header and adler32 crc).
                       **/
                      function deflateRaw(input, options) {
                        options = options || {};
                        options.raw = true;
                        return deflate(input, options);
                      }

                      /**
                       * gzip(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to compress.
                       * - options (Object): zlib deflate options.
                       *
                       * The same as [[deflate]], but create gzip wrapper instead of
                       * deflate one.
                       **/
                      function gzip(input, options) {
                        options = options || {};
                        options.gzip = true;
                        return deflate(input, options);
                      }

                      exports.Deflate = Deflate;
                      exports.deflate = deflate;
                      exports.deflateRaw = deflateRaw;
                      exports.gzip = gzip;
                    },
                    {
                      './utils/common': 1,
                      './utils/strings': 2,
                      './zlib/deflate': 5,
                      './zlib/messages': 6,
                      './zlib/zstream': 8,
                    },
                  ],
                },
                {},
                []
              )('/lib/deflate.js');
            });
          });
          var pako_deflate_1 = pako_deflate.deflate;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_inflate.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_inflate.js ***!
  \****************************************************************************/
        /*! exports provided: __moduleExports, inflate */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__moduleExports',
            function () {
              return pako_inflate;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'inflate',
            function () {
              return pako_inflate_1;
            }
          );
          /* harmony import */ var _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../../_virtual/_commonjsHelpers.js */ './node_modules/rrweb/es/rrweb/_virtual/_commonjsHelpers.js'
          );

          var pako_inflate = Object(
            _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
              'createCommonjsModule'
            ]
          )(function (module, exports) {
            /* pako 1.0.11 nodeca/pako */ (function (f) {
              {
                module.exports = f();
              }
            })(function () {
              return (function () {
                function r(e, n, t) {
                  function o(i, f) {
                    if (!n[i]) {
                      if (!e[i]) {
                        var c =
                          'function' ==
                            typeof _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                              'commonjsRequire'
                            ] &&
                          _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                            'commonjsRequire'
                          ];
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw ((a.code = 'MODULE_NOT_FOUND'), a);
                      }
                      var p = (n[i] = { exports: {} });
                      e[i][0].call(
                        p.exports,
                        function (r) {
                          var n = e[i][1][r];
                          return o(n || r);
                        },
                        p,
                        p.exports,
                        r,
                        e,
                        n,
                        t
                      );
                    }
                    return n[i].exports;
                  }
                  for (
                    var u =
                        'function' ==
                          typeof _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                            'commonjsRequire'
                          ] &&
                        _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
                          'commonjsRequire'
                        ],
                      i = 0;
                    i < t.length;
                    i++
                  )
                    o(t[i]);
                  return o;
                }
                return r;
              })()(
                {
                  1: [
                    function (require, module, exports) {
                      var TYPED_OK =
                        typeof Uint8Array !== 'undefined' &&
                        typeof Uint16Array !== 'undefined' &&
                        typeof Int32Array !== 'undefined';

                      function _has(obj, key) {
                        return Object.prototype.hasOwnProperty.call(obj, key);
                      }

                      exports.assign = function (
                        obj /*from1, from2, from3, ...*/
                      ) {
                        var sources = Array.prototype.slice.call(arguments, 1);
                        while (sources.length) {
                          var source = sources.shift();
                          if (!source) {
                            continue;
                          }

                          if (typeof source !== 'object') {
                            throw new TypeError(source + 'must be non-object');
                          }

                          for (var p in source) {
                            if (_has(source, p)) {
                              obj[p] = source[p];
                            }
                          }
                        }

                        return obj;
                      };

                      // reduce buffer size, avoiding mem copy
                      exports.shrinkBuf = function (buf, size) {
                        if (buf.length === size) {
                          return buf;
                        }
                        if (buf.subarray) {
                          return buf.subarray(0, size);
                        }
                        buf.length = size;
                        return buf;
                      };

                      var fnTyped = {
                        arraySet: function (
                          dest,
                          src,
                          src_offs,
                          len,
                          dest_offs
                        ) {
                          if (src.subarray && dest.subarray) {
                            dest.set(
                              src.subarray(src_offs, src_offs + len),
                              dest_offs
                            );
                            return;
                          }
                          // Fallback to ordinary array
                          for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                          }
                        },
                        // Join array of chunks to single array.
                        flattenChunks: function (chunks) {
                          var i, l, len, pos, chunk, result;

                          // calculate data length
                          len = 0;
                          for (i = 0, l = chunks.length; i < l; i++) {
                            len += chunks[i].length;
                          }

                          // join chunks
                          result = new Uint8Array(len);
                          pos = 0;
                          for (i = 0, l = chunks.length; i < l; i++) {
                            chunk = chunks[i];
                            result.set(chunk, pos);
                            pos += chunk.length;
                          }

                          return result;
                        },
                      };

                      var fnUntyped = {
                        arraySet: function (
                          dest,
                          src,
                          src_offs,
                          len,
                          dest_offs
                        ) {
                          for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                          }
                        },
                        // Join array of chunks to single array.
                        flattenChunks: function (chunks) {
                          return [].concat.apply([], chunks);
                        },
                      };

                      // Enable/Disable typed arrays use, for testing
                      //
                      exports.setTyped = function (on) {
                        if (on) {
                          exports.Buf8 = Uint8Array;
                          exports.Buf16 = Uint16Array;
                          exports.Buf32 = Int32Array;
                          exports.assign(exports, fnTyped);
                        } else {
                          exports.Buf8 = Array;
                          exports.Buf16 = Array;
                          exports.Buf32 = Array;
                          exports.assign(exports, fnUntyped);
                        }
                      };

                      exports.setTyped(TYPED_OK);
                    },
                    {},
                  ],
                  2: [
                    function (require, module, exports) {
                      var utils = require('./common');

                      // Quick check if we can use fast array to bin string conversion
                      //
                      // - apply(Array) can fail on Android 2.2
                      // - apply(Uint8Array) can fail on iOS 5.1 Safari
                      //
                      var STR_APPLY_OK = true;
                      var STR_APPLY_UIA_OK = true;

                      try {
                        String.fromCharCode.apply(null, [0]);
                      } catch (__) {
                        STR_APPLY_OK = false;
                      }
                      try {
                        String.fromCharCode.apply(null, new Uint8Array(1));
                      } catch (__) {
                        STR_APPLY_UIA_OK = false;
                      }

                      // Table with utf8 lengths (calculated by first byte of sequence)
                      // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
                      // because max possible codepoint is 0x10ffff
                      var _utf8len = new utils.Buf8(256);
                      for (var q = 0; q < 256; q++) {
                        _utf8len[q] =
                          q >= 252
                            ? 6
                            : q >= 248
                            ? 5
                            : q >= 240
                            ? 4
                            : q >= 224
                            ? 3
                            : q >= 192
                            ? 2
                            : 1;
                      }
                      _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

                      // convert string to array (typed, when possible)
                      exports.string2buf = function (str) {
                        var buf,
                          c,
                          c2,
                          m_pos,
                          i,
                          str_len = str.length,
                          buf_len = 0;

                        // count binary size
                        for (m_pos = 0; m_pos < str_len; m_pos++) {
                          c = str.charCodeAt(m_pos);
                          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                            c2 = str.charCodeAt(m_pos + 1);
                            if ((c2 & 0xfc00) === 0xdc00) {
                              c =
                                0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                              m_pos++;
                            }
                          }
                          buf_len +=
                            c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
                        }

                        // allocate buffer
                        buf = new utils.Buf8(buf_len);

                        // convert
                        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                          c = str.charCodeAt(m_pos);
                          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                            c2 = str.charCodeAt(m_pos + 1);
                            if ((c2 & 0xfc00) === 0xdc00) {
                              c =
                                0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                              m_pos++;
                            }
                          }
                          if (c < 0x80) {
                            /* one byte */
                            buf[i++] = c;
                          } else if (c < 0x800) {
                            /* two bytes */
                            buf[i++] = 0xc0 | (c >>> 6);
                            buf[i++] = 0x80 | (c & 0x3f);
                          } else if (c < 0x10000) {
                            /* three bytes */
                            buf[i++] = 0xe0 | (c >>> 12);
                            buf[i++] = 0x80 | ((c >>> 6) & 0x3f);
                            buf[i++] = 0x80 | (c & 0x3f);
                          } else {
                            /* four bytes */
                            buf[i++] = 0xf0 | (c >>> 18);
                            buf[i++] = 0x80 | ((c >>> 12) & 0x3f);
                            buf[i++] = 0x80 | ((c >>> 6) & 0x3f);
                            buf[i++] = 0x80 | (c & 0x3f);
                          }
                        }

                        return buf;
                      };

                      // Helper (used in 2 places)
                      function buf2binstring(buf, len) {
                        // On Chrome, the arguments in a function call that are allowed is `65534`.
                        // If the length of the buffer is smaller than that, we can use this optimization,
                        // otherwise we will take a slower path.
                        if (len < 65534) {
                          if (
                            (buf.subarray && STR_APPLY_UIA_OK) ||
                            (!buf.subarray && STR_APPLY_OK)
                          ) {
                            return String.fromCharCode.apply(
                              null,
                              utils.shrinkBuf(buf, len)
                            );
                          }
                        }

                        var result = '';
                        for (var i = 0; i < len; i++) {
                          result += String.fromCharCode(buf[i]);
                        }
                        return result;
                      }

                      // Convert byte array to binary string
                      exports.buf2binstring = function (buf) {
                        return buf2binstring(buf, buf.length);
                      };

                      // Convert binary string (typed, when possible)
                      exports.binstring2buf = function (str) {
                        var buf = new utils.Buf8(str.length);
                        for (var i = 0, len = buf.length; i < len; i++) {
                          buf[i] = str.charCodeAt(i);
                        }
                        return buf;
                      };

                      // convert array to string
                      exports.buf2string = function (buf, max) {
                        var i, out, c, c_len;
                        var len = max || buf.length;

                        // Reserve max possible length (2 words per char)
                        // NB: by unknown reasons, Array is significantly faster for
                        //     String.fromCharCode.apply than Uint16Array.
                        var utf16buf = new Array(len * 2);

                        for (out = 0, i = 0; i < len; ) {
                          c = buf[i++];
                          // quick process ascii
                          if (c < 0x80) {
                            utf16buf[out++] = c;
                            continue;
                          }

                          c_len = _utf8len[c];
                          // skip 5 & 6 byte codes
                          if (c_len > 4) {
                            utf16buf[out++] = 0xfffd;
                            i += c_len - 1;
                            continue;
                          }

                          // apply mask on first byte
                          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
                          // join the rest
                          while (c_len > 1 && i < len) {
                            c = (c << 6) | (buf[i++] & 0x3f);
                            c_len--;
                          }

                          // terminated by end of string?
                          if (c_len > 1) {
                            utf16buf[out++] = 0xfffd;
                            continue;
                          }

                          if (c < 0x10000) {
                            utf16buf[out++] = c;
                          } else {
                            c -= 0x10000;
                            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
                          }
                        }

                        return buf2binstring(utf16buf, out);
                      };

                      // Calculate max possible position in utf8 buffer,
                      // that will not break sequence. If that's not possible
                      // - (very small limits) return max size as is.
                      //
                      // buf[] - utf8 bytes array
                      // max   - length limit (mandatory);
                      exports.utf8border = function (buf, max) {
                        var pos;

                        max = max || buf.length;
                        if (max > buf.length) {
                          max = buf.length;
                        }

                        // go back from last position, until start of sequence found
                        pos = max - 1;
                        while (pos >= 0 && (buf[pos] & 0xc0) === 0x80) {
                          pos--;
                        }

                        // Very small and broken sequence,
                        // return max, because we should return something anyway.
                        if (pos < 0) {
                          return max;
                        }

                        // If we came to start of buffer - that means buffer is too small,
                        // return max too.
                        if (pos === 0) {
                          return max;
                        }

                        return pos + _utf8len[buf[pos]] > max ? pos : max;
                      };
                    },
                    { './common': 1 },
                  ],
                  3: [
                    function (require, module, exports) {
                      // Note: adler32 takes 12% for level 0 and 2% for level 6.
                      // It isn't worth it to make additional optimizations as in original.
                      // Small size is preferable.

                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      function adler32(adler, buf, len, pos) {
                        var s1 = (adler & 0xffff) | 0,
                          s2 = ((adler >>> 16) & 0xffff) | 0,
                          n = 0;

                        while (len !== 0) {
                          // Set limit ~ twice less than 5552, to keep
                          // s2 in 31-bits, because we force signed ints.
                          // in other case %= will fail.
                          n = len > 2000 ? 2000 : len;
                          len -= n;

                          do {
                            s1 = (s1 + buf[pos++]) | 0;
                            s2 = (s2 + s1) | 0;
                          } while (--n);

                          s1 %= 65521;
                          s2 %= 65521;
                        }

                        return s1 | (s2 << 16) | 0;
                      }

                      module.exports = adler32;
                    },
                    {},
                  ],
                  4: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      module.exports = {
                        /* Allowed flush values; see deflate() and inflate() below for details */
                        Z_NO_FLUSH: 0,
                        Z_PARTIAL_FLUSH: 1,
                        Z_SYNC_FLUSH: 2,
                        Z_FULL_FLUSH: 3,
                        Z_FINISH: 4,
                        Z_BLOCK: 5,
                        Z_TREES: 6,

                        /* Return codes for the compression/decompression functions. Negative values
                         * are errors, positive values are used for special but normal events.
                         */
                        Z_OK: 0,
                        Z_STREAM_END: 1,
                        Z_NEED_DICT: 2,
                        Z_ERRNO: -1,
                        Z_STREAM_ERROR: -2,
                        Z_DATA_ERROR: -3,
                        //Z_MEM_ERROR:     -4,
                        Z_BUF_ERROR: -5,
                        //Z_VERSION_ERROR: -6,

                        /* compression levels */
                        Z_NO_COMPRESSION: 0,
                        Z_BEST_SPEED: 1,
                        Z_BEST_COMPRESSION: 9,
                        Z_DEFAULT_COMPRESSION: -1,

                        Z_FILTERED: 1,
                        Z_HUFFMAN_ONLY: 2,
                        Z_RLE: 3,
                        Z_FIXED: 4,
                        Z_DEFAULT_STRATEGY: 0,

                        /* Possible values of the data_type field (though see inflate()) */
                        Z_BINARY: 0,
                        Z_TEXT: 1,
                        //Z_ASCII:                1, // = Z_TEXT (deprecated)
                        Z_UNKNOWN: 2,

                        /* The deflate compression method */
                        Z_DEFLATED: 8,
                        //Z_NULL:                 null // Use -1 or null inline, depending on var type
                      };
                    },
                    {},
                  ],
                  5: [
                    function (require, module, exports) {
                      // Note: we can't get significant speed boost here.
                      // So write code to minimize size - no pregenerated tables
                      // and array tools dependencies.

                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      // Use ordinary array, since untyped makes no boost here
                      function makeTable() {
                        var c,
                          table = [];

                        for (var n = 0; n < 256; n++) {
                          c = n;
                          for (var k = 0; k < 8; k++) {
                            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
                          }
                          table[n] = c;
                        }

                        return table;
                      }

                      // Create table on load. Just 255 signed longs. Not a problem.
                      var crcTable = makeTable();

                      function crc32(crc, buf, len, pos) {
                        var t = crcTable,
                          end = pos + len;

                        crc ^= -1;

                        for (var i = pos; i < end; i++) {
                          crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff];
                        }

                        return crc ^ -1; // >>> 0;
                      }

                      module.exports = crc32;
                    },
                    {},
                  ],
                  6: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      function GZheader() {
                        /* true if compressed data believed to be text */
                        this.text = 0;
                        /* modification time */
                        this.time = 0;
                        /* extra flags (not used when writing a gzip file) */
                        this.xflags = 0;
                        /* operating system */
                        this.os = 0;
                        /* pointer to extra field or Z_NULL if none */
                        this.extra = null;
                        /* extra field length (valid if extra != Z_NULL) */
                        this.extra_len = 0; // Actually, we don't need it in JS,
                        // but leave for few code modifications

                        //
                        // Setup limits is not necessary because in js we should not preallocate memory
                        // for inflate use constant limit in 65536 bytes
                        //

                        /* space at extra (only when reading header) */
                        // this.extra_max  = 0;
                        /* pointer to zero-terminated file name or Z_NULL */
                        this.name = '';
                        /* space at name (only when reading header) */
                        // this.name_max   = 0;
                        /* pointer to zero-terminated comment or Z_NULL */
                        this.comment = '';
                        /* space at comment (only when reading header) */
                        // this.comm_max   = 0;
                        /* true if there was or will be a header crc */
                        this.hcrc = 0;
                        /* true when done reading gzip header (not used when writing a gzip file) */
                        this.done = false;
                      }

                      module.exports = GZheader;
                    },
                    {},
                  ],
                  7: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      // See state defs from inflate.js
                      var BAD = 30; /* got a data error -- remain here until reset */
                      var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

                      /*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
                      module.exports = function inflate_fast(strm, start) {
                        var state;
                        var _in; /* local strm.input */
                        var last; /* have enough input while in < last */
                        var _out; /* local strm.output */
                        var beg; /* inflate()'s initial strm.output */
                        var end; /* while out < end, enough space available */
                        //#ifdef INFLATE_STRICT
                        var dmax; /* maximum distance from zlib header */
                        //#endif
                        var wsize; /* window size or zero if not using window */
                        var whave; /* valid bytes in the window */
                        var wnext; /* window write index */
                        // Use `s_window` instead `window`, avoid conflict with instrumentation tools
                        var s_window; /* allocated sliding window, if wsize != 0 */
                        var hold; /* local strm.hold */
                        var bits; /* local strm.bits */
                        var lcode; /* local strm.lencode */
                        var dcode; /* local strm.distcode */
                        var lmask; /* mask for first level of length codes */
                        var dmask; /* mask for first level of distance codes */
                        var here; /* retrieved table entry */
                        var op; /* code bits, operation, extra bits, or */
                        /*  window position, window bytes to copy */
                        var len; /* match length, unused bytes */
                        var dist; /* match distance */
                        var from; /* where to copy match from */
                        var from_source;

                        var input, output; // JS specific, because we have no pointers

                        /* copy state to local variables */
                        state = strm.state;
                        //here = state.here;
                        _in = strm.next_in;
                        input = strm.input;
                        last = _in + (strm.avail_in - 5);
                        _out = strm.next_out;
                        output = strm.output;
                        beg = _out - (start - strm.avail_out);
                        end = _out + (strm.avail_out - 257);
                        //#ifdef INFLATE_STRICT
                        dmax = state.dmax;
                        //#endif
                        wsize = state.wsize;
                        whave = state.whave;
                        wnext = state.wnext;
                        s_window = state.window;
                        hold = state.hold;
                        bits = state.bits;
                        lcode = state.lencode;
                        dcode = state.distcode;
                        lmask = (1 << state.lenbits) - 1;
                        dmask = (1 << state.distbits) - 1;

                        /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

                        top: do {
                          if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                          }

                          here = lcode[hold & lmask];

                          dolen: for (;;) {
                            // Goto emulation
                            op = here >>> 24 /*here.bits*/;
                            hold >>>= op;
                            bits -= op;
                            op = (here >>> 16) & 0xff /*here.op*/;
                            if (op === 0) {
                              /* literal */
                              //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                              //        "inflate:         literal '%c'\n" :
                              //        "inflate:         literal 0x%02x\n", here.val));
                              output[_out++] = here & 0xffff /*here.val*/;
                            } else if (op & 16) {
                              /* length base */
                              len = here & 0xffff /*here.val*/;
                              op &= 15; /* number of extra bits */
                              if (op) {
                                if (bits < op) {
                                  hold += input[_in++] << bits;
                                  bits += 8;
                                }
                                len += hold & ((1 << op) - 1);
                                hold >>>= op;
                                bits -= op;
                              }
                              //Tracevv((stderr, "inflate:         length %u\n", len));
                              if (bits < 15) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                hold += input[_in++] << bits;
                                bits += 8;
                              }
                              here = dcode[hold & dmask];

                              dodist: for (;;) {
                                // goto emulation
                                op = here >>> 24 /*here.bits*/;
                                hold >>>= op;
                                bits -= op;
                                op = (here >>> 16) & 0xff /*here.op*/;

                                if (op & 16) {
                                  /* distance base */
                                  dist = here & 0xffff /*here.val*/;
                                  op &= 15; /* number of extra bits */
                                  if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                    if (bits < op) {
                                      hold += input[_in++] << bits;
                                      bits += 8;
                                    }
                                  }
                                  dist += hold & ((1 << op) - 1);
                                  //#ifdef INFLATE_STRICT
                                  if (dist > dmax) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break top;
                                  }
                                  //#endif
                                  hold >>>= op;
                                  bits -= op;
                                  //Tracevv((stderr, "inflate:         distance %u\n", dist));
                                  op = _out - beg; /* max distance in output */
                                  if (dist > op) {
                                    /* see if copy from window */
                                    op =
                                      dist - op; /* distance back in window */
                                    if (op > whave) {
                                      if (state.sane) {
                                        strm.msg =
                                          'invalid distance too far back';
                                        state.mode = BAD;
                                        break top;
                                      }

                                      // (!) This block is disabled in zlib defaults,
                                      // don't enable it for binary compatibility
                                      //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                      //                if (len <= op - whave) {
                                      //                  do {
                                      //                    output[_out++] = 0;
                                      //                  } while (--len);
                                      //                  continue top;
                                      //                }
                                      //                len -= op - whave;
                                      //                do {
                                      //                  output[_out++] = 0;
                                      //                } while (--op > whave);
                                      //                if (op === 0) {
                                      //                  from = _out - dist;
                                      //                  do {
                                      //                    output[_out++] = output[from++];
                                      //                  } while (--len);
                                      //                  continue top;
                                      //                }
                                      //#endif
                                    }
                                    from = 0; // window index
                                    from_source = s_window;
                                    if (wnext === 0) {
                                      /* very common case */
                                      from += wsize - op;
                                      if (op < len) {
                                        /* some from window */
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from =
                                          _out - dist; /* rest from output */
                                        from_source = output;
                                      }
                                    } else if (wnext < op) {
                                      /* wrap around window */
                                      from += wsize + wnext - op;
                                      op -= wnext;
                                      if (op < len) {
                                        /* some from end of window */
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                          /* some from start of window */
                                          op = wnext;
                                          len -= op;
                                          do {
                                            output[_out++] = s_window[from++];
                                          } while (--op);
                                          from =
                                            _out - dist; /* rest from output */
                                          from_source = output;
                                        }
                                      }
                                    } else {
                                      /* contiguous in window */
                                      from += wnext - op;
                                      if (op < len) {
                                        /* some from window */
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from =
                                          _out - dist; /* rest from output */
                                        from_source = output;
                                      }
                                    }
                                    while (len > 2) {
                                      output[_out++] = from_source[from++];
                                      output[_out++] = from_source[from++];
                                      output[_out++] = from_source[from++];
                                      len -= 3;
                                    }
                                    if (len) {
                                      output[_out++] = from_source[from++];
                                      if (len > 1) {
                                        output[_out++] = from_source[from++];
                                      }
                                    }
                                  } else {
                                    from =
                                      _out - dist; /* copy direct from output */
                                    do {
                                      /* minimum length is three */
                                      output[_out++] = output[from++];
                                      output[_out++] = output[from++];
                                      output[_out++] = output[from++];
                                      len -= 3;
                                    } while (len > 2);
                                    if (len) {
                                      output[_out++] = output[from++];
                                      if (len > 1) {
                                        output[_out++] = output[from++];
                                      }
                                    }
                                  }
                                } else if ((op & 64) === 0) {
                                  /* 2nd level distance code */
                                  here =
                                    dcode[
                                      (here & 0xffff) /*here.val*/ +
                                        (hold & ((1 << op) - 1))
                                    ];
                                  continue dodist;
                                } else {
                                  strm.msg = 'invalid distance code';
                                  state.mode = BAD;
                                  break top;
                                }

                                break; // need to emulate goto via "continue"
                              }
                            } else if ((op & 64) === 0) {
                              /* 2nd level length code */
                              here =
                                lcode[
                                  (here & 0xffff) /*here.val*/ +
                                    (hold & ((1 << op) - 1))
                                ];
                              continue dolen;
                            } else if (op & 32) {
                              /* end-of-block */
                              //Tracevv((stderr, "inflate:         end of block\n"));
                              state.mode = TYPE;
                              break top;
                            } else {
                              strm.msg = 'invalid literal/length code';
                              state.mode = BAD;
                              break top;
                            }

                            break; // need to emulate goto via "continue"
                          }
                        } while (_in < last && _out < end);

                        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
                        len = bits >> 3;
                        _in -= len;
                        bits -= len << 3;
                        hold &= (1 << bits) - 1;

                        /* update state and return */
                        strm.next_in = _in;
                        strm.next_out = _out;
                        strm.avail_in =
                          _in < last ? 5 + (last - _in) : 5 - (_in - last);
                        strm.avail_out =
                          _out < end ? 257 + (end - _out) : 257 - (_out - end);
                        state.hold = hold;
                        state.bits = bits;
                        return;
                      };
                    },
                    {},
                  ],
                  8: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      var utils = require('../utils/common');
                      var adler32 = require('./adler32');
                      var crc32 = require('./crc32');
                      var inflate_fast = require('./inffast');
                      var inflate_table = require('./inftrees');

                      var CODES = 0;
                      var LENS = 1;
                      var DISTS = 2;

                      /* Public constants ==========================================================*/
                      /* ===========================================================================*/

                      /* Allowed flush values; see deflate() and inflate() below for details */
                      //var Z_NO_FLUSH      = 0;
                      //var Z_PARTIAL_FLUSH = 1;
                      //var Z_SYNC_FLUSH    = 2;
                      //var Z_FULL_FLUSH    = 3;
                      var Z_FINISH = 4;
                      var Z_BLOCK = 5;
                      var Z_TREES = 6;

                      /* Return codes for the compression/decompression functions. Negative values
                       * are errors, positive values are used for special but normal events.
                       */
                      var Z_OK = 0;
                      var Z_STREAM_END = 1;
                      var Z_NEED_DICT = 2;
                      //var Z_ERRNO         = -1;
                      var Z_STREAM_ERROR = -2;
                      var Z_DATA_ERROR = -3;
                      var Z_MEM_ERROR = -4;
                      var Z_BUF_ERROR = -5;
                      //var Z_VERSION_ERROR = -6;

                      /* The deflate compression method */
                      var Z_DEFLATED = 8;

                      /* STATES ====================================================================*/
                      /* ===========================================================================*/

                      var HEAD = 1; /* i: waiting for magic header */
                      var FLAGS = 2; /* i: waiting for method and flags (gzip) */
                      var TIME = 3; /* i: waiting for modification time (gzip) */
                      var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
                      var EXLEN = 5; /* i: waiting for extra length (gzip) */
                      var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
                      var NAME = 7; /* i: waiting for end of file name (gzip) */
                      var COMMENT = 8; /* i: waiting for end of comment (gzip) */
                      var HCRC = 9; /* i: waiting for header crc (gzip) */
                      var DICTID = 10; /* i: waiting for dictionary check value */
                      var DICT = 11; /* waiting for inflateSetDictionary() call */
                      var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
                      var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
                      var STORED = 14; /* i: waiting for stored size (length and complement) */
                      var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
                      var COPY = 16; /* i/o: waiting for input or output to copy stored block */
                      var TABLE = 17; /* i: waiting for dynamic block table lengths */
                      var LENLENS = 18; /* i: waiting for code length code lengths */
                      var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
                      var LEN_ = 20; /* i: same as LEN below, but only first time in */
                      var LEN = 21; /* i: waiting for length/lit/eob code */
                      var LENEXT = 22; /* i: waiting for length extra bits */
                      var DIST = 23; /* i: waiting for distance code */
                      var DISTEXT = 24; /* i: waiting for distance extra bits */
                      var MATCH = 25; /* o: waiting for output space to copy string */
                      var LIT = 26; /* o: waiting for output space to write literal */
                      var CHECK = 27; /* i: waiting for 32-bit check value */
                      var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
                      var DONE = 29; /* finished check, done -- remain here until reset */
                      var BAD = 30; /* got a data error -- remain here until reset */
                      var MEM = 31; /* got an inflate() memory error -- remain here until reset */
                      var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

                      /* ===========================================================================*/

                      var ENOUGH_LENS = 852;
                      var ENOUGH_DISTS = 592;
                      //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

                      var MAX_WBITS = 15;
                      /* 32K LZ77 window */
                      var DEF_WBITS = MAX_WBITS;

                      function zswap32(q) {
                        return (
                          ((q >>> 24) & 0xff) +
                          ((q >>> 8) & 0xff00) +
                          ((q & 0xff00) << 8) +
                          ((q & 0xff) << 24)
                        );
                      }

                      function InflateState() {
                        this.mode = 0; /* current inflate mode */
                        this.last = false; /* true if processing last block */
                        this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
                        this.havedict = false; /* true if dictionary provided */
                        this.flags = 0; /* gzip header method and flags (0 if zlib) */
                        this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
                        this.check = 0; /* protected copy of check value */
                        this.total = 0; /* protected copy of output count */
                        // TODO: may be {}
                        this.head = null; /* where to save gzip header information */

                        /* sliding window */
                        this.wbits = 0; /* log base 2 of requested window size */
                        this.wsize = 0; /* window size or zero if not using window */
                        this.whave = 0; /* valid bytes in the window */
                        this.wnext = 0; /* window write index */
                        this.window = null; /* allocated sliding window, if needed */

                        /* bit accumulator */
                        this.hold = 0; /* input bit accumulator */
                        this.bits = 0; /* number of bits in "in" */

                        /* for string and stored block copying */
                        this.length = 0; /* literal or length of data to copy */
                        this.offset = 0; /* distance back to copy string from */

                        /* for table and code decoding */
                        this.extra = 0; /* extra bits needed */

                        /* fixed and dynamic code tables */
                        this.lencode = null; /* starting table for length/literal codes */
                        this.distcode = null; /* starting table for distance codes */
                        this.lenbits = 0; /* index bits for lencode */
                        this.distbits = 0; /* index bits for distcode */

                        /* dynamic table building */
                        this.ncode = 0; /* number of code length code lengths */
                        this.nlen = 0; /* number of length code lengths */
                        this.ndist = 0; /* number of distance code lengths */
                        this.have = 0; /* number of code lengths in lens[] */
                        this.next = null; /* next available space in codes[] */

                        this.lens = new utils.Buf16(
                          320
                        ); /* temporary storage for code lengths */
                        this.work = new utils.Buf16(
                          288
                        ); /* work area for code table building */

                        /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
                        //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
                        this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
                        this.distdyn = null; /* dynamic table for distance codes (JS specific) */
                        this.sane = 0; /* if false, allow invalid distance too far */
                        this.back = 0; /* bits back of last unprocessed length/lit */
                        this.was = 0; /* initial length of match */
                      }

                      function inflateResetKeep(strm) {
                        var state;

                        if (!strm || !strm.state) {
                          return Z_STREAM_ERROR;
                        }
                        state = strm.state;
                        strm.total_in = strm.total_out = state.total = 0;
                        strm.msg = ''; /*Z_NULL*/
                        if (state.wrap) {
                          /* to support ill-conceived Java test suite */
                          strm.adler = state.wrap & 1;
                        }
                        state.mode = HEAD;
                        state.last = 0;
                        state.havedict = 0;
                        state.dmax = 32768;
                        state.head = null /*Z_NULL*/;
                        state.hold = 0;
                        state.bits = 0;
                        //state.lencode = state.distcode = state.next = state.codes;
                        state.lencode = state.lendyn = new utils.Buf32(
                          ENOUGH_LENS
                        );
                        state.distcode = state.distdyn = new utils.Buf32(
                          ENOUGH_DISTS
                        );

                        state.sane = 1;
                        state.back = -1;
                        //Tracev((stderr, "inflate: reset\n"));
                        return Z_OK;
                      }

                      function inflateReset(strm) {
                        var state;

                        if (!strm || !strm.state) {
                          return Z_STREAM_ERROR;
                        }
                        state = strm.state;
                        state.wsize = 0;
                        state.whave = 0;
                        state.wnext = 0;
                        return inflateResetKeep(strm);
                      }

                      function inflateReset2(strm, windowBits) {
                        var wrap;
                        var state;

                        /* get the state */
                        if (!strm || !strm.state) {
                          return Z_STREAM_ERROR;
                        }
                        state = strm.state;

                        /* extract wrap request from windowBits parameter */
                        if (windowBits < 0) {
                          wrap = 0;
                          windowBits = -windowBits;
                        } else {
                          wrap = (windowBits >> 4) + 1;
                          if (windowBits < 48) {
                            windowBits &= 15;
                          }
                        }

                        /* set number of window bits, free window if different */
                        if (windowBits && (windowBits < 8 || windowBits > 15)) {
                          return Z_STREAM_ERROR;
                        }
                        if (
                          state.window !== null &&
                          state.wbits !== windowBits
                        ) {
                          state.window = null;
                        }

                        /* update state and reset the rest of it */
                        state.wrap = wrap;
                        state.wbits = windowBits;
                        return inflateReset(strm);
                      }

                      function inflateInit2(strm, windowBits) {
                        var ret;
                        var state;

                        if (!strm) {
                          return Z_STREAM_ERROR;
                        }
                        //strm.msg = Z_NULL;                 /* in case we return an error */

                        state = new InflateState();

                        //if (state === Z_NULL) return Z_MEM_ERROR;
                        //Tracev((stderr, "inflate: allocated\n"));
                        strm.state = state;
                        state.window = null /*Z_NULL*/;
                        ret = inflateReset2(strm, windowBits);
                        if (ret !== Z_OK) {
                          strm.state = null /*Z_NULL*/;
                        }
                        return ret;
                      }

                      function inflateInit(strm) {
                        return inflateInit2(strm, DEF_WBITS);
                      }

                      /*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
                      var virgin = true;

                      var lenfix, distfix; // We have no pointers in JS, so keep tables separate

                      function fixedtables(state) {
                        /* build fixed huffman tables if first call (may not be thread safe) */
                        if (virgin) {
                          var sym;

                          lenfix = new utils.Buf32(512);
                          distfix = new utils.Buf32(32);

                          /* literal/length table */
                          sym = 0;
                          while (sym < 144) {
                            state.lens[sym++] = 8;
                          }
                          while (sym < 256) {
                            state.lens[sym++] = 9;
                          }
                          while (sym < 280) {
                            state.lens[sym++] = 7;
                          }
                          while (sym < 288) {
                            state.lens[sym++] = 8;
                          }

                          inflate_table(
                            LENS,
                            state.lens,
                            0,
                            288,
                            lenfix,
                            0,
                            state.work,
                            { bits: 9 }
                          );

                          /* distance table */
                          sym = 0;
                          while (sym < 32) {
                            state.lens[sym++] = 5;
                          }

                          inflate_table(
                            DISTS,
                            state.lens,
                            0,
                            32,
                            distfix,
                            0,
                            state.work,
                            { bits: 5 }
                          );

                          /* do this just once */
                          virgin = false;
                        }

                        state.lencode = lenfix;
                        state.lenbits = 9;
                        state.distcode = distfix;
                        state.distbits = 5;
                      }

                      /*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
                      function updatewindow(strm, src, end, copy) {
                        var dist;
                        var state = strm.state;

                        /* if it hasn't been done already, allocate space for the window */
                        if (state.window === null) {
                          state.wsize = 1 << state.wbits;
                          state.wnext = 0;
                          state.whave = 0;

                          state.window = new utils.Buf8(state.wsize);
                        }

                        /* copy state->wsize or less output bytes into the circular window */
                        if (copy >= state.wsize) {
                          utils.arraySet(
                            state.window,
                            src,
                            end - state.wsize,
                            state.wsize,
                            0
                          );
                          state.wnext = 0;
                          state.whave = state.wsize;
                        } else {
                          dist = state.wsize - state.wnext;
                          if (dist > copy) {
                            dist = copy;
                          }
                          //zmemcpy(state->window + state->wnext, end - copy, dist);
                          utils.arraySet(
                            state.window,
                            src,
                            end - copy,
                            dist,
                            state.wnext
                          );
                          copy -= dist;
                          if (copy) {
                            //zmemcpy(state->window, end - copy, copy);
                            utils.arraySet(
                              state.window,
                              src,
                              end - copy,
                              copy,
                              0
                            );
                            state.wnext = copy;
                            state.whave = state.wsize;
                          } else {
                            state.wnext += dist;
                            if (state.wnext === state.wsize) {
                              state.wnext = 0;
                            }
                            if (state.whave < state.wsize) {
                              state.whave += dist;
                            }
                          }
                        }
                        return 0;
                      }

                      function inflate(strm, flush) {
                        var state;
                        var input, output; // input/output buffers
                        var next; /* next input INDEX */
                        var put; /* next output INDEX */
                        var have, left; /* available input and output */
                        var hold; /* bit buffer */
                        var bits; /* bits in bit buffer */
                        var _in,
                          _out; /* save starting available input and output */
                        var copy; /* number of stored or match bytes to copy */
                        var from; /* where to copy match bytes from */
                        var from_source;
                        var here = 0; /* current decoding table entry */
                        var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
                        //var last;                   /* parent table entry */
                        var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
                        var len; /* length to copy for repeats, bits to drop */
                        var ret; /* return code */
                        var hbuf = new utils.Buf8(
                          4
                        ); /* buffer for gzip header crc calculation */
                        var opts;

                        var n; // temporary var for NEED_BITS

                        var order =
                          /* permutation of code lengths */
                          [
                            16,
                            17,
                            18,
                            0,
                            8,
                            7,
                            9,
                            6,
                            10,
                            5,
                            11,
                            4,
                            12,
                            3,
                            13,
                            2,
                            14,
                            1,
                            15,
                          ];

                        if (
                          !strm ||
                          !strm.state ||
                          !strm.output ||
                          (!strm.input && strm.avail_in !== 0)
                        ) {
                          return Z_STREAM_ERROR;
                        }

                        state = strm.state;
                        if (state.mode === TYPE) {
                          state.mode = TYPEDO;
                        } /* skip check */

                        //--- LOAD() ---
                        put = strm.next_out;
                        output = strm.output;
                        left = strm.avail_out;
                        next = strm.next_in;
                        input = strm.input;
                        have = strm.avail_in;
                        hold = state.hold;
                        bits = state.bits;
                        //---

                        _in = have;
                        _out = left;
                        ret = Z_OK;

                        // goto emulation
                        inf_leave: for (;;) {
                          switch (state.mode) {
                            case HEAD:
                              if (state.wrap === 0) {
                                state.mode = TYPEDO;
                                break;
                              }
                              //=== NEEDBITS(16);
                              while (bits < 16) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              if (state.wrap & 2 && hold === 0x8b1f) {
                                /* gzip header */
                                state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//

                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                state.mode = FLAGS;
                                break;
                              }
                              state.flags = 0; /* expect zlib header */
                              if (state.head) {
                                state.head.done = false;
                              }
                              if (
                                !(
                                  state.wrap & 1
                                ) /* check if zlib header allowed */ ||
                                (((hold & 0xff) /*BITS(8)*/ << 8) +
                                  (hold >> 8)) %
                                  31
                              ) {
                                strm.msg = 'incorrect header check';
                                state.mode = BAD;
                                break;
                              }
                              if ((hold & 0x0f) /*BITS(4)*/ !== Z_DEFLATED) {
                                strm.msg = 'unknown compression method';
                                state.mode = BAD;
                                break;
                              }
                              //--- DROPBITS(4) ---//
                              hold >>>= 4;
                              bits -= 4;
                              //---//
                              len = (hold & 0x0f) /*BITS(4)*/ + 8;
                              if (state.wbits === 0) {
                                state.wbits = len;
                              } else if (len > state.wbits) {
                                strm.msg = 'invalid window size';
                                state.mode = BAD;
                                break;
                              }
                              state.dmax = 1 << len;
                              //Tracev((stderr, "inflate:   zlib header ok\n"));
                              strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
                              state.mode = hold & 0x200 ? DICTID : TYPE;
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              break;
                            case FLAGS:
                              //=== NEEDBITS(16); */
                              while (bits < 16) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              state.flags = hold;
                              if ((state.flags & 0xff) !== Z_DEFLATED) {
                                strm.msg = 'unknown compression method';
                                state.mode = BAD;
                                break;
                              }
                              if (state.flags & 0xe000) {
                                strm.msg = 'unknown header flags set';
                                state.mode = BAD;
                                break;
                              }
                              if (state.head) {
                                state.head.text = (hold >> 8) & 1;
                              }
                              if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                              }
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              state.mode = TIME;
                            /* falls through */
                            case TIME:
                              //=== NEEDBITS(32); */
                              while (bits < 32) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              if (state.head) {
                                state.head.time = hold;
                              }
                              if (state.flags & 0x0200) {
                                //=== CRC4(state.check, hold)
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                hbuf[2] = (hold >>> 16) & 0xff;
                                hbuf[3] = (hold >>> 24) & 0xff;
                                state.check = crc32(state.check, hbuf, 4, 0);
                                //===
                              }
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              state.mode = OS;
                            /* falls through */
                            case OS:
                              //=== NEEDBITS(16); */
                              while (bits < 16) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              if (state.head) {
                                state.head.xflags = hold & 0xff;
                                state.head.os = hold >> 8;
                              }
                              if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                              }
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              state.mode = EXLEN;
                            /* falls through */
                            case EXLEN:
                              if (state.flags & 0x0400) {
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                state.length = hold;
                                if (state.head) {
                                  state.head.extra_len = hold;
                                }
                                if (state.flags & 0x0200) {
                                  //=== CRC2(state.check, hold);
                                  hbuf[0] = hold & 0xff;
                                  hbuf[1] = (hold >>> 8) & 0xff;
                                  state.check = crc32(state.check, hbuf, 2, 0);
                                  //===//
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                              } else if (state.head) {
                                state.head.extra = null /*Z_NULL*/;
                              }
                              state.mode = EXTRA;
                            /* falls through */
                            case EXTRA:
                              if (state.flags & 0x0400) {
                                copy = state.length;
                                if (copy > have) {
                                  copy = have;
                                }
                                if (copy) {
                                  if (state.head) {
                                    len = state.head.extra_len - state.length;
                                    if (!state.head.extra) {
                                      // Use untyped array for more convenient processing later
                                      state.head.extra = new Array(
                                        state.head.extra_len
                                      );
                                    }
                                    utils.arraySet(
                                      state.head.extra,
                                      input,
                                      next,
                                      // extra field is limited to 65536 bytes
                                      // - no need for additional size check
                                      copy,
                                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                      len
                                    );
                                    //zmemcpy(state.head.extra + len, next,
                                    //        len + copy > state.head.extra_max ?
                                    //        state.head.extra_max - len : copy);
                                  }
                                  if (state.flags & 0x0200) {
                                    state.check = crc32(
                                      state.check,
                                      input,
                                      copy,
                                      next
                                    );
                                  }
                                  have -= copy;
                                  next += copy;
                                  state.length -= copy;
                                }
                                if (state.length) {
                                  break inf_leave;
                                }
                              }
                              state.length = 0;
                              state.mode = NAME;
                            /* falls through */
                            case NAME:
                              if (state.flags & 0x0800) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                copy = 0;
                                do {
                                  // TODO: 2 or 1 bytes?
                                  len = input[next + copy++];
                                  /* use constant limit because in js we should not preallocate memory */
                                  if (
                                    state.head &&
                                    len &&
                                    state.length < 65536 /*state.head.name_max*/
                                  ) {
                                    state.head.name += String.fromCharCode(len);
                                  }
                                } while (len && copy < have);

                                if (state.flags & 0x0200) {
                                  state.check = crc32(
                                    state.check,
                                    input,
                                    copy,
                                    next
                                  );
                                }
                                have -= copy;
                                next += copy;
                                if (len) {
                                  break inf_leave;
                                }
                              } else if (state.head) {
                                state.head.name = null;
                              }
                              state.length = 0;
                              state.mode = COMMENT;
                            /* falls through */
                            case COMMENT:
                              if (state.flags & 0x1000) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                copy = 0;
                                do {
                                  len = input[next + copy++];
                                  /* use constant limit because in js we should not preallocate memory */
                                  if (
                                    state.head &&
                                    len &&
                                    state.length < 65536 /*state.head.comm_max*/
                                  ) {
                                    state.head.comment += String.fromCharCode(
                                      len
                                    );
                                  }
                                } while (len && copy < have);
                                if (state.flags & 0x0200) {
                                  state.check = crc32(
                                    state.check,
                                    input,
                                    copy,
                                    next
                                  );
                                }
                                have -= copy;
                                next += copy;
                                if (len) {
                                  break inf_leave;
                                }
                              } else if (state.head) {
                                state.head.comment = null;
                              }
                              state.mode = HCRC;
                            /* falls through */
                            case HCRC:
                              if (state.flags & 0x0200) {
                                //=== NEEDBITS(16); */
                                while (bits < 16) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                if (hold !== (state.check & 0xffff)) {
                                  strm.msg = 'header crc mismatch';
                                  state.mode = BAD;
                                  break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                              }
                              if (state.head) {
                                state.head.hcrc = (state.flags >> 9) & 1;
                                state.head.done = true;
                              }
                              strm.adler = state.check = 0;
                              state.mode = TYPE;
                              break;
                            case DICTID:
                              //=== NEEDBITS(32); */
                              while (bits < 32) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              strm.adler = state.check = zswap32(hold);
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              state.mode = DICT;
                            /* falls through */
                            case DICT:
                              if (state.havedict === 0) {
                                //--- RESTORE() ---
                                strm.next_out = put;
                                strm.avail_out = left;
                                strm.next_in = next;
                                strm.avail_in = have;
                                state.hold = hold;
                                state.bits = bits;
                                //---
                                return Z_NEED_DICT;
                              }
                              strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
                              state.mode = TYPE;
                            /* falls through */
                            case TYPE:
                              if (flush === Z_BLOCK || flush === Z_TREES) {
                                break inf_leave;
                              }
                            /* falls through */
                            case TYPEDO:
                              if (state.last) {
                                //--- BYTEBITS() ---//
                                hold >>>= bits & 7;
                                bits -= bits & 7;
                                //---//
                                state.mode = CHECK;
                                break;
                              }
                              //=== NEEDBITS(3); */
                              while (bits < 3) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              state.last = hold & 0x01 /*BITS(1)*/;
                              //--- DROPBITS(1) ---//
                              hold >>>= 1;
                              bits -= 1;
                              //---//

                              switch (hold & 0x03 /*BITS(2)*/) {
                                case 0 /* stored block */:
                                  //Tracev((stderr, "inflate:     stored block%s\n",
                                  //        state.last ? " (last)" : ""));
                                  state.mode = STORED;
                                  break;
                                case 1 /* fixed block */:
                                  fixedtables(state);
                                  //Tracev((stderr, "inflate:     fixed codes block%s\n",
                                  //        state.last ? " (last)" : ""));
                                  state.mode = LEN_; /* decode codes */
                                  if (flush === Z_TREES) {
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                    break inf_leave;
                                  }
                                  break;
                                case 2 /* dynamic block */:
                                  //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                  //        state.last ? " (last)" : ""));
                                  state.mode = TABLE;
                                  break;
                                case 3:
                                  strm.msg = 'invalid block type';
                                  state.mode = BAD;
                              }
                              //--- DROPBITS(2) ---//
                              hold >>>= 2;
                              bits -= 2;
                              //---//
                              break;
                            case STORED:
                              //--- BYTEBITS() ---// /* go to byte boundary */
                              hold >>>= bits & 7;
                              bits -= bits & 7;
                              //---//
                              //=== NEEDBITS(32); */
                              while (bits < 32) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              if (
                                (hold & 0xffff) !==
                                ((hold >>> 16) ^ 0xffff)
                              ) {
                                strm.msg = 'invalid stored block lengths';
                                state.mode = BAD;
                                break;
                              }
                              state.length = hold & 0xffff;
                              //Tracev((stderr, "inflate:       stored length %u\n",
                              //        state.length));
                              //=== INITBITS();
                              hold = 0;
                              bits = 0;
                              //===//
                              state.mode = COPY_;
                              if (flush === Z_TREES) {
                                break inf_leave;
                              }
                            /* falls through */
                            case COPY_:
                              state.mode = COPY;
                            /* falls through */
                            case COPY:
                              copy = state.length;
                              if (copy) {
                                if (copy > have) {
                                  copy = have;
                                }
                                if (copy > left) {
                                  copy = left;
                                }
                                if (copy === 0) {
                                  break inf_leave;
                                }
                                //--- zmemcpy(put, next, copy); ---
                                utils.arraySet(output, input, next, copy, put);
                                //---//
                                have -= copy;
                                next += copy;
                                left -= copy;
                                put += copy;
                                state.length -= copy;
                                break;
                              }
                              //Tracev((stderr, "inflate:       stored end\n"));
                              state.mode = TYPE;
                              break;
                            case TABLE:
                              //=== NEEDBITS(14); */
                              while (bits < 14) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              //===//
                              state.nlen = (hold & 0x1f) /*BITS(5)*/ + 257;
                              //--- DROPBITS(5) ---//
                              hold >>>= 5;
                              bits -= 5;
                              //---//
                              state.ndist = (hold & 0x1f) /*BITS(5)*/ + 1;
                              //--- DROPBITS(5) ---//
                              hold >>>= 5;
                              bits -= 5;
                              //---//
                              state.ncode = (hold & 0x0f) /*BITS(4)*/ + 4;
                              //--- DROPBITS(4) ---//
                              hold >>>= 4;
                              bits -= 4;
                              //---//
                              //#ifndef PKZIP_BUG_WORKAROUND
                              if (state.nlen > 286 || state.ndist > 30) {
                                strm.msg =
                                  'too many length or distance symbols';
                                state.mode = BAD;
                                break;
                              }
                              //#endif
                              //Tracev((stderr, "inflate:       table sizes ok\n"));
                              state.have = 0;
                              state.mode = LENLENS;
                            /* falls through */
                            case LENLENS:
                              while (state.have < state.ncode) {
                                //=== NEEDBITS(3);
                                while (bits < 3) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
                                //--- DROPBITS(3) ---//
                                hold >>>= 3;
                                bits -= 3;
                                //---//
                              }
                              while (state.have < 19) {
                                state.lens[order[state.have++]] = 0;
                              }
                              // We have separate tables & no pointers. 2 commented lines below not needed.
                              //state.next = state.codes;
                              //state.lencode = state.next;
                              // Switch to use dynamic table
                              state.lencode = state.lendyn;
                              state.lenbits = 7;

                              opts = { bits: state.lenbits };
                              ret = inflate_table(
                                CODES,
                                state.lens,
                                0,
                                19,
                                state.lencode,
                                0,
                                state.work,
                                opts
                              );
                              state.lenbits = opts.bits;

                              if (ret) {
                                strm.msg = 'invalid code lengths set';
                                state.mode = BAD;
                                break;
                              }
                              //Tracev((stderr, "inflate:       code lengths ok\n"));
                              state.have = 0;
                              state.mode = CODELENS;
                            /* falls through */
                            case CODELENS:
                              while (state.have < state.nlen + state.ndist) {
                                for (;;) {
                                  here =
                                    state.lencode[
                                      hold & ((1 << state.lenbits) - 1)
                                    ]; /*BITS(state.lenbits)*/
                                  here_bits = here >>> 24;
                                  here_op = (here >>> 16) & 0xff;
                                  here_val = here & 0xffff;

                                  if (here_bits <= bits) {
                                    break;
                                  }
                                  //--- PULLBYTE() ---//
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                  //---//
                                }
                                if (here_val < 16) {
                                  //--- DROPBITS(here.bits) ---//
                                  hold >>>= here_bits;
                                  bits -= here_bits;
                                  //---//
                                  state.lens[state.have++] = here_val;
                                } else {
                                  if (here_val === 16) {
                                    //=== NEEDBITS(here.bits + 2);
                                    n = here_bits + 2;
                                    while (bits < n) {
                                      if (have === 0) {
                                        break inf_leave;
                                      }
                                      have--;
                                      hold += input[next++] << bits;
                                      bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    if (state.have === 0) {
                                      strm.msg = 'invalid bit length repeat';
                                      state.mode = BAD;
                                      break;
                                    }
                                    len = state.lens[state.have - 1];
                                    copy = 3 + (hold & 0x03); //BITS(2);
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                  } else if (here_val === 17) {
                                    //=== NEEDBITS(here.bits + 3);
                                    n = here_bits + 3;
                                    while (bits < n) {
                                      if (have === 0) {
                                        break inf_leave;
                                      }
                                      have--;
                                      hold += input[next++] << bits;
                                      bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 3 + (hold & 0x07); //BITS(3);
                                    //--- DROPBITS(3) ---//
                                    hold >>>= 3;
                                    bits -= 3;
                                    //---//
                                  } else {
                                    //=== NEEDBITS(here.bits + 7);
                                    n = here_bits + 7;
                                    while (bits < n) {
                                      if (have === 0) {
                                        break inf_leave;
                                      }
                                      have--;
                                      hold += input[next++] << bits;
                                      bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 11 + (hold & 0x7f); //BITS(7);
                                    //--- DROPBITS(7) ---//
                                    hold >>>= 7;
                                    bits -= 7;
                                    //---//
                                  }
                                  if (
                                    state.have + copy >
                                    state.nlen + state.ndist
                                  ) {
                                    strm.msg = 'invalid bit length repeat';
                                    state.mode = BAD;
                                    break;
                                  }
                                  while (copy--) {
                                    state.lens[state.have++] = len;
                                  }
                                }
                              }

                              /* handle error breaks in while */
                              if (state.mode === BAD) {
                                break;
                              }

                              /* check for end-of-block code (better have one) */
                              if (state.lens[256] === 0) {
                                strm.msg =
                                  'invalid code -- missing end-of-block';
                                state.mode = BAD;
                                break;
                              }

                              /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
                              state.lenbits = 9;

                              opts = { bits: state.lenbits };
                              ret = inflate_table(
                                LENS,
                                state.lens,
                                0,
                                state.nlen,
                                state.lencode,
                                0,
                                state.work,
                                opts
                              );
                              // We have separate tables & no pointers. 2 commented lines below not needed.
                              // state.next_index = opts.table_index;
                              state.lenbits = opts.bits;
                              // state.lencode = state.next;

                              if (ret) {
                                strm.msg = 'invalid literal/lengths set';
                                state.mode = BAD;
                                break;
                              }

                              state.distbits = 6;
                              //state.distcode.copy(state.codes);
                              // Switch to use dynamic table
                              state.distcode = state.distdyn;
                              opts = { bits: state.distbits };
                              ret = inflate_table(
                                DISTS,
                                state.lens,
                                state.nlen,
                                state.ndist,
                                state.distcode,
                                0,
                                state.work,
                                opts
                              );
                              // We have separate tables & no pointers. 2 commented lines below not needed.
                              // state.next_index = opts.table_index;
                              state.distbits = opts.bits;
                              // state.distcode = state.next;

                              if (ret) {
                                strm.msg = 'invalid distances set';
                                state.mode = BAD;
                                break;
                              }
                              //Tracev((stderr, 'inflate:       codes ok\n'));
                              state.mode = LEN_;
                              if (flush === Z_TREES) {
                                break inf_leave;
                              }
                            /* falls through */
                            case LEN_:
                              state.mode = LEN;
                            /* falls through */
                            case LEN:
                              if (have >= 6 && left >= 258) {
                                //--- RESTORE() ---
                                strm.next_out = put;
                                strm.avail_out = left;
                                strm.next_in = next;
                                strm.avail_in = have;
                                state.hold = hold;
                                state.bits = bits;
                                //---
                                inflate_fast(strm, _out);
                                //--- LOAD() ---
                                put = strm.next_out;
                                output = strm.output;
                                left = strm.avail_out;
                                next = strm.next_in;
                                input = strm.input;
                                have = strm.avail_in;
                                hold = state.hold;
                                bits = state.bits;
                                //---

                                if (state.mode === TYPE) {
                                  state.back = -1;
                                }
                                break;
                              }
                              state.back = 0;
                              for (;;) {
                                here =
                                  state.lencode[
                                    hold & ((1 << state.lenbits) - 1)
                                  ]; /*BITS(state.lenbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if (here_bits <= bits) {
                                  break;
                                }
                                //--- PULLBYTE() ---//
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                              }
                              if (here_op && (here_op & 0xf0) === 0) {
                                last_bits = here_bits;
                                last_op = here_op;
                                last_val = here_val;
                                for (;;) {
                                  here =
                                    state.lencode[
                                      last_val +
                                        ((hold &
                                          ((1 << (last_bits + last_op)) -
                                            1)) /*BITS(last.bits + last.op)*/ >>
                                          last_bits)
                                    ];
                                  here_bits = here >>> 24;
                                  here_op = (here >>> 16) & 0xff;
                                  here_val = here & 0xffff;

                                  if (last_bits + here_bits <= bits) {
                                    break;
                                  }
                                  //--- PULLBYTE() ---//
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                  //---//
                                }
                                //--- DROPBITS(last.bits) ---//
                                hold >>>= last_bits;
                                bits -= last_bits;
                                //---//
                                state.back += last_bits;
                              }
                              //--- DROPBITS(here.bits) ---//
                              hold >>>= here_bits;
                              bits -= here_bits;
                              //---//
                              state.back += here_bits;
                              state.length = here_val;
                              if (here_op === 0) {
                                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                //        "inflate:         literal '%c'\n" :
                                //        "inflate:         literal 0x%02x\n", here.val));
                                state.mode = LIT;
                                break;
                              }
                              if (here_op & 32) {
                                //Tracevv((stderr, "inflate:         end of block\n"));
                                state.back = -1;
                                state.mode = TYPE;
                                break;
                              }
                              if (here_op & 64) {
                                strm.msg = 'invalid literal/length code';
                                state.mode = BAD;
                                break;
                              }
                              state.extra = here_op & 15;
                              state.mode = LENEXT;
                            /* falls through */
                            case LENEXT:
                              if (state.extra) {
                                //=== NEEDBITS(state.extra);
                                n = state.extra;
                                while (bits < n) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                state.length +=
                                  hold &
                                  ((1 << state.extra) -
                                    1) /*BITS(state.extra)*/;
                                //--- DROPBITS(state.extra) ---//
                                hold >>>= state.extra;
                                bits -= state.extra;
                                //---//
                                state.back += state.extra;
                              }
                              //Tracevv((stderr, "inflate:         length %u\n", state.length));
                              state.was = state.length;
                              state.mode = DIST;
                            /* falls through */
                            case DIST:
                              for (;;) {
                                here =
                                  state.distcode[
                                    hold & ((1 << state.distbits) - 1)
                                  ]; /*BITS(state.distbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if (here_bits <= bits) {
                                  break;
                                }
                                //--- PULLBYTE() ---//
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                              }
                              if ((here_op & 0xf0) === 0) {
                                last_bits = here_bits;
                                last_op = here_op;
                                last_val = here_val;
                                for (;;) {
                                  here =
                                    state.distcode[
                                      last_val +
                                        ((hold &
                                          ((1 << (last_bits + last_op)) -
                                            1)) /*BITS(last.bits + last.op)*/ >>
                                          last_bits)
                                    ];
                                  here_bits = here >>> 24;
                                  here_op = (here >>> 16) & 0xff;
                                  here_val = here & 0xffff;

                                  if (last_bits + here_bits <= bits) {
                                    break;
                                  }
                                  //--- PULLBYTE() ---//
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                  //---//
                                }
                                //--- DROPBITS(last.bits) ---//
                                hold >>>= last_bits;
                                bits -= last_bits;
                                //---//
                                state.back += last_bits;
                              }
                              //--- DROPBITS(here.bits) ---//
                              hold >>>= here_bits;
                              bits -= here_bits;
                              //---//
                              state.back += here_bits;
                              if (here_op & 64) {
                                strm.msg = 'invalid distance code';
                                state.mode = BAD;
                                break;
                              }
                              state.offset = here_val;
                              state.extra = here_op & 15;
                              state.mode = DISTEXT;
                            /* falls through */
                            case DISTEXT:
                              if (state.extra) {
                                //=== NEEDBITS(state.extra);
                                n = state.extra;
                                while (bits < n) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                state.offset +=
                                  hold &
                                  ((1 << state.extra) -
                                    1) /*BITS(state.extra)*/;
                                //--- DROPBITS(state.extra) ---//
                                hold >>>= state.extra;
                                bits -= state.extra;
                                //---//
                                state.back += state.extra;
                              }
                              //#ifdef INFLATE_STRICT
                              if (state.offset > state.dmax) {
                                strm.msg = 'invalid distance too far back';
                                state.mode = BAD;
                                break;
                              }
                              //#endif
                              //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                              state.mode = MATCH;
                            /* falls through */
                            case MATCH:
                              if (left === 0) {
                                break inf_leave;
                              }
                              copy = _out - left;
                              if (state.offset > copy) {
                                /* copy from window */
                                copy = state.offset - copy;
                                if (copy > state.whave) {
                                  if (state.sane) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break;
                                  }
                                  // (!) This block is disabled in zlib defaults,
                                  // don't enable it for binary compatibility
                                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                  //          Trace((stderr, "inflate.c too far\n"));
                                  //          copy -= state.whave;
                                  //          if (copy > state.length) { copy = state.length; }
                                  //          if (copy > left) { copy = left; }
                                  //          left -= copy;
                                  //          state.length -= copy;
                                  //          do {
                                  //            output[put++] = 0;
                                  //          } while (--copy);
                                  //          if (state.length === 0) { state.mode = LEN; }
                                  //          break;
                                  //#endif
                                }
                                if (copy > state.wnext) {
                                  copy -= state.wnext;
                                  from = state.wsize - copy;
                                } else {
                                  from = state.wnext - copy;
                                }
                                if (copy > state.length) {
                                  copy = state.length;
                                }
                                from_source = state.window;
                              } else {
                                /* copy from output */
                                from_source = output;
                                from = put - state.offset;
                                copy = state.length;
                              }
                              if (copy > left) {
                                copy = left;
                              }
                              left -= copy;
                              state.length -= copy;
                              do {
                                output[put++] = from_source[from++];
                              } while (--copy);
                              if (state.length === 0) {
                                state.mode = LEN;
                              }
                              break;
                            case LIT:
                              if (left === 0) {
                                break inf_leave;
                              }
                              output[put++] = state.length;
                              left--;
                              state.mode = LEN;
                              break;
                            case CHECK:
                              if (state.wrap) {
                                //=== NEEDBITS(32);
                                while (bits < 32) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  // Use '|' instead of '+' to make sure that result is signed
                                  hold |= input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                _out -= left;
                                strm.total_out += _out;
                                state.total += _out;
                                if (_out) {
                                  strm.adler = state.check =
                                    /*UPDATE(state.check, put - _out, _out);*/
                                    state.flags
                                      ? crc32(
                                          state.check,
                                          output,
                                          _out,
                                          put - _out
                                        )
                                      : adler32(
                                          state.check,
                                          output,
                                          _out,
                                          put - _out
                                        );
                                }
                                _out = left;
                                // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                                if (
                                  (state.flags ? hold : zswap32(hold)) !==
                                  state.check
                                ) {
                                  strm.msg = 'incorrect data check';
                                  state.mode = BAD;
                                  break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                //Tracev((stderr, "inflate:   check matches trailer\n"));
                              }
                              state.mode = LENGTH;
                            /* falls through */
                            case LENGTH:
                              if (state.wrap && state.flags) {
                                //=== NEEDBITS(32);
                                while (bits < 32) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                //===//
                                if (hold !== (state.total & 0xffffffff)) {
                                  strm.msg = 'incorrect length check';
                                  state.mode = BAD;
                                  break;
                                }
                                //=== INITBITS();
                                hold = 0;
                                bits = 0;
                                //===//
                                //Tracev((stderr, "inflate:   length matches trailer\n"));
                              }
                              state.mode = DONE;
                            /* falls through */
                            case DONE:
                              ret = Z_STREAM_END;
                              break inf_leave;
                            case BAD:
                              ret = Z_DATA_ERROR;
                              break inf_leave;
                            case MEM:
                              return Z_MEM_ERROR;
                            case SYNC:
                            /* falls through */
                            default:
                              return Z_STREAM_ERROR;
                          }
                        }

                        // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

                        /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

                        //--- RESTORE() ---
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        //---

                        if (
                          state.wsize ||
                          (_out !== strm.avail_out &&
                            state.mode < BAD &&
                            (state.mode < CHECK || flush !== Z_FINISH))
                        ) {
                          if (
                            updatewindow(
                              strm,
                              strm.output,
                              strm.next_out,
                              _out - strm.avail_out
                            )
                          );
                        }
                        _in -= strm.avail_in;
                        _out -= strm.avail_out;
                        strm.total_in += _in;
                        strm.total_out += _out;
                        state.total += _out;
                        if (state.wrap && _out) {
                          strm.adler = state.check =
                            /*UPDATE(state.check, strm.next_out - _out, _out);*/
                            state.flags
                              ? crc32(
                                  state.check,
                                  output,
                                  _out,
                                  strm.next_out - _out
                                )
                              : adler32(
                                  state.check,
                                  output,
                                  _out,
                                  strm.next_out - _out
                                );
                        }
                        strm.data_type =
                          state.bits +
                          (state.last ? 64 : 0) +
                          (state.mode === TYPE ? 128 : 0) +
                          (state.mode === LEN_ || state.mode === COPY_
                            ? 256
                            : 0);
                        if (
                          ((_in === 0 && _out === 0) || flush === Z_FINISH) &&
                          ret === Z_OK
                        ) {
                          ret = Z_BUF_ERROR;
                        }
                        return ret;
                      }

                      function inflateEnd(strm) {
                        if (
                          !strm ||
                          !strm.state /*|| strm->zfree == (free_func)0*/
                        ) {
                          return Z_STREAM_ERROR;
                        }

                        var state = strm.state;
                        if (state.window) {
                          state.window = null;
                        }
                        strm.state = null;
                        return Z_OK;
                      }

                      function inflateGetHeader(strm, head) {
                        var state;

                        /* check state */
                        if (!strm || !strm.state) {
                          return Z_STREAM_ERROR;
                        }
                        state = strm.state;
                        if ((state.wrap & 2) === 0) {
                          return Z_STREAM_ERROR;
                        }

                        /* save header structure */
                        state.head = head;
                        head.done = false;
                        return Z_OK;
                      }

                      function inflateSetDictionary(strm, dictionary) {
                        var dictLength = dictionary.length;

                        var state;
                        var dictid;
                        var ret;

                        /* check state */
                        if (
                          !strm /* == Z_NULL */ ||
                          !strm.state /* == Z_NULL */
                        ) {
                          return Z_STREAM_ERROR;
                        }
                        state = strm.state;

                        if (state.wrap !== 0 && state.mode !== DICT) {
                          return Z_STREAM_ERROR;
                        }

                        /* check for correct dictionary identifier */
                        if (state.mode === DICT) {
                          dictid = 1; /* adler32(0, null, 0)*/
                          /* dictid = adler32(dictid, dictionary, dictLength); */
                          dictid = adler32(dictid, dictionary, dictLength, 0);
                          if (dictid !== state.check) {
                            return Z_DATA_ERROR;
                          }
                        }
                        /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
                        ret = updatewindow(
                          strm,
                          dictionary,
                          dictLength,
                          dictLength
                        );
                        if (ret) {
                          state.mode = MEM;
                          return Z_MEM_ERROR;
                        }
                        state.havedict = 1;
                        // Tracev((stderr, "inflate:   dictionary set\n"));
                        return Z_OK;
                      }

                      exports.inflateReset = inflateReset;
                      exports.inflateReset2 = inflateReset2;
                      exports.inflateResetKeep = inflateResetKeep;
                      exports.inflateInit = inflateInit;
                      exports.inflateInit2 = inflateInit2;
                      exports.inflate = inflate;
                      exports.inflateEnd = inflateEnd;
                      exports.inflateGetHeader = inflateGetHeader;
                      exports.inflateSetDictionary = inflateSetDictionary;
                      exports.inflateInfo =
                        'pako inflate (from Nodeca project)';

                      /* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/
                    },
                    {
                      '../utils/common': 1,
                      './adler32': 3,
                      './crc32': 5,
                      './inffast': 7,
                      './inftrees': 9,
                    },
                  ],
                  9: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      var utils = require('../utils/common');

                      var MAXBITS = 15;
                      var ENOUGH_LENS = 852;
                      var ENOUGH_DISTS = 592;
                      //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

                      var CODES = 0;
                      var LENS = 1;
                      var DISTS = 2;

                      var lbase = [
                        /* Length codes 257..285 base */ 3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        13,
                        15,
                        17,
                        19,
                        23,
                        27,
                        31,
                        35,
                        43,
                        51,
                        59,
                        67,
                        83,
                        99,
                        115,
                        131,
                        163,
                        195,
                        227,
                        258,
                        0,
                        0,
                      ];

                      var lext = [
                        /* Length codes 257..285 extra */ 16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        17,
                        17,
                        17,
                        17,
                        18,
                        18,
                        18,
                        18,
                        19,
                        19,
                        19,
                        19,
                        20,
                        20,
                        20,
                        20,
                        21,
                        21,
                        21,
                        21,
                        16,
                        72,
                        78,
                      ];

                      var dbase = [
                        /* Distance codes 0..29 base */ 1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        9,
                        13,
                        17,
                        25,
                        33,
                        49,
                        65,
                        97,
                        129,
                        193,
                        257,
                        385,
                        513,
                        769,
                        1025,
                        1537,
                        2049,
                        3073,
                        4097,
                        6145,
                        8193,
                        12289,
                        16385,
                        24577,
                        0,
                        0,
                      ];

                      var dext = [
                        /* Distance codes 0..29 extra */ 16,
                        16,
                        16,
                        16,
                        17,
                        17,
                        18,
                        18,
                        19,
                        19,
                        20,
                        20,
                        21,
                        21,
                        22,
                        22,
                        23,
                        23,
                        24,
                        24,
                        25,
                        25,
                        26,
                        26,
                        27,
                        27,
                        28,
                        28,
                        29,
                        29,
                        64,
                        64,
                      ];

                      module.exports = function inflate_table(
                        type,
                        lens,
                        lens_index,
                        codes,
                        table,
                        table_index,
                        work,
                        opts
                      ) {
                        var bits = opts.bits;
                        //here = opts.here; /* table entry for duplication */

                        var len = 0; /* a code's length in bits */
                        var sym = 0; /* index of code symbols */
                        var min = 0,
                          max = 0; /* minimum and maximum code lengths */
                        var root = 0; /* number of index bits for root table */
                        var curr = 0; /* number of index bits for current table */
                        var drop = 0; /* code bits to drop for sub-table */
                        var left = 0; /* number of prefix codes available */
                        var used = 0; /* code entries in table used */
                        var huff = 0; /* Huffman code */
                        var incr; /* for incrementing code, index */
                        var fill; /* index for replicating entries */
                        var low; /* low bits for current root entry */
                        var mask; /* mask for low root bits */
                        var next; /* next available space in table */
                        var base = null; /* base value table to use */
                        var base_index = 0;
                        //  var shoextra;    /* extra bits table to use */
                        var end; /* use base and extra for symbol > end */
                        var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
                        var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
                        var extra = null;
                        var extra_index = 0;

                        var here_bits, here_op, here_val;

                        /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

                        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
                        for (len = 0; len <= MAXBITS; len++) {
                          count[len] = 0;
                        }
                        for (sym = 0; sym < codes; sym++) {
                          count[lens[lens_index + sym]]++;
                        }

                        /* bound code lengths, force root to be within code lengths */
                        root = bits;
                        for (max = MAXBITS; max >= 1; max--) {
                          if (count[max] !== 0) {
                            break;
                          }
                        }
                        if (root > max) {
                          root = max;
                        }
                        if (max === 0) {
                          /* no symbols to code at all */
                          //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
                          //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
                          //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
                          table[table_index++] = (1 << 24) | (64 << 16) | 0;

                          //table.op[opts.table_index] = 64;
                          //table.bits[opts.table_index] = 1;
                          //table.val[opts.table_index++] = 0;
                          table[table_index++] = (1 << 24) | (64 << 16) | 0;

                          opts.bits = 1;
                          return 0; /* no symbols, but wait for decoding to report error */
                        }
                        for (min = 1; min < max; min++) {
                          if (count[min] !== 0) {
                            break;
                          }
                        }
                        if (root < min) {
                          root = min;
                        }

                        /* check for an over-subscribed or incomplete set of lengths */
                        left = 1;
                        for (len = 1; len <= MAXBITS; len++) {
                          left <<= 1;
                          left -= count[len];
                          if (left < 0) {
                            return -1;
                          } /* over-subscribed */
                        }
                        if (left > 0 && (type === CODES || max !== 1)) {
                          return -1; /* incomplete set */
                        }

                        /* generate offsets into symbol table for each length for sorting */
                        offs[1] = 0;
                        for (len = 1; len < MAXBITS; len++) {
                          offs[len + 1] = offs[len] + count[len];
                        }

                        /* sort symbols by length, by symbol order within each length */
                        for (sym = 0; sym < codes; sym++) {
                          if (lens[lens_index + sym] !== 0) {
                            work[offs[lens[lens_index + sym]]++] = sym;
                          }
                        }

                        /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

                        /* set up for code type */
                        // poor man optimization - use if-else instead of switch,
                        // to avoid deopts in old v8
                        if (type === CODES) {
                          base = extra = work; /* dummy value--not used */
                          end = 19;
                        } else if (type === LENS) {
                          base = lbase;
                          base_index -= 257;
                          extra = lext;
                          extra_index -= 257;
                          end = 256;
                        } else {
                          /* DISTS */
                          base = dbase;
                          extra = dext;
                          end = -1;
                        }

                        /* initialize opts for loop */
                        huff = 0; /* starting code */
                        sym = 0; /* starting code symbol */
                        len = min; /* starting code length */
                        next = table_index; /* current table to fill in */
                        curr = root; /* current table index bits */
                        drop = 0; /* current bits to drop from code for index */
                        low = -1; /* trigger new sub-table when len > root */
                        used = 1 << root; /* use root table entries */
                        mask = used - 1; /* mask for comparing low */

                        /* check available table space */
                        if (
                          (type === LENS && used > ENOUGH_LENS) ||
                          (type === DISTS && used > ENOUGH_DISTS)
                        ) {
                          return 1;
                        }

                        /* process all codes and make table entries */
                        for (;;) {
                          /* create table entry */
                          here_bits = len - drop;
                          if (work[sym] < end) {
                            here_op = 0;
                            here_val = work[sym];
                          } else if (work[sym] > end) {
                            here_op = extra[extra_index + work[sym]];
                            here_val = base[base_index + work[sym]];
                          } else {
                            here_op = 32 + 64; /* end of block */
                            here_val = 0;
                          }

                          /* replicate for those indices with low len bits equal to huff */
                          incr = 1 << (len - drop);
                          fill = 1 << curr;
                          min = fill; /* save offset to next table */
                          do {
                            fill -= incr;
                            table[next + (huff >> drop) + fill] =
                              (here_bits << 24) |
                              (here_op << 16) |
                              here_val |
                              0;
                          } while (fill !== 0);

                          /* backwards increment the len-bit code huff */
                          incr = 1 << (len - 1);
                          while (huff & incr) {
                            incr >>= 1;
                          }
                          if (incr !== 0) {
                            huff &= incr - 1;
                            huff += incr;
                          } else {
                            huff = 0;
                          }

                          /* go to next symbol, update count, len */
                          sym++;
                          if (--count[len] === 0) {
                            if (len === max) {
                              break;
                            }
                            len = lens[lens_index + work[sym]];
                          }

                          /* create new sub-table if needed */
                          if (len > root && (huff & mask) !== low) {
                            /* if first time, transition to sub-tables */
                            if (drop === 0) {
                              drop = root;
                            }

                            /* increment past last table */
                            next += min; /* here min is 1 << curr */

                            /* determine length of next table */
                            curr = len - drop;
                            left = 1 << curr;
                            while (curr + drop < max) {
                              left -= count[curr + drop];
                              if (left <= 0) {
                                break;
                              }
                              curr++;
                              left <<= 1;
                            }

                            /* check for enough space */
                            used += 1 << curr;
                            if (
                              (type === LENS && used > ENOUGH_LENS) ||
                              (type === DISTS && used > ENOUGH_DISTS)
                            ) {
                              return 1;
                            }

                            /* point entry in root table to sub-table */
                            low = huff & mask;
                            /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
                            table[low] =
                              (root << 24) |
                              (curr << 16) |
                              (next - table_index) |
                              0;
                          }
                        }

                        /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
                        if (huff !== 0) {
                          //table.op[next + huff] = 64;            /* invalid code marker */
                          //table.bits[next + huff] = len - drop;
                          //table.val[next + huff] = 0;
                          table[next + huff] =
                            ((len - drop) << 24) | (64 << 16) | 0;
                        }

                        /* set return parameters */
                        //opts.table_index += used;
                        opts.bits = root;
                        return 0;
                      };
                    },
                    { '../utils/common': 1 },
                  ],
                  10: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      module.exports = {
                        2: 'need dictionary' /* Z_NEED_DICT       2  */,
                        1: 'stream end' /* Z_STREAM_END      1  */,
                        0: '' /* Z_OK              0  */,
                        '-1': 'file error' /* Z_ERRNO         (-1) */,
                        '-2': 'stream error' /* Z_STREAM_ERROR  (-2) */,
                        '-3': 'data error' /* Z_DATA_ERROR    (-3) */,
                        '-4': 'insufficient memory' /* Z_MEM_ERROR     (-4) */,
                        '-5': 'buffer error' /* Z_BUF_ERROR     (-5) */,
                        '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */,
                      };
                    },
                    {},
                  ],
                  11: [
                    function (require, module, exports) {
                      // (C) 1995-2013 Jean-loup Gailly and Mark Adler
                      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
                      //
                      // This software is provided 'as-is', without any express or implied
                      // warranty. In no event will the authors be held liable for any damages
                      // arising from the use of this software.
                      //
                      // Permission is granted to anyone to use this software for any purpose,
                      // including commercial applications, and to alter it and redistribute it
                      // freely, subject to the following restrictions:
                      //
                      // 1. The origin of this software must not be misrepresented; you must not
                      //   claim that you wrote the original software. If you use this software
                      //   in a product, an acknowledgment in the product documentation would be
                      //   appreciated but is not required.
                      // 2. Altered source versions must be plainly marked as such, and must not be
                      //   misrepresented as being the original software.
                      // 3. This notice may not be removed or altered from any source distribution.

                      function ZStream() {
                        /* next input byte */
                        this.input = null; // JS specific, because we have no pointers
                        this.next_in = 0;
                        /* number of bytes available at input */
                        this.avail_in = 0;
                        /* total number of input bytes read so far */
                        this.total_in = 0;
                        /* next output byte should be put there */
                        this.output = null; // JS specific, because we have no pointers
                        this.next_out = 0;
                        /* remaining free space at output */
                        this.avail_out = 0;
                        /* total number of bytes output so far */
                        this.total_out = 0;
                        /* last error message, NULL if no error */
                        this.msg = '' /*Z_NULL*/;
                        /* not visible by applications */
                        this.state = null;
                        /* best guess about the data type: binary or text */
                        this.data_type = 2 /*Z_UNKNOWN*/;
                        /* adler32 value of the uncompressed data */
                        this.adler = 0;
                      }

                      module.exports = ZStream;
                    },
                    {},
                  ],
                  '/lib/inflate.js': [
                    function (require, module, exports) {
                      var zlib_inflate = require('./zlib/inflate');
                      var utils = require('./utils/common');
                      var strings = require('./utils/strings');
                      var c = require('./zlib/constants');
                      var msg = require('./zlib/messages');
                      var ZStream = require('./zlib/zstream');
                      var GZheader = require('./zlib/gzheader');

                      var toString = Object.prototype.toString;

                      /**
                       * class Inflate
                       *
                       * Generic JS-style wrapper for zlib calls. If you don't need
                       * streaming behaviour - use more simple functions: [[inflate]]
                       * and [[inflateRaw]].
                       **/

                      /* internal
                       * inflate.chunks -> Array
                       *
                       * Chunks of output data, if [[Inflate#onData]] not overridden.
                       **/

                      /**
                       * Inflate.result -> Uint8Array|Array|String
                       *
                       * Uncompressed result, generated by default [[Inflate#onData]]
                       * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
                       * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
                       * push a chunk with explicit flush (call [[Inflate#push]] with
                       * `Z_SYNC_FLUSH` param).
                       **/

                      /**
                       * Inflate.err -> Number
                       *
                       * Error code after inflate finished. 0 (Z_OK) on success.
                       * Should be checked if broken data possible.
                       **/

                      /**
                       * Inflate.msg -> String
                       *
                       * Error message, if [[Inflate.err]] != 0
                       **/

                      /**
                       * new Inflate(options)
                       * - options (Object): zlib inflate options.
                       *
                       * Creates new inflator instance with specified params. Throws exception
                       * on bad params. Supported options:
                       *
                       * - `windowBits`
                       * - `dictionary`
                       *
                       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
                       * for more information on these.
                       *
                       * Additional options, for internal needs:
                       *
                       * - `chunkSize` - size of generated data chunks (16K by default)
                       * - `raw` (Boolean) - do raw inflate
                       * - `to` (String) - if equal to 'string', then result will be converted
                       *   from utf8 to utf16 (javascript) string. When string output requested,
                       *   chunk length can differ from `chunkSize`, depending on content.
                       *
                       * By default, when no options set, autodetect deflate/gzip data format via
                       * wrapper header.
                       *
                       * ##### Example:
                       *
                       * ```javascript
                       * var pako = require('pako')
                       *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
                       *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
                       *
                       * var inflate = new pako.Inflate({ level: 3});
                       *
                       * inflate.push(chunk1, false);
                       * inflate.push(chunk2, true);  // true -> last chunk
                       *
                       * if (inflate.err) { throw new Error(inflate.err); }
                       *
                       * console.log(inflate.result);
                       * ```
                       **/
                      function Inflate(options) {
                        if (!(this instanceof Inflate))
                          return new Inflate(options);

                        this.options = utils.assign(
                          {
                            chunkSize: 16384,
                            windowBits: 0,
                            to: '',
                          },
                          options || {}
                        );

                        var opt = this.options;

                        // Force window size for `raw` data, if not set directly,
                        // because we have no header for autodetect.
                        if (
                          opt.raw &&
                          opt.windowBits >= 0 &&
                          opt.windowBits < 16
                        ) {
                          opt.windowBits = -opt.windowBits;
                          if (opt.windowBits === 0) {
                            opt.windowBits = -15;
                          }
                        }

                        // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
                        if (
                          opt.windowBits >= 0 &&
                          opt.windowBits < 16 &&
                          !(options && options.windowBits)
                        ) {
                          opt.windowBits += 32;
                        }

                        // Gzip header has no info about windows size, we can do autodetect only
                        // for deflate. So, if window size not set, force it to max when gzip possible
                        if (opt.windowBits > 15 && opt.windowBits < 48) {
                          // bit 3 (16) -> gzipped data
                          // bit 4 (32) -> autodetect gzip/deflate
                          if ((opt.windowBits & 15) === 0) {
                            opt.windowBits |= 15;
                          }
                        }

                        this.err = 0; // error code, if happens (0 = Z_OK)
                        this.msg = ''; // error message
                        this.ended = false; // used to avoid multiple onEnd() calls
                        this.chunks = []; // chunks of compressed data

                        this.strm = new ZStream();
                        this.strm.avail_out = 0;

                        var status = zlib_inflate.inflateInit2(
                          this.strm,
                          opt.windowBits
                        );

                        if (status !== c.Z_OK) {
                          throw new Error(msg[status]);
                        }

                        this.header = new GZheader();

                        zlib_inflate.inflateGetHeader(this.strm, this.header);

                        // Setup dictionary
                        if (opt.dictionary) {
                          // Convert data if needed
                          if (typeof opt.dictionary === 'string') {
                            opt.dictionary = strings.string2buf(opt.dictionary);
                          } else if (
                            toString.call(opt.dictionary) ===
                            '[object ArrayBuffer]'
                          ) {
                            opt.dictionary = new Uint8Array(opt.dictionary);
                          }
                          if (opt.raw) {
                            //In raw mode we need to set the dictionary early
                            status = zlib_inflate.inflateSetDictionary(
                              this.strm,
                              opt.dictionary
                            );
                            if (status !== c.Z_OK) {
                              throw new Error(msg[status]);
                            }
                          }
                        }
                      }

                      /**
                       * Inflate#push(data[, mode]) -> Boolean
                       * - data (Uint8Array|Array|ArrayBuffer|String): input data
                       * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
                       *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
                       *
                       * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
                       * new output chunks. Returns `true` on success. The last data block must have
                       * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
                       * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
                       * can use mode Z_SYNC_FLUSH, keeping the decompression context.
                       *
                       * On fail call [[Inflate#onEnd]] with error code and return false.
                       *
                       * We strongly recommend to use `Uint8Array` on input for best speed (output
                       * format is detected automatically). Also, don't skip last param and always
                       * use the same type in your code (boolean or number). That will improve JS speed.
                       *
                       * For regular `Array`-s make sure all elements are [0..255].
                       *
                       * ##### Example
                       *
                       * ```javascript
                       * push(chunk, false); // push one of data chunks
                       * ...
                       * push(chunk, true);  // push last chunk
                       * ```
                       **/
                      Inflate.prototype.push = function (data, mode) {
                        var strm = this.strm;
                        var chunkSize = this.options.chunkSize;
                        var dictionary = this.options.dictionary;
                        var status, _mode;
                        var next_out_utf8, tail, utf8str;

                        // Flag to properly process Z_BUF_ERROR on testing inflate call
                        // when we check that all output data was flushed.
                        var allowBufError = false;

                        if (this.ended) {
                          return false;
                        }
                        _mode =
                          mode === ~~mode
                            ? mode
                            : mode === true
                            ? c.Z_FINISH
                            : c.Z_NO_FLUSH;

                        // Convert data if needed
                        if (typeof data === 'string') {
                          // Only binary strings can be decompressed on practice
                          strm.input = strings.binstring2buf(data);
                        } else if (
                          toString.call(data) === '[object ArrayBuffer]'
                        ) {
                          strm.input = new Uint8Array(data);
                        } else {
                          strm.input = data;
                        }

                        strm.next_in = 0;
                        strm.avail_in = strm.input.length;

                        do {
                          if (strm.avail_out === 0) {
                            strm.output = new utils.Buf8(chunkSize);
                            strm.next_out = 0;
                            strm.avail_out = chunkSize;
                          }

                          status = zlib_inflate.inflate(
                            strm,
                            c.Z_NO_FLUSH
                          ); /* no bad return value */

                          if (status === c.Z_NEED_DICT && dictionary) {
                            status = zlib_inflate.inflateSetDictionary(
                              this.strm,
                              dictionary
                            );
                          }

                          if (
                            status === c.Z_BUF_ERROR &&
                            allowBufError === true
                          ) {
                            status = c.Z_OK;
                            allowBufError = false;
                          }

                          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                            this.onEnd(status);
                            this.ended = true;
                            return false;
                          }

                          if (strm.next_out) {
                            if (
                              strm.avail_out === 0 ||
                              status === c.Z_STREAM_END ||
                              (strm.avail_in === 0 &&
                                (_mode === c.Z_FINISH ||
                                  _mode === c.Z_SYNC_FLUSH))
                            ) {
                              if (this.options.to === 'string') {
                                next_out_utf8 = strings.utf8border(
                                  strm.output,
                                  strm.next_out
                                );

                                tail = strm.next_out - next_out_utf8;
                                utf8str = strings.buf2string(
                                  strm.output,
                                  next_out_utf8
                                );

                                // move tail
                                strm.next_out = tail;
                                strm.avail_out = chunkSize - tail;
                                if (tail) {
                                  utils.arraySet(
                                    strm.output,
                                    strm.output,
                                    next_out_utf8,
                                    tail,
                                    0
                                  );
                                }

                                this.onData(utf8str);
                              } else {
                                this.onData(
                                  utils.shrinkBuf(strm.output, strm.next_out)
                                );
                              }
                            }
                          }

                          // When no more input data, we should check that internal inflate buffers
                          // are flushed. The only way to do it when avail_out = 0 - run one more
                          // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
                          // Here we set flag to process this error properly.
                          //
                          // NOTE. Deflate does not return error in this case and does not needs such
                          // logic.
                          if (strm.avail_in === 0 && strm.avail_out === 0) {
                            allowBufError = true;
                          }
                        } while (
                          (strm.avail_in > 0 || strm.avail_out === 0) &&
                          status !== c.Z_STREAM_END
                        );

                        if (status === c.Z_STREAM_END) {
                          _mode = c.Z_FINISH;
                        }

                        // Finalize on the last chunk.
                        if (_mode === c.Z_FINISH) {
                          status = zlib_inflate.inflateEnd(this.strm);
                          this.onEnd(status);
                          this.ended = true;
                          return status === c.Z_OK;
                        }

                        // callback interim results if Z_SYNC_FLUSH.
                        if (_mode === c.Z_SYNC_FLUSH) {
                          this.onEnd(c.Z_OK);
                          strm.avail_out = 0;
                          return true;
                        }

                        return true;
                      };

                      /**
                       * Inflate#onData(chunk) -> Void
                       * - chunk (Uint8Array|Array|String): output data. Type of array depends
                       *   on js engine support. When string output requested, each chunk
                       *   will be string.
                       *
                       * By default, stores data blocks in `chunks[]` property and glue
                       * those in `onEnd`. Override this handler, if you need another behaviour.
                       **/
                      Inflate.prototype.onData = function (chunk) {
                        this.chunks.push(chunk);
                      };

                      /**
                       * Inflate#onEnd(status) -> Void
                       * - status (Number): inflate status. 0 (Z_OK) on success,
                       *   other if not.
                       *
                       * Called either after you tell inflate that the input stream is
                       * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
                       * or if an error happened. By default - join collected chunks,
                       * free memory and fill `results` / `err` properties.
                       **/
                      Inflate.prototype.onEnd = function (status) {
                        // On success - join
                        if (status === c.Z_OK) {
                          if (this.options.to === 'string') {
                            // Glue & convert here, until we teach pako to send
                            // utf8 aligned strings to onData
                            this.result = this.chunks.join('');
                          } else {
                            this.result = utils.flattenChunks(this.chunks);
                          }
                        }
                        this.chunks = [];
                        this.err = status;
                        this.msg = this.strm.msg;
                      };

                      /**
                       * inflate(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to decompress.
                       * - options (Object): zlib inflate options.
                       *
                       * Decompress `data` with inflate/ungzip and `options`. Autodetect
                       * format via wrapper header by default. That's why we don't provide
                       * separate `ungzip` method.
                       *
                       * Supported options are:
                       *
                       * - windowBits
                       *
                       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
                       * for more information.
                       *
                       * Sugar (options):
                       *
                       * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
                       *   negative windowBits implicitly.
                       * - `to` (String) - if equal to 'string', then result will be converted
                       *   from utf8 to utf16 (javascript) string. When string output requested,
                       *   chunk length can differ from `chunkSize`, depending on content.
                       *
                       *
                       * ##### Example:
                       *
                       * ```javascript
                       * var pako = require('pako')
                       *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
                       *   , output;
                       *
                       * try {
                       *   output = pako.inflate(input);
                       * } catch (err)
                       *   console.log(err);
                       * }
                       * ```
                       **/
                      function inflate(input, options) {
                        var inflator = new Inflate(options);

                        inflator.push(input, true);

                        // That will never happens, if you don't cheat with options :)
                        if (inflator.err) {
                          throw inflator.msg || msg[inflator.err];
                        }

                        return inflator.result;
                      }

                      /**
                       * inflateRaw(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to decompress.
                       * - options (Object): zlib inflate options.
                       *
                       * The same as [[inflate]], but creates raw data, without wrapper
                       * (header and adler32 crc).
                       **/
                      function inflateRaw(input, options) {
                        options = options || {};
                        options.raw = true;
                        return inflate(input, options);
                      }

                      /**
                       * ungzip(data[, options]) -> Uint8Array|Array|String
                       * - data (Uint8Array|Array|String): input data to decompress.
                       * - options (Object): zlib inflate options.
                       *
                       * Just shortcut to [[inflate]], because it autodetects format
                       * by header.content. Done for convenience.
                       **/

                      exports.Inflate = Inflate;
                      exports.inflate = inflate;
                      exports.inflateRaw = inflateRaw;
                      exports.ungzip = inflate;
                    },
                    {
                      './utils/common': 1,
                      './utils/strings': 2,
                      './zlib/constants': 4,
                      './zlib/gzheader': 6,
                      './zlib/inflate': 8,
                      './zlib/messages': 10,
                      './zlib/zstream': 11,
                    },
                  ],
                },
                {},
                []
              )('/lib/inflate.js');
            });
          });
          var pako_inflate_1 = pako_inflate.inflate;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/rrweb-snapshot/es/rrweb-snapshot.js':
        /*!**************************************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/rrweb-snapshot/es/rrweb-snapshot.js ***!
  \**************************************************************************************/
        /*! exports provided: NodeType, addHoverClass, buildNodeWithSN, rebuild, serializeNodeWithId, snapshot, transformAttribute */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'NodeType',
            function () {
              return NodeType;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'addHoverClass',
            function () {
              return addHoverClass;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'buildNodeWithSN',
            function () {
              return buildNodeWithSN;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'rebuild',
            function () {
              return rebuild;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'serializeNodeWithId',
            function () {
              return serializeNodeWithId;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'snapshot',
            function () {
              return snapshot;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'transformAttribute',
            function () {
              return transformAttribute;
            }
          );
          var NodeType;
          (function (NodeType) {
            NodeType[(NodeType['Document'] = 0)] = 'Document';
            NodeType[(NodeType['DocumentType'] = 1)] = 'DocumentType';
            NodeType[(NodeType['Element'] = 2)] = 'Element';
            NodeType[(NodeType['Text'] = 3)] = 'Text';
            NodeType[(NodeType['CDATA'] = 4)] = 'CDATA';
            NodeType[(NodeType['Comment'] = 5)] = 'Comment';
          })(NodeType || (NodeType = {}));

          var _id = 1;
          var symbolAndNumberRegex = RegExp('[^a-z1-6-]');
          function genId() {
            return _id++;
          }
          function getValidTagName(tagName) {
            var processedTagName = tagName.toLowerCase().trim();
            if (symbolAndNumberRegex.test(processedTagName)) {
              return 'div';
            }
            return processedTagName;
          }
          function getCssRulesString(s) {
            try {
              var rules = s.rules || s.cssRules;
              return rules
                ? Array.from(rules).reduce(function (prev, cur) {
                    return prev + getCssRuleString(cur);
                  }, '')
                : null;
            } catch (error) {
              return null;
            }
          }
          function getCssRuleString(rule) {
            return isCSSImportRule(rule)
              ? getCssRulesString(rule.styleSheet) || ''
              : rule.cssText;
          }
          function isCSSImportRule(rule) {
            return 'styleSheet' in rule;
          }
          function extractOrigin(url) {
            var origin;
            if (url.indexOf('//') > -1) {
              origin = url.split('/').slice(0, 3).join('/');
            } else {
              origin = url.split('/')[0];
            }
            origin = origin.split('?')[0];
            return origin;
          }
          var URL_IN_CSS_REF = /url\((?:'([^']*)'|"([^"]*)"|([^)]*))\)/gm;
          var RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/;
          var DATA_URI = /^(data:)([\w\/\+\-]+);(charset=[\w-]+|base64).*,(.*)/i;
          function absoluteToStylesheet(cssText, href) {
            return (cssText || '').replace(URL_IN_CSS_REF, function (
              origin,
              path1,
              path2,
              path3
            ) {
              var filePath = path1 || path2 || path3;
              if (!filePath) {
                return origin;
              }
              if (!RELATIVE_PATH.test(filePath)) {
                return "url('" + filePath + "')";
              }
              if (DATA_URI.test(filePath)) {
                return 'url(' + filePath + ')';
              }
              if (filePath[0] === '/') {
                return "url('" + (extractOrigin(href) + filePath) + "')";
              }
              var stack = href.split('/');
              var parts = filePath.split('/');
              stack.pop();
              for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                if (part === '.') {
                  continue;
                } else if (part === '..') {
                  stack.pop();
                } else {
                  stack.push(part);
                }
              }
              return "url('" + stack.join('/') + "')";
            });
          }
          function getAbsoluteSrcsetString(doc, attributeValue) {
            if (attributeValue.trim() === '') {
              return attributeValue;
            }
            var srcsetValues = attributeValue.split(',');
            var resultingSrcsetString = srcsetValues
              .map(function (srcItem) {
                var trimmedSrcItem = srcItem.trimLeft().trimRight();
                var urlAndSize = trimmedSrcItem.split(' ');
                if (urlAndSize.length === 2) {
                  var absUrl = absoluteToDoc(doc, urlAndSize[0]);
                  return absUrl + ' ' + urlAndSize[1];
                } else if (urlAndSize.length === 1) {
                  var absUrl = absoluteToDoc(doc, urlAndSize[0]);
                  return '' + absUrl;
                }
                return '';
              })
              .join(',');
            return resultingSrcsetString;
          }
          function absoluteToDoc(doc, attributeValue) {
            if (!attributeValue || attributeValue.trim() === '') {
              return attributeValue;
            }
            var a = doc.createElement('a');
            a.href = attributeValue;
            return a.href;
          }
          function isSVGElement(el) {
            return el.tagName === 'svg' || el instanceof SVGElement;
          }
          function transformAttribute(doc, name, value) {
            if (name === 'src' || (name === 'href' && value)) {
              return absoluteToDoc(doc, value);
            } else if (name === 'srcset' && value) {
              return getAbsoluteSrcsetString(doc, value);
            } else if (name === 'style' && value) {
              return absoluteToStylesheet(value, location.href);
            } else {
              return value;
            }
          }
          function serializeNode(
            n,
            doc,
            blockClass,
            inlineStylesheet,
            maskInputOptions
          ) {
            if (maskInputOptions === void 0) {
              maskInputOptions = {};
            }
            switch (n.nodeType) {
              case n.DOCUMENT_NODE:
                return {
                  type: NodeType.Document,
                  childNodes: [],
                };
              case n.DOCUMENT_TYPE_NODE:
                return {
                  type: NodeType.DocumentType,
                  name: n.name,
                  publicId: n.publicId,
                  systemId: n.systemId,
                };
              case n.ELEMENT_NODE:
                var needBlock_1 = false;
                if (typeof blockClass === 'string') {
                  needBlock_1 = n.classList.contains(blockClass);
                } else {
                  n.classList.forEach(function (className) {
                    if (blockClass.test(className)) {
                      needBlock_1 = true;
                    }
                  });
                }
                var tagName = getValidTagName(n.tagName);
                var attributes_1 = {};
                for (
                  var _i = 0, _a = Array.from(n.attributes);
                  _i < _a.length;
                  _i++
                ) {
                  var _b = _a[_i],
                    name = _b.name,
                    value = _b.value;
                  attributes_1[name] = transformAttribute(doc, name, value);
                }
                if (tagName === 'link' && inlineStylesheet) {
                  var stylesheet = Array.from(doc.styleSheets).find(function (
                    s
                  ) {
                    return s.href === n.href;
                  });
                  var cssText = getCssRulesString(stylesheet);
                  if (cssText) {
                    delete attributes_1.rel;
                    delete attributes_1.href;
                    attributes_1._cssText = absoluteToStylesheet(
                      cssText,
                      stylesheet.href
                    );
                  }
                }
                if (
                  tagName === 'style' &&
                  n.sheet &&
                  !(n.innerText || n.textContent || '').trim().length
                ) {
                  var cssText = getCssRulesString(n.sheet);
                  if (cssText) {
                    attributes_1._cssText = absoluteToStylesheet(
                      cssText,
                      location.href
                    );
                  }
                }
                if (
                  tagName === 'input' ||
                  tagName === 'textarea' ||
                  tagName === 'select'
                ) {
                  var value = n.value;
                  if (
                    attributes_1.type !== 'radio' &&
                    attributes_1.type !== 'checkbox' &&
                    attributes_1.type !== 'submit' &&
                    attributes_1.type !== 'button' &&
                    value
                  ) {
                    attributes_1.value =
                      maskInputOptions[attributes_1.type] ||
                      maskInputOptions[tagName]
                        ? '*'.repeat(value.length)
                        : value;
                  } else if (n.checked) {
                    attributes_1.checked = n.checked;
                  }
                }
                if (tagName === 'option') {
                  var selectValue = n.parentElement;
                  if (attributes_1.value === selectValue.value) {
                    attributes_1.selected = n.selected;
                  }
                }
                if (tagName === 'canvas') {
                  attributes_1.rr_dataURL = n.toDataURL();
                }
                if (tagName === 'audio' || tagName === 'video') {
                  attributes_1.rr_mediaState = n.paused ? 'paused' : 'played';
                }
                if (needBlock_1) {
                  var _c = n.getBoundingClientRect(),
                    width = _c.width,
                    height = _c.height;
                  attributes_1.rr_width = width + 'px';
                  attributes_1.rr_height = height + 'px';
                }
                return {
                  type: NodeType.Element,
                  tagName: tagName,
                  attributes: attributes_1,
                  childNodes: [],
                  isSVG: isSVGElement(n) || undefined,
                  needBlock: needBlock_1,
                };
              case n.TEXT_NODE:
                var parentTagName = n.parentNode && n.parentNode.tagName;
                var textContent = n.textContent;
                var isStyle = parentTagName === 'STYLE' ? true : undefined;
                if (isStyle && textContent) {
                  textContent = absoluteToStylesheet(
                    textContent,
                    location.href
                  );
                }
                if (parentTagName === 'SCRIPT') {
                  textContent = 'SCRIPT_PLACEHOLDER';
                }
                return {
                  type: NodeType.Text,
                  textContent: textContent || '',
                  isStyle: isStyle,
                };
              case n.CDATA_SECTION_NODE:
                return {
                  type: NodeType.CDATA,
                  textContent: '',
                };
              case n.COMMENT_NODE:
                return {
                  type: NodeType.Comment,
                  textContent: n.textContent || '',
                };
              default:
                return false;
            }
          }
          function serializeNodeWithId(
            n,
            doc,
            map,
            blockClass,
            skipChild,
            inlineStylesheet,
            maskInputOptions
          ) {
            if (skipChild === void 0) {
              skipChild = false;
            }
            if (inlineStylesheet === void 0) {
              inlineStylesheet = true;
            }
            var _serializedNode = serializeNode(
              n,
              doc,
              blockClass,
              inlineStylesheet,
              maskInputOptions
            );
            if (!_serializedNode) {
              console.warn(n, 'not serialized');
              return null;
            }
            var id;
            if ('__sn' in n) {
              id = n.__sn.id;
            } else {
              id = genId();
            }
            var serializedNode = Object.assign(_serializedNode, { id: id });
            n.__sn = serializedNode;
            map[id] = n;
            var recordChild = !skipChild;
            if (serializedNode.type === NodeType.Element) {
              recordChild = recordChild && !serializedNode.needBlock;
              delete serializedNode.needBlock;
            }
            if (
              (serializedNode.type === NodeType.Document ||
                serializedNode.type === NodeType.Element) &&
              recordChild
            ) {
              for (
                var _i = 0, _a = Array.from(n.childNodes);
                _i < _a.length;
                _i++
              ) {
                var childN = _a[_i];
                var serializedChildNode = serializeNodeWithId(
                  childN,
                  doc,
                  map,
                  blockClass,
                  skipChild,
                  inlineStylesheet,
                  maskInputOptions
                );
                if (serializedChildNode) {
                  serializedNode.childNodes.push(serializedChildNode);
                }
              }
            }
            return serializedNode;
          }
          function snapshot(
            n,
            blockClass,
            inlineStylesheet,
            maskAllInputsOrOptions
          ) {
            if (blockClass === void 0) {
              blockClass = 'rr-block';
            }
            if (inlineStylesheet === void 0) {
              inlineStylesheet = true;
            }
            var idNodeMap = {};
            var maskInputOptions =
              maskAllInputsOrOptions === true
                ? {
                    color: true,
                    date: true,
                    'datetime-local': true,
                    email: true,
                    month: true,
                    number: true,
                    range: true,
                    search: true,
                    tel: true,
                    text: true,
                    time: true,
                    url: true,
                    week: true,
                  }
                : maskAllInputsOrOptions === false
                ? {}
                : maskAllInputsOrOptions;
            return [
              serializeNodeWithId(
                n,
                n,
                idNodeMap,
                blockClass,
                false,
                inlineStylesheet,
                maskInputOptions
              ),
              idNodeMap,
            ];
          }

          var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
          function parse(css, options) {
            if (options === void 0) {
              options = {};
            }
            var lineno = 1;
            var column = 1;
            function updatePosition(str) {
              var lines = str.match(/\n/g);
              if (lines) {
                lineno += lines.length;
              }
              var i = str.lastIndexOf('\n');
              column = i === -1 ? column + str.length : str.length - i;
            }
            function position() {
              var start = { line: lineno, column: column };
              return function (node) {
                node.position = new Position(start);
                whitespace();
                return node;
              };
            }
            var Position = (function () {
              function Position(start) {
                this.start = start;
                this.end = { line: lineno, column: column };
                this.source = options.source;
              }
              return Position;
            })();
            Position.prototype.content = css;
            var errorsList = [];
            function error(msg) {
              var err = new Error(
                options.source + ':' + lineno + ':' + column + ': ' + msg
              );
              err.reason = msg;
              err.filename = options.source;
              err.line = lineno;
              err.column = column;
              err.source = css;
              if (options.silent) {
                errorsList.push(err);
              } else {
                throw err;
              }
            }
            function stylesheet() {
              var rulesList = rules();
              return {
                type: 'stylesheet',
                stylesheet: {
                  source: options.source,
                  rules: rulesList,
                  parsingErrors: errorsList,
                },
              };
            }
            function open() {
              return match(/^{\s*/);
            }
            function close() {
              return match(/^}/);
            }
            function rules() {
              var node;
              var rules = [];
              whitespace();
              comments(rules);
              while (
                css.length &&
                css.charAt(0) !== '}' &&
                (node = atrule() || rule())
              ) {
                if (node !== false) {
                  rules.push(node);
                  comments(rules);
                }
              }
              return rules;
            }
            function match(re) {
              var m = re.exec(css);
              if (!m) {
                return;
              }
              var str = m[0];
              updatePosition(str);
              css = css.slice(str.length);
              return m;
            }
            function whitespace() {
              match(/^\s*/);
            }
            function comments(rules) {
              if (rules === void 0) {
                rules = [];
              }
              var c;
              while ((c = comment())) {
                if (c !== false) {
                  rules.push(c);
                }
                c = comment();
              }
              return rules;
            }
            function comment() {
              var pos = position();
              if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
                return;
              }
              var i = 2;
              while (
                '' !== css.charAt(i) &&
                ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))
              ) {
                ++i;
              }
              i += 2;
              if ('' === css.charAt(i - 1)) {
                return error('End of comment missing');
              }
              var str = css.slice(2, i - 2);
              column += 2;
              updatePosition(str);
              css = css.slice(i);
              column += 2;
              return pos({
                type: 'comment',
                comment: str,
              });
            }
            function selector() {
              var m = match(/^([^{]+)/);
              if (!m) {
                return;
              }
              return trim(m[0])
                .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
                .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
                  return m.replace(/,/g, '\u200C');
                })
                .split(/\s*(?![^(]*\)),\s*/)
                .map(function (s) {
                  return s.replace(/\u200C/g, ',');
                });
            }
            function declaration() {
              var pos = position();
              var propMatch = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
              if (!propMatch) {
                return;
              }
              var prop = trim(propMatch[0]);
              if (!match(/^:\s*/)) {
                return error("property missing ':'");
              }
              var val = match(
                /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/
              );
              var ret = pos({
                type: 'declaration',
                property: prop.replace(commentre, ''),
                value: val ? trim(val[0]).replace(commentre, '') : '',
              });
              match(/^[;\s]*/);
              return ret;
            }
            function declarations() {
              var decls = [];
              if (!open()) {
                return error("missing '{'");
              }
              comments(decls);
              var decl;
              while ((decl = declaration())) {
                if (decl !== false) {
                  decls.push(decl);
                  comments(decls);
                }
                decl = declaration();
              }
              if (!close()) {
                return error("missing '}'");
              }
              return decls;
            }
            function keyframe() {
              var m;
              var vals = [];
              var pos = position();
              while ((m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/))) {
                vals.push(m[1]);
                match(/^,\s*/);
              }
              if (!vals.length) {
                return;
              }
              return pos({
                type: 'keyframe',
                values: vals,
                declarations: declarations(),
              });
            }
            function atkeyframes() {
              var pos = position();
              var m = match(/^@([-\w]+)?keyframes\s*/);
              if (!m) {
                return;
              }
              var vendor = m[1];
              m = match(/^([-\w]+)\s*/);
              if (!m) {
                return error('@keyframes missing name');
              }
              var name = m[1];
              if (!open()) {
                return error("@keyframes missing '{'");
              }
              var frame;
              var frames = comments();
              while ((frame = keyframe())) {
                frames.push(frame);
                frames = frames.concat(comments());
              }
              if (!close()) {
                return error("@keyframes missing '}'");
              }
              return pos({
                type: 'keyframes',
                name: name,
                vendor: vendor,
                keyframes: frames,
              });
            }
            function atsupports() {
              var pos = position();
              var m = match(/^@supports *([^{]+)/);
              if (!m) {
                return;
              }
              var supports = trim(m[1]);
              if (!open()) {
                return error("@supports missing '{'");
              }
              var style = comments().concat(rules());
              if (!close()) {
                return error("@supports missing '}'");
              }
              return pos({
                type: 'supports',
                supports: supports,
                rules: style,
              });
            }
            function athost() {
              var pos = position();
              var m = match(/^@host\s*/);
              if (!m) {
                return;
              }
              if (!open()) {
                return error("@host missing '{'");
              }
              var style = comments().concat(rules());
              if (!close()) {
                return error("@host missing '}'");
              }
              return pos({
                type: 'host',
                rules: style,
              });
            }
            function atmedia() {
              var pos = position();
              var m = match(/^@media *([^{]+)/);
              if (!m) {
                return;
              }
              var media = trim(m[1]);
              if (!open()) {
                return error("@media missing '{'");
              }
              var style = comments().concat(rules());
              if (!close()) {
                return error("@media missing '}'");
              }
              return pos({
                type: 'media',
                media: media,
                rules: style,
              });
            }
            function atcustommedia() {
              var pos = position();
              var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
              if (!m) {
                return;
              }
              return pos({
                type: 'custom-media',
                name: trim(m[1]),
                media: trim(m[2]),
              });
            }
            function atpage() {
              var pos = position();
              var m = match(/^@page */);
              if (!m) {
                return;
              }
              var sel = selector() || [];
              if (!open()) {
                return error("@page missing '{'");
              }
              var decls = comments();
              var decl;
              while ((decl = declaration())) {
                decls.push(decl);
                decls = decls.concat(comments());
              }
              if (!close()) {
                return error("@page missing '}'");
              }
              return pos({
                type: 'page',
                selectors: sel,
                declarations: decls,
              });
            }
            function atdocument() {
              var pos = position();
              var m = match(/^@([-\w]+)?document *([^{]+)/);
              if (!m) {
                return;
              }
              var vendor = trim(m[1]);
              var doc = trim(m[2]);
              if (!open()) {
                return error("@document missing '{'");
              }
              var style = comments().concat(rules());
              if (!close()) {
                return error("@document missing '}'");
              }
              return pos({
                type: 'document',
                document: doc,
                vendor: vendor,
                rules: style,
              });
            }
            function atfontface() {
              var pos = position();
              var m = match(/^@font-face\s*/);
              if (!m) {
                return;
              }
              if (!open()) {
                return error("@font-face missing '{'");
              }
              var decls = comments();
              var decl;
              while ((decl = declaration())) {
                decls.push(decl);
                decls = decls.concat(comments());
              }
              if (!close()) {
                return error("@font-face missing '}'");
              }
              return pos({
                type: 'font-face',
                declarations: decls,
              });
            }
            var atimport = _compileAtrule('import');
            var atcharset = _compileAtrule('charset');
            var atnamespace = _compileAtrule('namespace');
            function _compileAtrule(name) {
              var re = new RegExp('^@' + name + '\\s*([^;]+);');
              return function () {
                var pos = position();
                var m = match(re);
                if (!m) {
                  return;
                }
                var ret = { type: name };
                ret[name] = m[1].trim();
                return pos(ret);
              };
            }
            function atrule() {
              if (css[0] !== '@') {
                return;
              }
              return (
                atkeyframes() ||
                atmedia() ||
                atcustommedia() ||
                atsupports() ||
                atimport() ||
                atcharset() ||
                atnamespace() ||
                atdocument() ||
                atpage() ||
                athost() ||
                atfontface()
              );
            }
            function rule() {
              var pos = position();
              var sel = selector();
              if (!sel) {
                return error('selector missing');
              }
              comments();
              return pos({
                type: 'rule',
                selectors: sel,
                declarations: declarations(),
              });
            }
            return addParent(stylesheet());
          }
          function trim(str) {
            return str ? str.replace(/^\s+|\s+$/g, '') : '';
          }
          function addParent(obj, parent) {
            var isNode = obj && typeof obj.type === 'string';
            var childParent = isNode ? obj : parent;
            for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
              var k = _a[_i];
              var value = obj[k];
              if (Array.isArray(value)) {
                value.forEach(function (v) {
                  addParent(v, childParent);
                });
              } else if (value && typeof value === 'object') {
                addParent(value, childParent);
              }
            }
            if (isNode) {
              Object.defineProperty(obj, 'parent', {
                configurable: true,
                writable: true,
                enumerable: false,
                value: parent || null,
              });
            }
            return obj;
          }

          var tagMap = {
            script: 'noscript',
            altglyph: 'altGlyph',
            altglyphdef: 'altGlyphDef',
            altglyphitem: 'altGlyphItem',
            animatecolor: 'animateColor',
            animatemotion: 'animateMotion',
            animatetransform: 'animateTransform',
            clippath: 'clipPath',
            feblend: 'feBlend',
            fecolormatrix: 'feColorMatrix',
            fecomponenttransfer: 'feComponentTransfer',
            fecomposite: 'feComposite',
            feconvolvematrix: 'feConvolveMatrix',
            fediffuselighting: 'feDiffuseLighting',
            fedisplacementmap: 'feDisplacementMap',
            fedistantlight: 'feDistantLight',
            fedropshadow: 'feDropShadow',
            feflood: 'feFlood',
            fefunca: 'feFuncA',
            fefuncb: 'feFuncB',
            fefuncg: 'feFuncG',
            fefuncr: 'feFuncR',
            fegaussianblur: 'feGaussianBlur',
            feimage: 'feImage',
            femerge: 'feMerge',
            femergenode: 'feMergeNode',
            femorphology: 'feMorphology',
            feoffset: 'feOffset',
            fepointlight: 'fePointLight',
            fespecularlighting: 'feSpecularLighting',
            fespotlight: 'feSpotLight',
            fetile: 'feTile',
            feturbulence: 'feTurbulence',
            foreignobject: 'foreignObject',
            glyphref: 'glyphRef',
            lineargradient: 'linearGradient',
            radialgradient: 'radialGradient',
          };
          function getTagName(n) {
            var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;
            if (tagName === 'link' && n.attributes._cssText) {
              tagName = 'style';
            }
            return tagName;
          }
          var HOVER_SELECTOR = /([^\\]):hover/g;
          function addHoverClass(cssText) {
            var ast = parse(cssText, { silent: true });
            if (!ast.stylesheet) {
              return cssText;
            }
            ast.stylesheet.rules.forEach(function (rule) {
              if ('selectors' in rule) {
                (rule.selectors || []).forEach(function (selector) {
                  if (HOVER_SELECTOR.test(selector)) {
                    var newSelector = selector.replace(
                      HOVER_SELECTOR,
                      '$1.\\:hover'
                    );
                    cssText = cssText.replace(
                      selector,
                      selector + ', ' + newSelector
                    );
                  }
                });
              }
            });
            return cssText;
          }
          function buildNode(n, doc, HACK_CSS) {
            switch (n.type) {
              case NodeType.Document:
                return doc.implementation.createDocument(null, '', null);
              case NodeType.DocumentType:
                return doc.implementation.createDocumentType(
                  n.name,
                  n.publicId,
                  n.systemId
                );
              case NodeType.Element:
                var tagName = getTagName(n);
                var node_1;
                if (n.isSVG) {
                  node_1 = doc.createElementNS(
                    'http://www.w3.org/2000/svg',
                    tagName
                  );
                } else {
                  node_1 = doc.createElement(tagName);
                }
                var _loop_1 = function (name) {
                  if (!n.attributes.hasOwnProperty(name)) {
                    return 'continue';
                  }
                  var value = n.attributes[name];
                  value = typeof value === 'boolean' ? '' : value;
                  if (!name.startsWith('rr_')) {
                    var isTextarea = tagName === 'textarea' && name === 'value';
                    var isRemoteOrDynamicCss =
                      tagName === 'style' && name === '_cssText';
                    if (isRemoteOrDynamicCss && HACK_CSS) {
                      value = addHoverClass(value);
                    }
                    if (isTextarea || isRemoteOrDynamicCss) {
                      var child = doc.createTextNode(value);
                      for (
                        var _i = 0, _a = Array.from(node_1.childNodes);
                        _i < _a.length;
                        _i++
                      ) {
                        var c = _a[_i];
                        if (c.nodeType === node_1.TEXT_NODE) {
                          node_1.removeChild(c);
                        }
                      }
                      node_1.appendChild(child);
                      return 'continue';
                    }
                    if (tagName === 'iframe' && name === 'src') {
                      return 'continue';
                    }
                    try {
                      if (n.isSVG && name === 'xlink:href') {
                        node_1.setAttributeNS(
                          'http://www.w3.org/1999/xlink',
                          name,
                          value
                        );
                      } else if (
                        name == 'onload' ||
                        name == 'onclick' ||
                        name.substring(0, 7) == 'onmouse'
                      ) {
                        node_1.setAttribute('_' + name, value);
                      } else {
                        node_1.setAttribute(name, value);
                      }
                    } catch (error) {}
                  } else {
                    if (tagName === 'canvas' && name === 'rr_dataURL') {
                      var image_1 = document.createElement('img');
                      image_1.src = value;
                      image_1.onload = function () {
                        var ctx = node_1.getContext('2d');
                        if (ctx) {
                          ctx.drawImage(
                            image_1,
                            0,
                            0,
                            image_1.width,
                            image_1.height
                          );
                        }
                      };
                    }
                    if (name === 'rr_width') {
                      node_1.style.width = value;
                    }
                    if (name === 'rr_height') {
                      node_1.style.height = value;
                    }
                    if (name === 'rr_mediaState') {
                      switch (value) {
                        case 'played':
                          node_1.play();
                        case 'paused':
                          node_1.pause();
                          break;
                      }
                    }
                  }
                };
                for (var name in n.attributes) {
                  _loop_1(name);
                }
                return node_1;
              case NodeType.Text:
                return doc.createTextNode(
                  n.isStyle && HACK_CSS
                    ? addHoverClass(n.textContent)
                    : n.textContent
                );
              case NodeType.CDATA:
                return doc.createCDATASection(n.textContent);
              case NodeType.Comment:
                return doc.createComment(n.textContent);
              default:
                return null;
            }
          }
          function buildNodeWithSN(n, doc, map, skipChild, HACK_CSS) {
            if (skipChild === void 0) {
              skipChild = false;
            }
            if (HACK_CSS === void 0) {
              HACK_CSS = true;
            }
            var node = buildNode(n, doc, HACK_CSS);
            if (!node) {
              return null;
            }
            if (n.type === NodeType.Document) {
              doc.close();
              doc.open();
              node = doc;
            }
            node.__sn = n;
            map[n.id] = node;
            if (
              (n.type === NodeType.Document || n.type === NodeType.Element) &&
              !skipChild
            ) {
              for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {
                var childN = _a[_i];
                var childNode = buildNodeWithSN(
                  childN,
                  doc,
                  map,
                  false,
                  HACK_CSS
                );
                if (!childNode) {
                  console.warn('Failed to rebuild', childN);
                } else {
                  node.appendChild(childNode);
                }
              }
            }
            return node;
          }
          function rebuild(n, doc, HACK_CSS) {
            if (HACK_CSS === void 0) {
              HACK_CSS = true;
            }
            var idNodeMap = {};
            return [
              buildNodeWithSN(n, doc, idNodeMap, false, HACK_CSS),
              idNodeMap,
            ];
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/smoothscroll-polyfill/dist/smoothscroll.js':
        /*!*********************************************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/smoothscroll-polyfill/dist/smoothscroll.js ***!
  \*********************************************************************************************/
        /*! exports provided: __moduleExports, polyfill */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__moduleExports',
            function () {
              return smoothscroll;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'polyfill',
            function () {
              return smoothscroll_1;
            }
          );
          /* harmony import */ var _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../../_virtual/_commonjsHelpers.js */ './node_modules/rrweb/es/rrweb/_virtual/_commonjsHelpers.js'
          );

          var smoothscroll = Object(
            _virtual_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_0__[
              'createCommonjsModule'
            ]
          )(function (module, exports) {
            /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */
            (function () {
              // polyfill
              function polyfill() {
                // aliases
                var w = window;
                var d = document;

                // return if scroll behavior is supported and polyfill is not forced
                if (
                  'scrollBehavior' in d.documentElement.style &&
                  w.__forceSmoothScrollPolyfill__ !== true
                ) {
                  return;
                }

                // globals
                var Element = w.HTMLElement || w.Element;
                var SCROLL_TIME = 468;

                // object gathering original scroll methods
                var original = {
                  scroll: w.scroll || w.scrollTo,
                  scrollBy: w.scrollBy,
                  elementScroll: Element.prototype.scroll || scrollElement,
                  scrollIntoView: Element.prototype.scrollIntoView,
                };

                // define timing method
                var now =
                  w.performance && w.performance.now
                    ? w.performance.now.bind(w.performance)
                    : Date.now;

                /**
                 * indicates if a the current browser is made by Microsoft
                 * @method isMicrosoftBrowser
                 * @param {String} userAgent
                 * @returns {Boolean}
                 */
                function isMicrosoftBrowser(userAgent) {
                  var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];

                  return new RegExp(userAgentPatterns.join('|')).test(
                    userAgent
                  );
                }

                /*
                 * IE has rounding bug rounding down clientHeight and clientWidth and
                 * rounding up scrollHeight and scrollWidth causing false positives
                 * on hasScrollableSpace
                 */
                var ROUNDING_TOLERANCE = isMicrosoftBrowser(
                  w.navigator.userAgent
                )
                  ? 1
                  : 0;

                /**
                 * changes scroll position inside an element
                 * @method scrollElement
                 * @param {Number} x
                 * @param {Number} y
                 * @returns {undefined}
                 */
                function scrollElement(x, y) {
                  this.scrollLeft = x;
                  this.scrollTop = y;
                }

                /**
                 * returns result of applying ease math function to a number
                 * @method ease
                 * @param {Number} k
                 * @returns {Number}
                 */
                function ease(k) {
                  return 0.5 * (1 - Math.cos(Math.PI * k));
                }

                /**
                 * indicates if a smooth behavior should be applied
                 * @method shouldBailOut
                 * @param {Number|Object} firstArg
                 * @returns {Boolean}
                 */
                function shouldBailOut(firstArg) {
                  if (
                    firstArg === null ||
                    typeof firstArg !== 'object' ||
                    firstArg.behavior === undefined ||
                    firstArg.behavior === 'auto' ||
                    firstArg.behavior === 'instant'
                  ) {
                    // first argument is not an object/null
                    // or behavior is auto, instant or undefined
                    return true;
                  }

                  if (
                    typeof firstArg === 'object' &&
                    firstArg.behavior === 'smooth'
                  ) {
                    // first argument is an object and behavior is smooth
                    return false;
                  }

                  // throw error when behavior is not supported
                  throw new TypeError(
                    'behavior member of ScrollOptions ' +
                      firstArg.behavior +
                      ' is not a valid value for enumeration ScrollBehavior.'
                  );
                }

                /**
                 * indicates if an element has scrollable space in the provided axis
                 * @method hasScrollableSpace
                 * @param {Node} el
                 * @param {String} axis
                 * @returns {Boolean}
                 */
                function hasScrollableSpace(el, axis) {
                  if (axis === 'Y') {
                    return (
                      el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight
                    );
                  }

                  if (axis === 'X') {
                    return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
                  }
                }

                /**
                 * indicates if an element has a scrollable overflow property in the axis
                 * @method canOverflow
                 * @param {Node} el
                 * @param {String} axis
                 * @returns {Boolean}
                 */
                function canOverflow(el, axis) {
                  var overflowValue = w.getComputedStyle(el, null)[
                    'overflow' + axis
                  ];

                  return overflowValue === 'auto' || overflowValue === 'scroll';
                }

                /**
                 * indicates if an element can be scrolled in either axis
                 * @method isScrollable
                 * @param {Node} el
                 * @param {String} axis
                 * @returns {Boolean}
                 */
                function isScrollable(el) {
                  var isScrollableY =
                    hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');
                  var isScrollableX =
                    hasScrollableSpace(el, 'X') && canOverflow(el, 'X');

                  return isScrollableY || isScrollableX;
                }

                /**
                 * finds scrollable parent of an element
                 * @method findScrollableParent
                 * @param {Node} el
                 * @returns {Node} el
                 */
                function findScrollableParent(el) {
                  while (el !== d.body && isScrollable(el) === false) {
                    el = el.parentNode || el.host;
                  }

                  return el;
                }

                /**
                 * self invoked function that, given a context, steps through scrolling
                 * @method step
                 * @param {Object} context
                 * @returns {undefined}
                 */
                function step(context) {
                  var time = now();
                  var value;
                  var currentX;
                  var currentY;
                  var elapsed = (time - context.startTime) / SCROLL_TIME;

                  // avoid elapsed times higher than one
                  elapsed = elapsed > 1 ? 1 : elapsed;

                  // apply easing to elapsed time
                  value = ease(elapsed);

                  currentX =
                    context.startX + (context.x - context.startX) * value;
                  currentY =
                    context.startY + (context.y - context.startY) * value;

                  context.method.call(context.scrollable, currentX, currentY);

                  // scroll more if we have not reached our destination
                  if (currentX !== context.x || currentY !== context.y) {
                    w.requestAnimationFrame(step.bind(w, context));
                  }
                }

                /**
                 * scrolls window or element with a smooth behavior
                 * @method smoothScroll
                 * @param {Object|Node} el
                 * @param {Number} x
                 * @param {Number} y
                 * @returns {undefined}
                 */
                function smoothScroll(el, x, y) {
                  var scrollable;
                  var startX;
                  var startY;
                  var method;
                  var startTime = now();

                  // define scroll context
                  if (el === d.body) {
                    scrollable = w;
                    startX = w.scrollX || w.pageXOffset;
                    startY = w.scrollY || w.pageYOffset;
                    method = original.scroll;
                  } else {
                    scrollable = el;
                    startX = el.scrollLeft;
                    startY = el.scrollTop;
                    method = scrollElement;
                  }

                  // scroll looping over a frame
                  step({
                    scrollable: scrollable,
                    method: method,
                    startTime: startTime,
                    startX: startX,
                    startY: startY,
                    x: x,
                    y: y,
                  });
                }

                // ORIGINAL METHODS OVERRIDES
                // w.scroll and w.scrollTo
                w.scroll = w.scrollTo = function () {
                  // avoid action when no arguments are passed
                  if (arguments[0] === undefined) {
                    return;
                  }

                  // avoid smooth behavior if not required
                  if (shouldBailOut(arguments[0]) === true) {
                    original.scroll.call(
                      w,
                      arguments[0].left !== undefined
                        ? arguments[0].left
                        : typeof arguments[0] !== 'object'
                        ? arguments[0]
                        : w.scrollX || w.pageXOffset,
                      // use top prop, second argument if present or fallback to scrollY
                      arguments[0].top !== undefined
                        ? arguments[0].top
                        : arguments[1] !== undefined
                        ? arguments[1]
                        : w.scrollY || w.pageYOffset
                    );

                    return;
                  }

                  // LET THE SMOOTHNESS BEGIN!
                  smoothScroll.call(
                    w,
                    d.body,
                    arguments[0].left !== undefined
                      ? ~~arguments[0].left
                      : w.scrollX || w.pageXOffset,
                    arguments[0].top !== undefined
                      ? ~~arguments[0].top
                      : w.scrollY || w.pageYOffset
                  );
                };

                // w.scrollBy
                w.scrollBy = function () {
                  // avoid action when no arguments are passed
                  if (arguments[0] === undefined) {
                    return;
                  }

                  // avoid smooth behavior if not required
                  if (shouldBailOut(arguments[0])) {
                    original.scrollBy.call(
                      w,
                      arguments[0].left !== undefined
                        ? arguments[0].left
                        : typeof arguments[0] !== 'object'
                        ? arguments[0]
                        : 0,
                      arguments[0].top !== undefined
                        ? arguments[0].top
                        : arguments[1] !== undefined
                        ? arguments[1]
                        : 0
                    );

                    return;
                  }

                  // LET THE SMOOTHNESS BEGIN!
                  smoothScroll.call(
                    w,
                    d.body,
                    ~~arguments[0].left + (w.scrollX || w.pageXOffset),
                    ~~arguments[0].top + (w.scrollY || w.pageYOffset)
                  );
                };

                // Element.prototype.scroll and Element.prototype.scrollTo
                Element.prototype.scroll = Element.prototype.scrollTo = function () {
                  // avoid action when no arguments are passed
                  if (arguments[0] === undefined) {
                    return;
                  }

                  // avoid smooth behavior if not required
                  if (shouldBailOut(arguments[0]) === true) {
                    // if one number is passed, throw error to match Firefox implementation
                    if (
                      typeof arguments[0] === 'number' &&
                      arguments[1] === undefined
                    ) {
                      throw new SyntaxError('Value could not be converted');
                    }

                    original.elementScroll.call(
                      this,
                      // use left prop, first number argument or fallback to scrollLeft
                      arguments[0].left !== undefined
                        ? ~~arguments[0].left
                        : typeof arguments[0] !== 'object'
                        ? ~~arguments[0]
                        : this.scrollLeft,
                      // use top prop, second argument or fallback to scrollTop
                      arguments[0].top !== undefined
                        ? ~~arguments[0].top
                        : arguments[1] !== undefined
                        ? ~~arguments[1]
                        : this.scrollTop
                    );

                    return;
                  }

                  var left = arguments[0].left;
                  var top = arguments[0].top;

                  // LET THE SMOOTHNESS BEGIN!
                  smoothScroll.call(
                    this,
                    this,
                    typeof left === 'undefined' ? this.scrollLeft : ~~left,
                    typeof top === 'undefined' ? this.scrollTop : ~~top
                  );
                };

                // Element.prototype.scrollBy
                Element.prototype.scrollBy = function () {
                  // avoid action when no arguments are passed
                  if (arguments[0] === undefined) {
                    return;
                  }

                  // avoid smooth behavior if not required
                  if (shouldBailOut(arguments[0]) === true) {
                    original.elementScroll.call(
                      this,
                      arguments[0].left !== undefined
                        ? ~~arguments[0].left + this.scrollLeft
                        : ~~arguments[0] + this.scrollLeft,
                      arguments[0].top !== undefined
                        ? ~~arguments[0].top + this.scrollTop
                        : ~~arguments[1] + this.scrollTop
                    );

                    return;
                  }

                  this.scroll({
                    left: ~~arguments[0].left + this.scrollLeft,
                    top: ~~arguments[0].top + this.scrollTop,
                    behavior: arguments[0].behavior,
                  });
                };

                // Element.prototype.scrollIntoView
                Element.prototype.scrollIntoView = function () {
                  // avoid smooth behavior if not required
                  if (shouldBailOut(arguments[0]) === true) {
                    original.scrollIntoView.call(
                      this,
                      arguments[0] === undefined ? true : arguments[0]
                    );

                    return;
                  }

                  // LET THE SMOOTHNESS BEGIN!
                  var scrollableParent = findScrollableParent(this);
                  var parentRects = scrollableParent.getBoundingClientRect();
                  var clientRects = this.getBoundingClientRect();

                  if (scrollableParent !== d.body) {
                    // reveal element inside parent
                    smoothScroll.call(
                      this,
                      scrollableParent,
                      scrollableParent.scrollLeft +
                        clientRects.left -
                        parentRects.left,
                      scrollableParent.scrollTop +
                        clientRects.top -
                        parentRects.top
                    );

                    // reveal parent in viewport unless is fixed
                    if (
                      w.getComputedStyle(scrollableParent).position !== 'fixed'
                    ) {
                      w.scrollBy({
                        left: parentRects.left,
                        top: parentRects.top,
                        behavior: 'smooth',
                      });
                    }
                  } else {
                    // reveal element in viewport
                    w.scrollBy({
                      left: clientRects.left,
                      top: clientRects.top,
                      behavior: 'smooth',
                    });
                  }
                };
              }

              {
                // commonjs
                module.exports = { polyfill: polyfill };
              }
            })();
          });
          var smoothscroll_1 = smoothscroll.polyfill;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js':
        /*!*********************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js ***!
  \*********************************************************************/
        /*! exports provided: __assign, __read, __spread, __values */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__assign',
            function () {
              return __assign;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__read',
            function () {
              return __read;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__spread',
            function () {
              return __spread;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__values',
            function () {
              return __values;
            }
          );
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

          var __assign = function () {
            __assign =
              Object.assign ||
              function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
              };
            return __assign.apply(this, arguments);
          };

          function __values(o) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator],
              i = 0;
            if (m) return m.call(o);
            return {
              next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
              },
            };
          }

          function __read(o, n) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o),
              r,
              ar = [],
              e;
            try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
            } catch (error) {
              e = { error: error };
            } finally {
              try {
                if (r && !r.done && (m = i['return'])) m.call(i);
              } finally {
                if (e) throw e.error;
              }
            }
            return ar;
          }

          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]));
            return ar;
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/entries/all.js':
        /*!********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/entries/all.js ***!
  \********************************************************/
        /*! exports provided: EventType, IncrementalSource, MouseInteractions, ReplayerEvents, utils, mirror, record, Replayer, addCustomEvent, pack, unpack */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'EventType',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__['EventType'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'IncrementalSource',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__[
                'IncrementalSource'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'MouseInteractions',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__[
                'MouseInteractions'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ReplayerEvents',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__['ReplayerEvents'];
            }
          );

          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony reexport (module object) */ __webpack_require__.d(
            __webpack_exports__,
            'utils',
            function () {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__;
            }
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'mirror',
            function () {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__['mirror'];
            }
          );

          /* harmony import */ var _record_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../record/index.js */ './node_modules/rrweb/es/rrweb/src/record/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'record',
            function () {
              return _record_index_js__WEBPACK_IMPORTED_MODULE_2__['default'];
            }
          );

          /* harmony import */ var _replay_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../replay/index.js */ './node_modules/rrweb/es/rrweb/src/replay/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Replayer',
            function () {
              return _replay_index_js__WEBPACK_IMPORTED_MODULE_3__['Replayer'];
            }
          );

          /* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../index.js */ './node_modules/rrweb/es/rrweb/src/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'addCustomEvent',
            function () {
              return _index_js__WEBPACK_IMPORTED_MODULE_4__['addCustomEvent'];
            }
          );

          /* harmony import */ var _packer_pack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ../packer/pack.js */ './node_modules/rrweb/es/rrweb/src/packer/pack.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'pack',
            function () {
              return _packer_pack_js__WEBPACK_IMPORTED_MODULE_5__['pack'];
            }
          );

          /* harmony import */ var _packer_unpack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ../packer/unpack.js */ './node_modules/rrweb/es/rrweb/src/packer/unpack.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'unpack',
            function () {
              return _packer_unpack_js__WEBPACK_IMPORTED_MODULE_6__['unpack'];
            }
          );

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/index.js':
        /*!**************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/index.js ***!
  \**************************************************/
        /*! exports provided: EventType, IncrementalSource, MouseInteractions, ReplayerEvents, utils, mirror, record, Replayer, addCustomEvent */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'addCustomEvent',
            function () {
              return addCustomEvent;
            }
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'EventType',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__['EventType'];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'IncrementalSource',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__[
                'IncrementalSource'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'MouseInteractions',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__[
                'MouseInteractions'
              ];
            }
          );

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ReplayerEvents',
            function () {
              return _types_js__WEBPACK_IMPORTED_MODULE_0__['ReplayerEvents'];
            }
          );

          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony reexport (module object) */ __webpack_require__.d(
            __webpack_exports__,
            'utils',
            function () {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__;
            }
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'mirror',
            function () {
              return _utils_js__WEBPACK_IMPORTED_MODULE_1__['mirror'];
            }
          );

          /* harmony import */ var _record_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./record/index.js */ './node_modules/rrweb/es/rrweb/src/record/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'record',
            function () {
              return _record_index_js__WEBPACK_IMPORTED_MODULE_2__['default'];
            }
          );

          /* harmony import */ var _replay_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./replay/index.js */ './node_modules/rrweb/es/rrweb/src/replay/index.js'
          );
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'Replayer',
            function () {
              return _replay_index_js__WEBPACK_IMPORTED_MODULE_3__['Replayer'];
            }
          );

          var addCustomEvent =
            _record_index_js__WEBPACK_IMPORTED_MODULE_2__['default']
              .addCustomEvent;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/packer/base.js':
        /*!********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/packer/base.js ***!
  \********************************************************/
        /*! exports provided: MARK */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'MARK',
            function () {
              return MARK;
            }
          );
          var MARK = 'v1';

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/packer/pack.js':
        /*!********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/packer/pack.js ***!
  \********************************************************/
        /*! exports provided: pack */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'pack',
            function () {
              return pack;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _node_modules_pako_dist_pako_deflate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../node_modules/pako/dist/pako_deflate.js */ './node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_deflate.js'
          );
          /* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ./base.js */ './node_modules/rrweb/es/rrweb/src/packer/base.js'
          );

          var pack = function (event) {
            var _e = Object(
              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                '__assign'
              ]
            )(
              Object(
                _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                  '__assign'
                ]
              )({}, event),
              { v: _base_js__WEBPACK_IMPORTED_MODULE_2__['MARK'] }
            );
            return Object(
              _node_modules_pako_dist_pako_deflate_js__WEBPACK_IMPORTED_MODULE_1__[
                'deflate'
              ]
            )(JSON.stringify(_e), { to: 'string' });
          };

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/packer/unpack.js':
        /*!**********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/packer/unpack.js ***!
  \**********************************************************/
        /*! exports provided: unpack */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'unpack',
            function () {
              return unpack;
            }
          );
          /* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ./base.js */ './node_modules/rrweb/es/rrweb/src/packer/base.js'
          );
          /* harmony import */ var _node_modules_pako_dist_pako_inflate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../node_modules/pako/dist/pako_inflate.js */ './node_modules/rrweb/es/rrweb/node_modules/pako/dist/pako_inflate.js'
          );

          var unpack = function (raw) {
            if (typeof raw !== 'string') {
              return raw;
            }
            try {
              var e = JSON.parse(raw);
              if (e.timestamp) {
                return e;
              }
            } catch (error) {}
            try {
              var e = JSON.parse(
                Object(
                  _node_modules_pako_dist_pako_inflate_js__WEBPACK_IMPORTED_MODULE_1__[
                    'inflate'
                  ]
                )(raw, { to: 'string' })
              );
              if (e.v === _base_js__WEBPACK_IMPORTED_MODULE_0__['MARK']) {
                return e;
              }
              throw new Error(
                'These events were packed with packer ' +
                  e.v +
                  ' which is incompatible with current packer ' +
                  _base_js__WEBPACK_IMPORTED_MODULE_0__['MARK'] +
                  '.'
              );
            } catch (error) {
              console.error(error);
              throw new Error('Unknown data format.');
            }
          };

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/record/index.js':
        /*!*********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/record/index.js ***!
  \*********************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js */ './node_modules/rrweb/es/rrweb/node_modules/rrweb-snapshot/es/rrweb-snapshot.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony import */ var _observer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ./observer.js */ './node_modules/rrweb/es/rrweb/src/record/observer.js'
          );

          function wrapEvent(e) {
            return Object(
              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                '__assign'
              ]
            )(
              Object(
                _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                  '__assign'
                ]
              )({}, e),
              { timestamp: Date.now() }
            );
          }
          var wrappedEmit;
          function record(options) {
            if (options === void 0) {
              options = {};
            }
            var emit = options.emit,
              checkoutEveryNms = options.checkoutEveryNms,
              checkoutEveryNth = options.checkoutEveryNth,
              _a = options.blockClass,
              blockClass = _a === void 0 ? 'rr-block' : _a,
              _b = options.ignoreClass,
              ignoreClass = _b === void 0 ? 'rr-ignore' : _b,
              _c = options.inlineStylesheet,
              inlineStylesheet = _c === void 0 ? true : _c,
              maskAllInputs = options.maskAllInputs,
              _maskInputOptions = options.maskInputOptions,
              hooks = options.hooks,
              packFn = options.packFn,
              _d = options.sampling,
              sampling = _d === void 0 ? {} : _d,
              mousemoveWait = options.mousemoveWait;
            if (!emit) {
              throw new Error('emit function is required');
            }
            if (
              mousemoveWait !== undefined &&
              sampling.mousemove === undefined
            ) {
              sampling.mousemove = mousemoveWait;
            }
            var maskInputOptions =
              maskAllInputs === true
                ? {
                    color: true,
                    date: true,
                    'datetime-local': true,
                    email: true,
                    month: true,
                    number: true,
                    range: true,
                    search: true,
                    tel: true,
                    text: true,
                    time: true,
                    url: true,
                    week: true,
                    textarea: true,
                    select: true,
                  }
                : _maskInputOptions !== undefined
                ? _maskInputOptions
                : {};
            Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__['polyfill'])();
            var lastFullSnapshotEvent;
            var incrementalSnapshotCount = 0;
            wrappedEmit = function (e, isCheckout) {
              emit(packFn ? packFn(e) : e, isCheckout);
              if (
                e.type ===
                _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].FullSnapshot
              ) {
                lastFullSnapshotEvent = e;
                incrementalSnapshotCount = 0;
              } else if (
                e.type ===
                _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                  .IncrementalSnapshot
              ) {
                incrementalSnapshotCount++;
                var exceedCount =
                  checkoutEveryNth &&
                  incrementalSnapshotCount >= checkoutEveryNth;
                var exceedTime =
                  checkoutEveryNms &&
                  e.timestamp - lastFullSnapshotEvent.timestamp >
                    checkoutEveryNms;
                if (exceedCount || exceedTime) {
                  takeFullSnapshot(true);
                }
              }
            };
            function takeFullSnapshot(isCheckout) {
              var _a, _b, _c, _d;
              if (isCheckout === void 0) {
                isCheckout = false;
              }
              wrappedEmit(
                wrapEvent({
                  type:
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Meta,
                  data: {
                    href: window.location.href,
                    width: Object(
                      _utils_js__WEBPACK_IMPORTED_MODULE_3__['getWindowWidth']
                    )(),
                    height: Object(
                      _utils_js__WEBPACK_IMPORTED_MODULE_3__['getWindowHeight']
                    )(),
                  },
                }),
                isCheckout
              );
              var _e = Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__read'
                  ]
                )(
                  Object(
                    _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                      'snapshot'
                    ]
                  )(document, blockClass, inlineStylesheet, maskInputOptions),
                  2
                ),
                node = _e[0],
                idNodeMap = _e[1];
              if (!node) {
                return console.warn('Failed to snapshot the document');
              }
              _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].map = idNodeMap;
              wrappedEmit(
                wrapEvent({
                  type:
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                      .FullSnapshot,
                  data: {
                    node: node,
                    initialOffset: {
                      left:
                        window.pageXOffset !== undefined
                          ? window.pageXOffset
                          : (document === null || document === void 0
                              ? void 0
                              : document.documentElement.scrollLeft) ||
                            ((_b =
                              (_a =
                                document === null || document === void 0
                                  ? void 0
                                  : document.body) === null || _a === void 0
                                ? void 0
                                : _a.parentElement) === null || _b === void 0
                              ? void 0
                              : _b.scrollLeft) ||
                            (document === null || document === void 0
                              ? void 0
                              : document.body.scrollLeft) ||
                            0,
                      top:
                        window.pageYOffset !== undefined
                          ? window.pageYOffset
                          : (document === null || document === void 0
                              ? void 0
                              : document.documentElement.scrollTop) ||
                            ((_d =
                              (_c =
                                document === null || document === void 0
                                  ? void 0
                                  : document.body) === null || _c === void 0
                                ? void 0
                                : _c.parentElement) === null || _d === void 0
                              ? void 0
                              : _d.scrollTop) ||
                            (document === null || document === void 0
                              ? void 0
                              : document.body.scrollTop) ||
                            0,
                    },
                  },
                })
              );
            }
            try {
              var handlers_1 = [];
              handlers_1.push(
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__['on'])(
                  'DOMContentLoaded',
                  function () {
                    wrappedEmit(
                      wrapEvent({
                        type:
                          _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                            .DomContentLoaded,
                        data: {},
                      })
                    );
                  }
                )
              );
              var init_1 = function () {
                takeFullSnapshot();
                handlers_1.push(
                  Object(_observer_js__WEBPACK_IMPORTED_MODULE_4__['default'])(
                    {
                      mutationCb: function (m) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].Mutation,
                              },
                              m
                            ),
                          })
                        );
                      },
                      mousemoveCb: function (positions, source) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: {
                              source: source,
                              positions: positions,
                            },
                          })
                        );
                      },
                      mouseInteractionCb: function (d) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].MouseInteraction,
                              },
                              d
                            ),
                          })
                        );
                      },
                      scrollCb: function (p) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].Scroll,
                              },
                              p
                            ),
                          })
                        );
                      },
                      viewportResizeCb: function (d) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].ViewportResize,
                              },
                              d
                            ),
                          })
                        );
                      },
                      inputCb: function (v) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].Input,
                              },
                              v
                            ),
                          })
                        );
                      },
                      mediaInteractionCb: function (p) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].MediaInteraction,
                              },
                              p
                            ),
                          })
                        );
                      },
                      styleSheetRuleCb: function (r) {
                        return wrappedEmit(
                          wrapEvent({
                            type:
                              _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                'EventType'
                              ].IncrementalSnapshot,
                            data: Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__assign'
                              ]
                            )(
                              {
                                source:
                                  _types_js__WEBPACK_IMPORTED_MODULE_2__[
                                    'IncrementalSource'
                                  ].StyleSheetRule,
                              },
                              r
                            ),
                          })
                        );
                      },
                      blockClass: blockClass,
                      ignoreClass: ignoreClass,
                      maskInputOptions: maskInputOptions,
                      inlineStylesheet: inlineStylesheet,
                      sampling: sampling,
                    },
                    hooks
                  )
                );
              };
              if (
                document.readyState === 'interactive' ||
                document.readyState === 'complete'
              ) {
                init_1();
              } else {
                handlers_1.push(
                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__['on'])(
                    'load',
                    function () {
                      wrappedEmit(
                        wrapEvent({
                          type:
                            _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                              .Load,
                          data: {},
                        })
                      );
                      init_1();
                    },
                    window
                  )
                );
              }
              return function () {
                handlers_1.forEach(function (h) {
                  return h();
                });
              };
            } catch (error) {
              console.warn(error);
            }
          }
          record.addCustomEvent = function (tag, payload) {
            if (!wrappedEmit) {
              throw new Error('please add custom event after start recording');
            }
            wrappedEmit(
              wrapEvent({
                type:
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Custom,
                data: {
                  tag: tag,
                  payload: payload,
                },
              })
            );
          };

          /* harmony default export */ __webpack_exports__['default'] = record;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/record/mutation.js':
        /*!************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/record/mutation.js ***!
  \************************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js */ './node_modules/rrweb/es/rrweb/node_modules/rrweb-snapshot/es/rrweb-snapshot.js'
          );
          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );

          var moveKey = function (id, parentId) {
            return id + '@' + parentId;
          };
          function isINode(n) {
            return '__sn' in n;
          }
          var MutationBuffer = (function () {
            function MutationBuffer(
              cb,
              blockClass,
              inlineStylesheet,
              maskInputOptions
            ) {
              var _this = this;
              this.texts = [];
              this.attributes = [];
              this.removes = [];
              this.adds = [];
              this.movedMap = {};
              this.addedSet = new Set();
              this.movedSet = new Set();
              this.droppedSet = new Set();
              this.processMutations = function (mutations) {
                var e_1, _a, e_2, _b;
                mutations.forEach(_this.processMutation);
                var addQueue = [];
                var pushAdd = function (n) {
                  if (!n.parentNode) {
                    return;
                  }
                  var parentId = _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                    'mirror'
                  ].getId(n.parentNode);
                  var nextId =
                    n.nextSibling &&
                    _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                      n.nextSibling
                    );
                  if (parentId === -1 || nextId === -1) {
                    return addQueue.push(n);
                  }
                  _this.adds.push({
                    parentId: parentId,
                    nextId: nextId,
                    node: Object(
                      _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                        'serializeNodeWithId'
                      ]
                    )(
                      n,
                      document,
                      _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].map,
                      _this.blockClass,
                      true,
                      _this.inlineStylesheet,
                      _this.maskInputOptions
                    ),
                  });
                };
                try {
                  for (
                    var _c = Object(
                        _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                          '__values'
                        ]
                      )(_this.movedSet),
                      _d = _c.next();
                    !_d.done;
                    _d = _c.next()
                  ) {
                    var n = _d.value;
                    pushAdd(n);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                try {
                  for (
                    var _e = Object(
                        _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                          '__values'
                        ]
                      )(_this.addedSet),
                      _f = _e.next();
                    !_f.done;
                    _f = _e.next()
                  ) {
                    var n = _f.value;
                    if (
                      !isAncestorInSet(_this.droppedSet, n) &&
                      !isParentRemoved(_this.removes, n)
                    ) {
                      pushAdd(n);
                    } else if (isAncestorInSet(_this.movedSet, n)) {
                      pushAdd(n);
                    } else {
                      _this.droppedSet.add(n);
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                while (addQueue.length) {
                  if (
                    addQueue.every(function (n) {
                      return (
                        _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                          n.parentNode
                        ) === -1
                      );
                    })
                  ) {
                    break;
                  }
                  pushAdd(addQueue.shift());
                }
                _this.emit();
              };
              this.emit = function () {
                var payload = {
                  texts: _this.texts
                    .map(function (text) {
                      return {
                        id: _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                          'mirror'
                        ].getId(text.node),
                        value: text.value,
                      };
                    })
                    .filter(function (text) {
                      return _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                        'mirror'
                      ].has(text.id);
                    }),
                  attributes: _this.attributes
                    .map(function (attribute) {
                      return {
                        id: _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                          'mirror'
                        ].getId(attribute.node),
                        attributes: attribute.attributes,
                      };
                    })
                    .filter(function (attribute) {
                      return _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                        'mirror'
                      ].has(attribute.id);
                    }),
                  removes: _this.removes,
                  adds: _this.adds,
                };
                if (
                  !payload.texts.length &&
                  !payload.attributes.length &&
                  !payload.removes.length &&
                  !payload.adds.length
                ) {
                  return;
                }
                _this.emissionCallback(payload);
                _this.texts = [];
                _this.attributes = [];
                _this.removes = [];
                _this.adds = [];
                _this.addedSet = new Set();
                _this.movedSet = new Set();
                _this.droppedSet = new Set();
                _this.movedMap = {};
              };
              this.processMutation = function (m) {
                switch (m.type) {
                  case 'characterData': {
                    var value = m.target.textContent;
                    if (
                      !Object(
                        _utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked']
                      )(m.target, _this.blockClass) &&
                      value !== m.oldValue
                    ) {
                      _this.texts.push({
                        value: value,
                        node: m.target,
                      });
                    }
                    break;
                  }
                  case 'attributes': {
                    var value = m.target.getAttribute(m.attributeName);
                    if (
                      Object(
                        _utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked']
                      )(m.target, _this.blockClass) ||
                      value === m.oldValue
                    ) {
                      return;
                    }
                    var item = _this.attributes.find(function (a) {
                      return a.node === m.target;
                    });
                    if (!item) {
                      item = {
                        node: m.target,
                        attributes: {},
                      };
                      _this.attributes.push(item);
                    }
                    item.attributes[m.attributeName] = Object(
                      _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                        'transformAttribute'
                      ]
                    )(document, m.attributeName, value);
                    break;
                  }
                  case 'childList': {
                    m.addedNodes.forEach(function (n) {
                      return _this.genAdds(n, m.target);
                    });
                    m.removedNodes.forEach(function (n) {
                      var nodeId = _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                        'mirror'
                      ].getId(n);
                      var parentId = _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                        'mirror'
                      ].getId(m.target);
                      if (
                        Object(
                          _utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked']
                        )(n, _this.blockClass) ||
                        Object(
                          _utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked']
                        )(m.target, _this.blockClass)
                      ) {
                        return;
                      }
                      if (_this.addedSet.has(n)) {
                        deepDelete(_this.addedSet, n);
                        _this.droppedSet.add(n);
                      } else if (_this.addedSet.has(m.target) && nodeId === -1);
                      else if (
                        Object(
                          _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                            'isAncestorRemoved'
                          ]
                        )(m.target)
                      );
                      else if (
                        _this.movedSet.has(n) &&
                        _this.movedMap[moveKey(nodeId, parentId)]
                      ) {
                        deepDelete(_this.movedSet, n);
                      } else {
                        _this.removes.push({
                          parentId: parentId,
                          id: nodeId,
                        });
                      }
                      _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                        'mirror'
                      ].removeNodeFromMap(n);
                    });
                    break;
                  }
                }
              };
              this.genAdds = function (n, target) {
                if (
                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked'])(
                    n,
                    _this.blockClass
                  )
                ) {
                  return;
                }
                if (isINode(n)) {
                  _this.movedSet.add(n);
                  var targetId = null;
                  if (target && isINode(target)) {
                    targetId = target.__sn.id;
                  }
                  if (targetId) {
                    _this.movedMap[moveKey(n.__sn.id, targetId)] = true;
                  }
                } else {
                  _this.addedSet.add(n);
                  _this.droppedSet.delete(n);
                }
                n.childNodes.forEach(function (childN) {
                  return _this.genAdds(childN);
                });
              };
              this.blockClass = blockClass;
              this.inlineStylesheet = inlineStylesheet;
              this.maskInputOptions = maskInputOptions;
              this.emissionCallback = cb;
            }
            return MutationBuffer;
          })();
          function deepDelete(addsSet, n) {
            addsSet.delete(n);
            n.childNodes.forEach(function (childN) {
              return deepDelete(addsSet, childN);
            });
          }
          function isParentRemoved(removes, n) {
            var parentNode = n.parentNode;
            if (!parentNode) {
              return false;
            }
            var parentId = _utils_js__WEBPACK_IMPORTED_MODULE_2__[
              'mirror'
            ].getId(parentNode);
            if (
              removes.some(function (r) {
                return r.id === parentId;
              })
            ) {
              return true;
            }
            return isParentRemoved(removes, parentNode);
          }
          function isAncestorInSet(set, n) {
            var parentNode = n.parentNode;
            if (!parentNode) {
              return false;
            }
            if (set.has(parentNode)) {
              return true;
            }
            return isAncestorInSet(set, parentNode);
          }

          /* harmony default export */ __webpack_exports__[
            'default'
          ] = MutationBuffer;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/record/observer.js':
        /*!************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/record/observer.js ***!
  \************************************************************/
        /*! exports provided: default, INPUT_TAGS */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'INPUT_TAGS',
            function () {
              return INPUT_TAGS;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./mutation.js */ './node_modules/rrweb/es/rrweb/src/record/mutation.js'
          );

          function initMutationObserver(
            cb,
            blockClass,
            inlineStylesheet,
            maskInputOptions
          ) {
            var mutationBuffer = new _mutation_js__WEBPACK_IMPORTED_MODULE_3__[
              'default'
            ](cb, blockClass, inlineStylesheet, maskInputOptions);
            var observer = new MutationObserver(
              mutationBuffer.processMutations
            );
            observer.observe(document, {
              attributes: true,
              attributeOldValue: true,
              characterData: true,
              characterDataOldValue: true,
              childList: true,
              subtree: true,
            });
            return observer;
          }
          function initMoveObserver(cb, sampling) {
            if (sampling.mousemove === false) {
              return function () {};
            }
            var threshold =
              typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;
            var positions = [];
            var timeBaseline;
            var wrappedCb = Object(
              _utils_js__WEBPACK_IMPORTED_MODULE_2__['throttle']
            )(function (isTouch) {
              var totalOffset = Date.now() - timeBaseline;
              cb(
                positions.map(function (p) {
                  p.timeOffset -= totalOffset;
                  return p;
                }),
                isTouch
                  ? _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                      .TouchMove
                  : _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                      .MouseMove
              );
              positions = [];
              timeBaseline = null;
            }, 500);
            var updatePosition = Object(
              _utils_js__WEBPACK_IMPORTED_MODULE_2__['throttle']
            )(
              function (evt) {
                var target = evt.target;
                var _a = Object(
                    _utils_js__WEBPACK_IMPORTED_MODULE_2__['isTouchEvent']
                  )(evt)
                    ? evt.changedTouches[0]
                    : evt,
                  clientX = _a.clientX,
                  clientY = _a.clientY;
                if (!timeBaseline) {
                  timeBaseline = Date.now();
                }
                positions.push({
                  x: clientX,
                  y: clientY,
                  id: _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                    target
                  ),
                  timeOffset: Date.now() - timeBaseline,
                });
                wrappedCb(
                  Object(
                    _utils_js__WEBPACK_IMPORTED_MODULE_2__['isTouchEvent']
                  )(evt)
                );
              },
              threshold,
              {
                trailing: false,
              }
            );
            var handlers = [
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                'mousemove',
                updatePosition
              ),
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                'touchmove',
                updatePosition
              ),
            ];
            return function () {
              handlers.forEach(function (h) {
                return h();
              });
            };
          }
          function initMouseInteractionObserver(cb, blockClass, sampling) {
            if (sampling.mouseInteraction === false) {
              return function () {};
            }
            var disableMap =
              sampling.mouseInteraction === true ||
              sampling.mouseInteraction === undefined
                ? {}
                : sampling.mouseInteraction;
            var handlers = [];
            var getHandler = function (eventKey) {
              return function (event) {
                if (
                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked'])(
                    event.target,
                    blockClass
                  )
                ) {
                  return;
                }
                var id = _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                  event.target
                );
                var _a = Object(
                    _utils_js__WEBPACK_IMPORTED_MODULE_2__['isTouchEvent']
                  )(event)
                    ? event.changedTouches[0]
                    : event,
                  clientX = _a.clientX,
                  clientY = _a.clientY;
                cb({
                  type:
                    _types_js__WEBPACK_IMPORTED_MODULE_1__['MouseInteractions'][
                      eventKey
                    ],
                  id: id,
                  x: clientX,
                  y: clientY,
                });
              };
            };
            Object.keys(
              _types_js__WEBPACK_IMPORTED_MODULE_1__['MouseInteractions']
            )
              .filter(function (key) {
                return (
                  Number.isNaN(Number(key)) &&
                  !key.endsWith('_Departed') &&
                  disableMap[key] !== false
                );
              })
              .forEach(function (eventKey) {
                var eventName = eventKey.toLowerCase();
                var handler = getHandler(eventKey);
                handlers.push(
                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                    eventName,
                    handler
                  )
                );
              });
            return function () {
              handlers.forEach(function (h) {
                return h();
              });
            };
          }
          function initScrollObserver(cb, blockClass, sampling) {
            var updatePosition = Object(
              _utils_js__WEBPACK_IMPORTED_MODULE_2__['throttle']
            )(function (evt) {
              if (
                !evt.target ||
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked'])(
                  evt.target,
                  blockClass
                )
              ) {
                return;
              }
              var id = _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                evt.target
              );
              if (evt.target === document) {
                var scrollEl =
                  document.scrollingElement || document.documentElement;
                cb({
                  id: id,
                  x: scrollEl.scrollLeft,
                  y: scrollEl.scrollTop,
                });
              } else {
                cb({
                  id: id,
                  x: evt.target.scrollLeft,
                  y: evt.target.scrollTop,
                });
              }
            }, sampling.scroll || 100);
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
              'scroll',
              updatePosition
            );
          }
          function initViewportResizeObserver(cb) {
            var updateDimension = Object(
              _utils_js__WEBPACK_IMPORTED_MODULE_2__['throttle']
            )(function () {
              var height = Object(
                _utils_js__WEBPACK_IMPORTED_MODULE_2__['getWindowHeight']
              )();
              var width = Object(
                _utils_js__WEBPACK_IMPORTED_MODULE_2__['getWindowWidth']
              )();
              cb({
                width: Number(width),
                height: Number(height),
              });
            }, 200);
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
              'resize',
              updateDimension,
              window
            );
          }
          var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];
          var lastInputValueMap = new WeakMap();
          function initInputObserver(
            cb,
            blockClass,
            ignoreClass,
            maskInputOptions,
            sampling
          ) {
            function eventHandler(event) {
              var target = event.target;
              if (
                !target ||
                !target.tagName ||
                INPUT_TAGS.indexOf(target.tagName) < 0 ||
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked'])(
                  target,
                  blockClass
                )
              ) {
                return;
              }
              var type = target.type;
              if (
                type === 'password' ||
                target.classList.contains(ignoreClass)
              ) {
                return;
              }
              var text = target.value;
              var isChecked = false;
              if (type === 'radio' || type === 'checkbox') {
                isChecked = target.checked;
              } else if (
                maskInputOptions[target.tagName.toLowerCase()] ||
                maskInputOptions[type]
              ) {
                text = '*'.repeat(text.length);
              }
              cbWithDedup(target, { text: text, isChecked: isChecked });
              var name = target.name;
              if (type === 'radio' && name && isChecked) {
                document
                  .querySelectorAll('input[type="radio"][name="' + name + '"]')
                  .forEach(function (el) {
                    if (el !== target) {
                      cbWithDedup(el, {
                        text: el.value,
                        isChecked: !isChecked,
                      });
                    }
                  });
              }
            }
            function cbWithDedup(target, v) {
              var lastInputValue = lastInputValueMap.get(target);
              if (
                !lastInputValue ||
                lastInputValue.text !== v.text ||
                lastInputValue.isChecked !== v.isChecked
              ) {
                lastInputValueMap.set(target, v);
                var id = _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                  target
                );
                cb(
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__assign'
                    ]
                  )(
                    Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__assign'
                      ]
                    )({}, v),
                    { id: id }
                  )
                );
              }
            }
            var events =
              sampling.input === 'last' ? ['change'] : ['input', 'change'];
            var handlers = events.map(function (eventName) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                eventName,
                eventHandler
              );
            });
            var propertyDescriptor = Object.getOwnPropertyDescriptor(
              HTMLInputElement.prototype,
              'value'
            );
            var hookProperties = [
              [HTMLInputElement.prototype, 'value'],
              [HTMLInputElement.prototype, 'checked'],
              [HTMLSelectElement.prototype, 'value'],
              [HTMLTextAreaElement.prototype, 'value'],
            ];
            if (propertyDescriptor && propertyDescriptor.set) {
              handlers.push.apply(
                handlers,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(
                  hookProperties.map(function (p) {
                    return Object(
                      _utils_js__WEBPACK_IMPORTED_MODULE_2__['hookSetter']
                    )(p[0], p[1], {
                      set: function () {
                        eventHandler({ target: this });
                      },
                    });
                  })
                )
              );
            }
            return function () {
              handlers.forEach(function (h) {
                return h();
              });
            };
          }
          function initStyleSheetObserver(cb) {
            var insertRule = CSSStyleSheet.prototype.insertRule;
            CSSStyleSheet.prototype.insertRule = function (rule, index) {
              var id = _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                this.ownerNode
              );
              if (id !== -1) {
                cb({
                  id: id,
                  adds: [{ rule: rule, index: index }],
                });
              }
              return insertRule.apply(this, arguments);
            };
            var deleteRule = CSSStyleSheet.prototype.deleteRule;
            CSSStyleSheet.prototype.deleteRule = function (index) {
              var id = _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                this.ownerNode
              );
              if (id !== -1) {
                cb({
                  id: id,
                  removes: [{ index: index }],
                });
              }
              return deleteRule.apply(this, arguments);
            };
            return function () {
              CSSStyleSheet.prototype.insertRule = insertRule;
              CSSStyleSheet.prototype.deleteRule = deleteRule;
            };
          }
          function initMediaInteractionObserver(
            mediaInteractionCb,
            blockClass
          ) {
            var handler = function (type) {
              return function (event) {
                var target = event.target;
                if (
                  !target ||
                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['isBlocked'])(
                    target,
                    blockClass
                  )
                ) {
                  return;
                }
                mediaInteractionCb({
                  type:
                    type === 'play'
                      ? _types_js__WEBPACK_IMPORTED_MODULE_1__[
                          'MediaInteractions'
                        ].Play
                      : _types_js__WEBPACK_IMPORTED_MODULE_1__[
                          'MediaInteractions'
                        ].Pause,
                  id: _utils_js__WEBPACK_IMPORTED_MODULE_2__['mirror'].getId(
                    target
                  ),
                });
              };
            };
            var handlers = [
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                'play',
                handler('play')
              ),
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__['on'])(
                'pause',
                handler('pause')
              ),
            ];
            return function () {
              handlers.forEach(function (h) {
                return h();
              });
            };
          }
          function mergeHooks(o, hooks) {
            var mutationCb = o.mutationCb,
              mousemoveCb = o.mousemoveCb,
              mouseInteractionCb = o.mouseInteractionCb,
              scrollCb = o.scrollCb,
              viewportResizeCb = o.viewportResizeCb,
              inputCb = o.inputCb,
              mediaInteractionCb = o.mediaInteractionCb,
              styleSheetRuleCb = o.styleSheetRuleCb;
            o.mutationCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.mutation) {
                hooks.mutation.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              mutationCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.mousemoveCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.mousemove) {
                hooks.mousemove.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              mousemoveCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.mouseInteractionCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.mouseInteraction) {
                hooks.mouseInteraction.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              mouseInteractionCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.scrollCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.scroll) {
                hooks.scroll.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              scrollCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.viewportResizeCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.viewportResize) {
                hooks.viewportResize.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              viewportResizeCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.inputCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.input) {
                hooks.input.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              inputCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.mediaInteractionCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.mediaInteaction) {
                hooks.mediaInteaction.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              mediaInteractionCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
            o.styleSheetRuleCb = function () {
              var p = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                p[_i] = arguments[_i];
              }
              if (hooks.styleSheetRule) {
                hooks.styleSheetRule.apply(
                  hooks,
                  Object(
                    _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                      '__spread'
                    ]
                  )(p)
                );
              }
              styleSheetRuleCb.apply(
                void 0,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(p)
              );
            };
          }
          function initObservers(o, hooks) {
            if (hooks === void 0) {
              hooks = {};
            }
            mergeHooks(o, hooks);
            var mutationObserver = initMutationObserver(
              o.mutationCb,
              o.blockClass,
              o.inlineStylesheet,
              o.maskInputOptions
            );
            var mousemoveHandler = initMoveObserver(o.mousemoveCb, o.sampling);
            var mouseInteractionHandler = initMouseInteractionObserver(
              o.mouseInteractionCb,
              o.blockClass,
              o.sampling
            );
            var scrollHandler = initScrollObserver(
              o.scrollCb,
              o.blockClass,
              o.sampling
            );
            var viewportResizeHandler = initViewportResizeObserver(
              o.viewportResizeCb
            );
            var inputHandler = initInputObserver(
              o.inputCb,
              o.blockClass,
              o.ignoreClass,
              o.maskInputOptions,
              o.sampling
            );
            var mediaInteractionHandler = initMediaInteractionObserver(
              o.mediaInteractionCb,
              o.blockClass
            );
            var styleSheetObserver = initStyleSheetObserver(o.styleSheetRuleCb);
            return function () {
              mutationObserver.disconnect();
              mousemoveHandler();
              mouseInteractionHandler();
              scrollHandler();
              viewportResizeHandler();
              inputHandler();
              mediaInteractionHandler();
              styleSheetObserver();
            };
          }

          /* harmony default export */ __webpack_exports__[
            'default'
          ] = initObservers;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/replay/index.js':
        /*!*********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/replay/index.js ***!
  \*********************************************************/
        /*! exports provided: Replayer */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Replayer',
            function () {
              return Replayer;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js */ './node_modules/rrweb/es/rrweb/node_modules/rrweb-snapshot/es/rrweb-snapshot.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony import */ var _node_modules_mitt_dist_mitt_es_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../../node_modules/mitt/dist/mitt.es.js */ './node_modules/rrweb/es/rrweb/node_modules/mitt/dist/mitt.es.js'
          );
          /* harmony import */ var _node_modules_smoothscroll_polyfill_dist_smoothscroll_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
            /*! ../../node_modules/smoothscroll-polyfill/dist/smoothscroll.js */ './node_modules/rrweb/es/rrweb/node_modules/smoothscroll-polyfill/dist/smoothscroll.js'
          );
          /* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
            /*! ./timer.js */ './node_modules/rrweb/es/rrweb/src/replay/timer.js'
          );
          /* harmony import */ var _machine_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
            /*! ./machine.js */ './node_modules/rrweb/es/rrweb/src/replay/machine.js'
          );
          /* harmony import */ var _styles_inject_style_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
            /*! ./styles/inject-style.js */ './node_modules/rrweb/es/rrweb/src/replay/styles/inject-style.js'
          );

          var SKIP_TIME_THRESHOLD = 10 * 1000;
          var SKIP_TIME_INTERVAL = 5 * 1000;
          var mitt =
            _node_modules_mitt_dist_mitt_es_js__WEBPACK_IMPORTED_MODULE_4__[
              'default'
            ] ||
            _node_modules_mitt_dist_mitt_es_js__WEBPACK_IMPORTED_MODULE_4__;
          var REPLAY_CONSOLE_PREFIX = '[replayer]';
          var defaultConfig = {
            speed: 1,
            root: document.body,
            loadTimeout: 0,
            skipInactive: false,
            showWarning: true,
            showDebug: false,
            blockClass: 'rr-block',
            liveMode: false,
            insertStyleRules: [],
            triggerFocus: true,
          };
          var Replayer = (function () {
            function Replayer(events, config) {
              var _this = this;
              this.emitter = mitt();
              this.legacy_missingNodeRetryMap = {};
              if (
                !(config === null || config === void 0
                  ? void 0
                  : config.liveMode) &&
                events.length < 2
              ) {
                throw new Error('Replayer need at least 2 events.');
              }
              this.config = Object.assign({}, defaultConfig, config);
              this.handleResize = this.handleResize.bind(this);
              this.getCastFn = this.getCastFn.bind(this);
              this.emitter.on(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents'].Resize,
                this.handleResize
              );
              Object(
                _node_modules_smoothscroll_polyfill_dist_smoothscroll_js__WEBPACK_IMPORTED_MODULE_5__[
                  'polyfill'
                ]
              )();
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__['polyfill'])();
              this.setupDom();
              this.treeIndex = new _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                'TreeIndex'
              ]();
              this.fragmentParentMap = new Map();
              this.emitter.on(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents'].Flush,
                function () {
                  var e_1, _a, e_2, _b, e_3, _c;
                  var _d = _this.treeIndex.flush(),
                    scrollMap = _d.scrollMap,
                    inputMap = _d.inputMap;
                  try {
                    for (
                      var _e = Object(
                          _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                            '__values'
                          ]
                        )(scrollMap.values()),
                        _f = _e.next();
                      !_f.done;
                      _f = _e.next()
                    ) {
                      var d = _f.value;
                      _this.applyScroll(d);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    } finally {
                      if (e_1) throw e_1.error;
                    }
                  }
                  try {
                    for (
                      var _g = Object(
                          _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                            '__values'
                          ]
                        )(inputMap.values()),
                        _h = _g.next();
                      !_h.done;
                      _h = _g.next()
                    ) {
                      var d = _h.value;
                      _this.applyInput(d);
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    } finally {
                      if (e_2) throw e_2.error;
                    }
                  }
                  try {
                    for (
                      var _j = Object(
                          _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                            '__values'
                          ]
                        )(_this.fragmentParentMap.entries()),
                        _k = _j.next();
                      !_k.done;
                      _k = _j.next()
                    ) {
                      var _l = Object(
                          _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                            '__read'
                          ]
                        )(_k.value, 2),
                        frag = _l[0],
                        parent = _l[1];
                      _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].map[
                        parent.__sn.id
                      ] = parent;
                      if (
                        parent.__sn.type ===
                          _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                            'NodeType'
                          ].Element &&
                        parent.__sn.tagName === 'textarea' &&
                        frag.textContent
                      ) {
                        parent.value = frag.textContent;
                      }
                      parent.appendChild(frag);
                    }
                  } catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                  } finally {
                    try {
                      if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                    } finally {
                      if (e_3) throw e_3.error;
                    }
                  }
                  _this.fragmentParentMap.clear();
                }
              );
              var timer = new _timer_js__WEBPACK_IMPORTED_MODULE_6__['Timer'](
                [],
                (config === null || config === void 0
                  ? void 0
                  : config.speed) || defaultConfig.speed
              );
              this.service = Object(
                _machine_js__WEBPACK_IMPORTED_MODULE_7__['createPlayerService']
              )(
                {
                  events: events.map(function (e) {
                    if (config && config.unpackFn) {
                      return config.unpackFn(e);
                    }
                    return e;
                  }),
                  timer: timer,
                  timeOffset: 0,
                  baselineTime: 0,
                  lastPlayedEvent: null,
                },
                {
                  getCastFn: this.getCastFn,
                  emitter: this.emitter,
                }
              );
              this.service.start();
              this.service.subscribe(function (state) {
                _this.emitter.emit(
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                    .StateChange,
                  {
                    player: state,
                  }
                );
              });
              this.speedService = Object(
                _machine_js__WEBPACK_IMPORTED_MODULE_7__['createSpeedService']
              )({
                normalSpeed: -1,
                timer: timer,
              });
              this.speedService.start();
              this.speedService.subscribe(function (state) {
                _this.emitter.emit(
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                    .StateChange,
                  {
                    speed: state,
                  }
                );
              });
              var firstMeta = this.service.state.context.events.find(function (
                e
              ) {
                return (
                  e.type ===
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Meta
                );
              });
              var firstFullsnapshot = this.service.state.context.events.find(
                function (e) {
                  return (
                    e.type ===
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                      .FullSnapshot
                  );
                }
              );
              if (firstMeta) {
                var _a = firstMeta.data,
                  width_1 = _a.width,
                  height_1 = _a.height;
                setTimeout(function () {
                  _this.emitter.emit(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                      .Resize,
                    {
                      width: width_1,
                      height: height_1,
                    }
                  );
                }, 0);
              }
              if (firstFullsnapshot) {
                this.rebuildFullSnapshot(firstFullsnapshot);
              }
            }
            Object.defineProperty(Replayer.prototype, 'timer', {
              get: function () {
                return this.service.state.context.timer;
              },
              enumerable: false,
              configurable: true,
            });
            Replayer.prototype.on = function (event, handler) {
              this.emitter.on(event, handler);
            };
            Replayer.prototype.setConfig = function (config) {
              var _this = this;
              Object.keys(config).forEach(function (key) {
                _this.config[key] = config[key];
              });
              if (!this.config.skipInactive) {
                this.backToNormal();
              }
            };
            Replayer.prototype.getMetaData = function () {
              var firstEvent = this.service.state.context.events[0];
              var lastEvent = this.service.state.context.events[
                this.service.state.context.events.length - 1
              ];
              return {
                startTime: firstEvent.timestamp,
                endTime: lastEvent.timestamp,
                totalTime: lastEvent.timestamp - firstEvent.timestamp,
              };
            };
            Replayer.prototype.getCurrentTime = function () {
              return this.timer.timeOffset + this.getTimeOffset();
            };
            Replayer.prototype.getTimeOffset = function () {
              var _a = this.service.state.context,
                baselineTime = _a.baselineTime,
                events = _a.events;
              return baselineTime - events[0].timestamp;
            };
            Replayer.prototype.play = function (timeOffset) {
              if (timeOffset === void 0) {
                timeOffset = 0;
              }
              if (this.service.state.matches('paused')) {
                this.service.send({
                  type: 'PLAY',
                  payload: { timeOffset: timeOffset },
                });
              } else {
                this.service.send({ type: 'PAUSE' });
                this.service.send({
                  type: 'PLAY',
                  payload: { timeOffset: timeOffset },
                });
              }
              this.emitter.emit(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents'].Start
              );
            };
            Replayer.prototype.pause = function (timeOffset) {
              if (
                timeOffset === undefined &&
                this.service.state.matches('playing')
              ) {
                this.service.send({ type: 'PAUSE' });
              }
              if (typeof timeOffset === 'number') {
                this.play(timeOffset);
                this.service.send({ type: 'PAUSE' });
              }
              this.emitter.emit(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents'].Pause
              );
            };
            Replayer.prototype.resume = function (timeOffset) {
              if (timeOffset === void 0) {
                timeOffset = 0;
              }
              console.warn(
                "The 'resume' will be departed in 1.0. Please use 'play' method which has the same interface."
              );
              this.play(timeOffset);
              this.emitter.emit(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents'].Resume
              );
            };
            Replayer.prototype.startLive = function (baselineTime) {
              this.service.send({
                type: 'TO_LIVE',
                payload: { baselineTime: baselineTime },
              });
            };
            Replayer.prototype.addEvent = function (rawEvent) {
              var _this = this;
              var event = this.config.unpackFn
                ? this.config.unpackFn(rawEvent)
                : rawEvent;
              Promise.resolve().then(function () {
                return _this.service.send({
                  type: 'ADD_EVENT',
                  payload: { event: event },
                });
              });
            };
            Replayer.prototype.enableInteract = function () {
              this.iframe.setAttribute('scrolling', 'auto');
              this.iframe.style.pointerEvents = 'auto';
            };
            Replayer.prototype.disableInteract = function () {
              this.iframe.setAttribute('scrolling', 'no');
              this.iframe.style.pointerEvents = 'none';
            };
            Replayer.prototype.setupDom = function () {
              this.wrapper = document.createElement('div');
              this.wrapper.classList.add('replayer-wrapper');
              this.config.root.appendChild(this.wrapper);
              this.mouse = document.createElement('div');
              this.mouse.classList.add('replayer-mouse');
              this.wrapper.appendChild(this.mouse);
              this.iframe = document.createElement('iframe');
              this.iframe.setAttribute('sandbox', 'allow-same-origin');
              this.disableInteract();
              this.wrapper.appendChild(this.iframe);
            };
            Replayer.prototype.handleResize = function (dimension) {
              this.iframe.setAttribute('width', String(dimension.width));
              this.iframe.setAttribute('height', String(dimension.height));
            };
            Replayer.prototype.getCastFn = function (event, isSync) {
              var _this = this;
              if (isSync === void 0) {
                isSync = false;
              }
              var castFn;
              switch (event.type) {
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                  .DomContentLoaded:
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Load:
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Custom:
                  castFn = function () {
                    _this.emitter.emit(
                      _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                        .CustomEvent,
                      event
                    );
                  };
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType'].Meta:
                  castFn = function () {
                    return _this.emitter.emit(
                      _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                        .Resize,
                      {
                        width: event.data.width,
                        height: event.data.height,
                      }
                    );
                  };
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                  .FullSnapshot:
                  castFn = function () {
                    _this.rebuildFullSnapshot(event);
                    _this.iframe.contentWindow.scrollTo(
                      event.data.initialOffset
                    );
                  };
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                  .IncrementalSnapshot:
                  castFn = function () {
                    var e_4, _a;
                    _this.applyIncremental(event, isSync);
                    if (isSync) {
                      return;
                    }
                    if (event === _this.nextUserInteractionEvent) {
                      _this.nextUserInteractionEvent = null;
                      _this.backToNormal();
                    }
                    if (
                      _this.config.skipInactive &&
                      !_this.nextUserInteractionEvent
                    ) {
                      try {
                        for (
                          var _b = Object(
                              _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                                '__values'
                              ]
                            )(_this.service.state.context.events),
                            _c = _b.next();
                          !_c.done;
                          _c = _b.next()
                        ) {
                          var _event = _c.value;
                          if (_event.timestamp <= event.timestamp) {
                            continue;
                          }
                          if (_this.isUserInteraction(_event)) {
                            if (
                              _event.delay - event.delay >
                              SKIP_TIME_THRESHOLD *
                                _this.speedService.state.context.timer.speed
                            ) {
                              _this.nextUserInteractionEvent = _event;
                            }
                            break;
                          }
                        }
                      } catch (e_4_1) {
                        e_4 = { error: e_4_1 };
                      } finally {
                        try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                          if (e_4) throw e_4.error;
                        }
                      }
                      if (_this.nextUserInteractionEvent) {
                        var skipTime =
                          _this.nextUserInteractionEvent.delay - event.delay;
                        var payload = {
                          speed: Math.min(
                            Math.round(skipTime / SKIP_TIME_INTERVAL),
                            360
                          ),
                        };
                        _this.speedService.send({
                          type: 'FAST_FORWARD',
                          payload: payload,
                        });
                        _this.emitter.emit(
                          _types_js__WEBPACK_IMPORTED_MODULE_2__[
                            'ReplayerEvents'
                          ].SkipStart,
                          payload
                        );
                      }
                    }
                  };
                  break;
              }
              var wrappedCastFn = function () {
                if (castFn) {
                  castFn();
                }
                _this.service.send({
                  type: 'CAST_EVENT',
                  payload: { event: event },
                });
                if (
                  event ===
                  _this.service.state.context.events[
                    _this.service.state.context.events.length - 1
                  ]
                ) {
                  _this.backToNormal();
                  _this.service.send('END');
                  _this.emitter.emit(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                      .Finish
                  );
                }
              };
              return wrappedCastFn;
            };
            Replayer.prototype.rebuildFullSnapshot = function (event) {
              if (!this.iframe.contentDocument) {
                return console.warn(
                  'Looks like your replayer has been destroyed.'
                );
              }
              if (Object.keys(this.legacy_missingNodeRetryMap).length) {
                console.warn(
                  'Found unresolved missing node map',
                  this.legacy_missingNodeRetryMap
                );
              }
              this.legacy_missingNodeRetryMap = {};
              _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].map = Object(
                _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                  'rebuild'
                ]
              )(event.data.node, this.iframe.contentDocument)[1];
              var styleEl = document.createElement('style');
              var _a = this.iframe.contentDocument,
                documentElement = _a.documentElement,
                head = _a.head;
              documentElement.insertBefore(styleEl, head);
              var injectStylesRules = Object(
                _styles_inject_style_js__WEBPACK_IMPORTED_MODULE_8__['default']
              )(this.config.blockClass).concat(this.config.insertStyleRules);
              for (var idx = 0; idx < injectStylesRules.length; idx++) {
                styleEl.sheet.insertRule(injectStylesRules[idx], idx);
              }
              this.emitter.emit(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                  .FullsnapshotRebuilded,
                event
              );
              this.waitForStylesheetLoad();
            };
            Replayer.prototype.waitForStylesheetLoad = function () {
              var _this = this;
              var _a;
              var head =
                (_a = this.iframe.contentDocument) === null || _a === void 0
                  ? void 0
                  : _a.head;
              if (head) {
                var unloadSheets_1 = new Set();
                var timer_1;
                var beforeLoadState_1 = this.service.state;
                var unsubscribe_1 = this.service.subscribe(function (state) {
                  beforeLoadState_1 = state;
                }).unsubscribe;
                head
                  .querySelectorAll('link[rel="stylesheet"]')
                  .forEach(function (css) {
                    if (!css.sheet) {
                      unloadSheets_1.add(css);
                      css.addEventListener('load', function () {
                        unloadSheets_1.delete(css);
                        if (unloadSheets_1.size === 0 && timer_1 !== -1) {
                          if (beforeLoadState_1.matches('playing')) {
                            _this.play(_this.getCurrentTime());
                          }
                          _this.emitter.emit(
                            _types_js__WEBPACK_IMPORTED_MODULE_2__[
                              'ReplayerEvents'
                            ].LoadStylesheetEnd
                          );
                          if (timer_1) {
                            window.clearTimeout(timer_1);
                          }
                          unsubscribe_1();
                        }
                      });
                    }
                  });
                if (unloadSheets_1.size > 0) {
                  this.service.send({ type: 'PAUSE' });
                  this.emitter.emit(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                      .LoadStylesheetStart
                  );
                  timer_1 = window.setTimeout(function () {
                    if (beforeLoadState_1.matches('playing')) {
                      _this.play(_this.getCurrentTime());
                    }
                    timer_1 = -1;
                    unsubscribe_1();
                  }, this.config.loadTimeout);
                }
              }
            };
            Replayer.prototype.applyIncremental = function (e, isSync) {
              var _this = this;
              var d = e.data;
              switch (d.source) {
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .Mutation: {
                  if (isSync) {
                    d.adds.forEach(function (m) {
                      return _this.treeIndex.add(m);
                    });
                    d.texts.forEach(function (m) {
                      return _this.treeIndex.text(m);
                    });
                    d.attributes.forEach(function (m) {
                      return _this.treeIndex.attribute(m);
                    });
                    d.removes.forEach(function (m) {
                      return _this.treeIndex.remove(m);
                    });
                  }
                  this.applyMutation(d, isSync);
                  break;
                }
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .MouseMove:
                  if (isSync) {
                    var lastPosition = d.positions[d.positions.length - 1];
                    this.moveAndHover(
                      d,
                      lastPosition.x,
                      lastPosition.y,
                      lastPosition.id
                    );
                  } else {
                    d.positions.forEach(function (p) {
                      var action = {
                        doAction: function () {
                          _this.moveAndHover(d, p.x, p.y, p.id);
                        },
                        delay:
                          p.timeOffset +
                          e.timestamp -
                          _this.service.state.context.baselineTime,
                      };
                      _this.timer.addAction(action);
                    });
                  }
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .MouseInteraction: {
                  if (d.id === -1) {
                    break;
                  }
                  var event = new Event(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['MouseInteractions'][
                      d.type
                    ].toLowerCase()
                  );
                  var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                    'mirror'
                  ].getNode(d.id);
                  if (!target) {
                    return this.debugNodeNotFound(d, d.id);
                  }
                  this.emitter.emit(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                      .MouseInteraction,
                    {
                      type: d.type,
                      target: target,
                    }
                  );
                  var triggerFocus = this.config.triggerFocus;
                  switch (d.type) {
                    case _types_js__WEBPACK_IMPORTED_MODULE_2__[
                      'MouseInteractions'
                    ].Blur:
                      if ('blur' in target) {
                        target.blur();
                      }
                      break;
                    case _types_js__WEBPACK_IMPORTED_MODULE_2__[
                      'MouseInteractions'
                    ].Focus:
                      if (triggerFocus && target.focus) {
                        target.focus({
                          preventScroll: true,
                        });
                      }
                      break;
                    case _types_js__WEBPACK_IMPORTED_MODULE_2__[
                      'MouseInteractions'
                    ].Click:
                    case _types_js__WEBPACK_IMPORTED_MODULE_2__[
                      'MouseInteractions'
                    ].TouchStart:
                    case _types_js__WEBPACK_IMPORTED_MODULE_2__[
                      'MouseInteractions'
                    ].TouchEnd:
                      if (!isSync) {
                        this.moveAndHover(d, d.x, d.y, d.id);
                        this.mouse.classList.remove('active');
                        void this.mouse.offsetWidth;
                        this.mouse.classList.add('active');
                      }
                      break;
                    default:
                      target.dispatchEvent(event);
                  }
                  break;
                }
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .Scroll: {
                  if (d.id === -1) {
                    break;
                  }
                  if (isSync) {
                    this.treeIndex.scroll(d);
                    break;
                  }
                  this.applyScroll(d);
                  break;
                }
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .ViewportResize:
                  this.emitter.emit(
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                      .Resize,
                    {
                      width: d.width,
                      height: d.height,
                    }
                  );
                  break;
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .Input: {
                  if (d.id === -1) {
                    break;
                  }
                  if (isSync) {
                    this.treeIndex.input(d);
                    break;
                  }
                  this.applyInput(d);
                  break;
                }
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .MediaInteraction: {
                  var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                    'mirror'
                  ].getNode(d.id);
                  if (!target) {
                    return this.debugNodeNotFound(d, d.id);
                  }
                  var mediaEl_1 = target;
                  if (
                    d.type ===
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['MediaInteractions']
                      .Pause
                  ) {
                    mediaEl_1.pause();
                  }
                  if (
                    d.type ===
                    _types_js__WEBPACK_IMPORTED_MODULE_2__['MediaInteractions']
                      .Play
                  ) {
                    if (
                      mediaEl_1.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA
                    ) {
                      mediaEl_1.play();
                    } else {
                      mediaEl_1.addEventListener('canplay', function () {
                        mediaEl_1.play();
                      });
                    }
                  }
                  break;
                }
                case _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                  .StyleSheetRule: {
                  var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                    'mirror'
                  ].getNode(d.id);
                  if (!target) {
                    return this.debugNodeNotFound(d, d.id);
                  }
                  var styleEl = target;
                  var styleSheet_1 = styleEl.sheet;
                  if (d.adds) {
                    d.adds.forEach(function (_a) {
                      var rule = _a.rule,
                        index = _a.index;
                      var _index =
                        index === undefined
                          ? undefined
                          : Math.min(index, styleSheet_1.rules.length);
                      try {
                        styleSheet_1.insertRule(rule, _index);
                      } catch (e) {}
                    });
                  }
                  if (d.removes) {
                    d.removes.forEach(function (_a) {
                      var index = _a.index;
                      styleSheet_1.deleteRule(index);
                    });
                  }
                  break;
                }
              }
            };
            Replayer.prototype.applyMutation = function (d, useVirtualParent) {
              var _this = this;
              d.removes.forEach(function (mutation) {
                var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].getNode(mutation.id);
                if (!target) {
                  return _this.warnNodeNotFound(d, mutation.id);
                }
                var parent = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].getNode(mutation.parentId);
                if (!parent) {
                  return _this.warnNodeNotFound(d, mutation.parentId);
                }
                _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].removeNodeFromMap(target);
                if (parent) {
                  var realParent = _this.fragmentParentMap.get(parent);
                  if (realParent && realParent.contains(target)) {
                    realParent.removeChild(target);
                  } else {
                    parent.removeChild(target);
                  }
                }
              });
              var legacy_missingNodeMap = Object(
                _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                  '__assign'
                ]
              )({}, this.legacy_missingNodeRetryMap);
              var queue = [];
              var appendNode = function (mutation) {
                if (!_this.iframe.contentDocument) {
                  return console.warn(
                    'Looks like your replayer has been destroyed.'
                  );
                }
                var parent = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].getNode(mutation.parentId);
                if (!parent) {
                  return queue.push(mutation);
                }
                var parentInDocument = _this.iframe.contentDocument.contains(
                  parent
                );
                if (useVirtualParent && parentInDocument) {
                  var virtualParent = document.createDocumentFragment();
                  _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].map[
                    mutation.parentId
                  ] = virtualParent;
                  _this.fragmentParentMap.set(virtualParent, parent);
                  while (parent.firstChild) {
                    virtualParent.appendChild(parent.firstChild);
                  }
                  parent = virtualParent;
                }
                var previous = null;
                var next = null;
                if (mutation.previousId) {
                  previous = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                    'mirror'
                  ].getNode(mutation.previousId);
                }
                if (mutation.nextId) {
                  next = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                    'mirror'
                  ].getNode(mutation.nextId);
                }
                if (
                  mutation.nextId !== null &&
                  mutation.nextId !== -1 &&
                  !next
                ) {
                  return queue.push(mutation);
                }
                var target = Object(
                  _node_modules_rrweb_snapshot_es_rrweb_snapshot_js__WEBPACK_IMPORTED_MODULE_1__[
                    'buildNodeWithSN'
                  ]
                )(
                  mutation.node,
                  _this.iframe.contentDocument,
                  _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].map,
                  true
                );
                if (mutation.previousId === -1 || mutation.nextId === -1) {
                  legacy_missingNodeMap[mutation.node.id] = {
                    node: target,
                    mutation: mutation,
                  };
                  return;
                }
                if (
                  previous &&
                  previous.nextSibling &&
                  previous.nextSibling.parentNode
                ) {
                  parent.insertBefore(target, previous.nextSibling);
                } else if (next && next.parentNode) {
                  parent.contains(next)
                    ? parent.insertBefore(target, next)
                    : parent.insertBefore(target, null);
                } else {
                  parent.appendChild(target);
                }
                if (mutation.previousId || mutation.nextId) {
                  _this.legacy_resolveMissingNode(
                    legacy_missingNodeMap,
                    parent,
                    target,
                    mutation
                  );
                }
              };
              d.adds.forEach(function (mutation) {
                appendNode(mutation);
              });
              while (queue.length) {
                if (
                  queue.every(function (m) {
                    return !Boolean(
                      _utils_js__WEBPACK_IMPORTED_MODULE_3__['mirror'].getNode(
                        m.parentId
                      )
                    );
                  })
                ) {
                  return queue.forEach(function (m) {
                    return _this.warnNodeNotFound(d, m.node.id);
                  });
                }
                var mutation = queue.shift();
                appendNode(mutation);
              }
              if (Object.keys(legacy_missingNodeMap).length) {
                Object.assign(
                  this.legacy_missingNodeRetryMap,
                  legacy_missingNodeMap
                );
              }
              d.texts.forEach(function (mutation) {
                var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].getNode(mutation.id);
                if (!target) {
                  return _this.warnNodeNotFound(d, mutation.id);
                }
                if (_this.fragmentParentMap.has(target)) {
                  target = _this.fragmentParentMap.get(target);
                }
                target.textContent = mutation.value;
              });
              d.attributes.forEach(function (mutation) {
                var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                  'mirror'
                ].getNode(mutation.id);
                if (!target) {
                  return _this.warnNodeNotFound(d, mutation.id);
                }
                if (_this.fragmentParentMap.has(target)) {
                  target = _this.fragmentParentMap.get(target);
                }
                for (var attributeName in mutation.attributes) {
                  if (typeof attributeName === 'string') {
                    var value = mutation.attributes[attributeName];
                    if (value !== null) {
                      target.setAttribute(attributeName, value);
                    } else {
                      target.removeAttribute(attributeName);
                    }
                  }
                }
              });
            };
            Replayer.prototype.applyScroll = function (d) {
              var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                'mirror'
              ].getNode(d.id);
              if (!target) {
                return this.debugNodeNotFound(d, d.id);
              }
              if (target === this.iframe.contentDocument) {
                this.iframe.contentWindow.scrollTo({
                  top: d.y,
                  left: d.x,
                  behavior: 'smooth',
                });
              } else {
                try {
                  target.scrollTop = d.y;
                  target.scrollLeft = d.x;
                } catch (error) {}
              }
            };
            Replayer.prototype.applyInput = function (d) {
              var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                'mirror'
              ].getNode(d.id);
              if (!target) {
                return this.debugNodeNotFound(d, d.id);
              }
              try {
                target.checked = d.isChecked;
                target.value = d.text;
              } catch (error) {}
            };
            Replayer.prototype.legacy_resolveMissingNode = function (
              map,
              parent,
              target,
              targetMutation
            ) {
              var previousId = targetMutation.previousId,
                nextId = targetMutation.nextId;
              var previousInMap = previousId && map[previousId];
              var nextInMap = nextId && map[nextId];
              if (previousInMap) {
                var _a = previousInMap,
                  node = _a.node,
                  mutation = _a.mutation;
                parent.insertBefore(node, target);
                delete map[mutation.node.id];
                delete this.legacy_missingNodeRetryMap[mutation.node.id];
                if (mutation.previousId || mutation.nextId) {
                  this.legacy_resolveMissingNode(map, parent, node, mutation);
                }
              }
              if (nextInMap) {
                var _b = nextInMap,
                  node = _b.node,
                  mutation = _b.mutation;
                parent.insertBefore(node, target.nextSibling);
                delete map[mutation.node.id];
                delete this.legacy_missingNodeRetryMap[mutation.node.id];
                if (mutation.previousId || mutation.nextId) {
                  this.legacy_resolveMissingNode(map, parent, node, mutation);
                }
              }
            };
            Replayer.prototype.moveAndHover = function (d, x, y, id) {
              this.mouse.style.left = x + 'px';
              this.mouse.style.top = y + 'px';
              var target = _utils_js__WEBPACK_IMPORTED_MODULE_3__[
                'mirror'
              ].getNode(id);
              if (!target) {
                return this.debugNodeNotFound(d, id);
              }
              this.hoverElements(target);
            };
            Replayer.prototype.hoverElements = function (el) {
              var _a;
              (_a = this.iframe.contentDocument) === null || _a === void 0
                ? void 0
                : _a
                    .querySelectorAll('.\\:hover')
                    .forEach(function (hoveredEl) {
                      hoveredEl.classList.remove(':hover');
                    });
              var currentEl = el;
              while (currentEl) {
                if (currentEl.classList) {
                  currentEl.classList.add(':hover');
                }
                currentEl = currentEl.parentElement;
              }
            };
            Replayer.prototype.isUserInteraction = function (event) {
              if (
                event.type !==
                _types_js__WEBPACK_IMPORTED_MODULE_2__['EventType']
                  .IncrementalSnapshot
              ) {
                return false;
              }
              return (
                event.data.source >
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                    .Mutation &&
                event.data.source <=
                  _types_js__WEBPACK_IMPORTED_MODULE_2__['IncrementalSource']
                    .Input
              );
            };
            Replayer.prototype.backToNormal = function () {
              this.nextUserInteractionEvent = null;
              if (this.speedService.state.matches('normal')) {
                return;
              }
              this.speedService.send({ type: 'BACK_TO_NORMAL' });
              this.emitter.emit(
                _types_js__WEBPACK_IMPORTED_MODULE_2__['ReplayerEvents']
                  .SkipEnd,
                {
                  speed: this.speedService.state.context.normalSpeed,
                }
              );
            };
            Replayer.prototype.warnNodeNotFound = function (d, id) {
              if (!this.config.showWarning) {
                return;
              }
              console.warn(
                REPLAY_CONSOLE_PREFIX,
                "Node with id '" + id + "' not found in",
                d
              );
            };
            Replayer.prototype.debugNodeNotFound = function (d, id) {
              if (!this.config.showDebug) {
                return;
              }
              console.log(
                REPLAY_CONSOLE_PREFIX,
                "Node with id '" + id + "' not found in",
                d
              );
            };
            return Replayer;
          })();

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/replay/machine.js':
        /*!***********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/replay/machine.js ***!
  \***********************************************************/
        /*! exports provided: createPlayerService, createSpeedService, discardPriorSnapshots */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createPlayerService',
            function () {
              return createPlayerService;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createSpeedService',
            function () {
              return createSpeedService;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'discardPriorSnapshots',
            function () {
              return discardPriorSnapshots;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );
          /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! ../utils.js */ './node_modules/rrweb/es/rrweb/src/utils.js'
          );
          /* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
            /*! ./timer.js */ './node_modules/rrweb/es/rrweb/src/replay/timer.js'
          );
          /* harmony import */ var _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
            /*! ../../node_modules/@xstate/fsm/es/index.js */ './node_modules/rrweb/es/rrweb/node_modules/@xstate/fsm/es/index.js'
          );

          function discardPriorSnapshots(events, baselineTime) {
            for (var idx = events.length - 1; idx >= 0; idx--) {
              var event = events[idx];
              if (
                event.type ===
                _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType'].Meta
              ) {
                if (event.timestamp <= baselineTime) {
                  return events.slice(idx);
                }
              }
            }
            return events;
          }
          function createPlayerService(context, _a) {
            var getCastFn = _a.getCastFn,
              emitter = _a.emitter;
            var playerMachine = Object(
              _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'createMachine'
              ]
            )(
              {
                id: 'player',
                context: context,
                initial: 'paused',
                states: {
                  playing: {
                    on: {
                      PAUSE: {
                        target: 'paused',
                        actions: ['pause'],
                      },
                      CAST_EVENT: {
                        target: 'playing',
                        actions: 'castEvent',
                      },
                      END: {
                        target: 'paused',
                        actions: ['resetLastPlayedEvent', 'pause'],
                      },
                    },
                  },
                  paused: {
                    on: {
                      PLAY: {
                        target: 'playing',
                        actions: ['recordTimeOffset', 'play'],
                      },
                      CAST_EVENT: {
                        target: 'paused',
                        actions: 'castEvent',
                      },
                    },
                  },
                  live: {
                    on: {
                      ADD_EVENT: {
                        target: 'live',
                        actions: ['addEvent'],
                      },
                    },
                  },
                },
              },
              {
                actions: {
                  castEvent: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )({
                    lastPlayedEvent: function (ctx, event) {
                      if (event.type === 'CAST_EVENT') {
                        return event.payload.event;
                      }
                      return ctx.lastPlayedEvent;
                    },
                  }),
                  recordTimeOffset: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )(function (ctx, event) {
                    var timeOffset = ctx.timeOffset;
                    if ('payload' in event && 'timeOffset' in event.payload) {
                      timeOffset = event.payload.timeOffset;
                    }
                    return Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__assign'
                      ]
                    )(
                      Object(
                        _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                          '__assign'
                        ]
                      )({}, ctx),
                      {
                        timeOffset: timeOffset,
                        baselineTime: ctx.events[0].timestamp + timeOffset,
                      }
                    );
                  }),
                  play: function (ctx) {
                    var e_1, _a, e_2, _b;
                    var timer = ctx.timer,
                      events = ctx.events,
                      baselineTime = ctx.baselineTime,
                      lastPlayedEvent = ctx.lastPlayedEvent;
                    timer.clear();
                    try {
                      for (
                        var events_1 = Object(
                            _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                              '__values'
                            ]
                          )(events),
                          events_1_1 = events_1.next();
                        !events_1_1.done;
                        events_1_1 = events_1.next()
                      ) {
                        var event = events_1_1.value;
                        Object(
                          _timer_js__WEBPACK_IMPORTED_MODULE_3__['addDelay']
                        )(event, baselineTime);
                      }
                    } catch (e_1_1) {
                      e_1 = { error: e_1_1 };
                    } finally {
                      try {
                        if (
                          events_1_1 &&
                          !events_1_1.done &&
                          (_a = events_1.return)
                        )
                          _a.call(events_1);
                      } finally {
                        if (e_1) throw e_1.error;
                      }
                    }
                    var neededEvents = discardPriorSnapshots(
                      events,
                      baselineTime
                    );
                    var actions = new Array();
                    var _loop_1 = function (event) {
                      if (
                        lastPlayedEvent &&
                        lastPlayedEvent.timestamp < baselineTime &&
                        (event.timestamp <= lastPlayedEvent.timestamp ||
                          event === lastPlayedEvent)
                      ) {
                        return 'continue';
                      }
                      var isSync = event.timestamp < baselineTime;
                      if (
                        isSync &&
                        !Object(
                          _utils_js__WEBPACK_IMPORTED_MODULE_2__[
                            'needCastInSyncMode'
                          ]
                        )(event)
                      ) {
                        return 'continue';
                      }
                      var castFn = getCastFn(event, isSync);
                      if (isSync) {
                        castFn();
                      } else {
                        actions.push({
                          doAction: function () {
                            castFn();
                            emitter.emit(
                              _types_js__WEBPACK_IMPORTED_MODULE_1__[
                                'ReplayerEvents'
                              ].EventCast,
                              event
                            );
                          },
                          delay: event.delay,
                        });
                      }
                    };
                    try {
                      for (
                        var neededEvents_1 = Object(
                            _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                              '__values'
                            ]
                          )(neededEvents),
                          neededEvents_1_1 = neededEvents_1.next();
                        !neededEvents_1_1.done;
                        neededEvents_1_1 = neededEvents_1.next()
                      ) {
                        var event = neededEvents_1_1.value;
                        _loop_1(event);
                      }
                    } catch (e_2_1) {
                      e_2 = { error: e_2_1 };
                    } finally {
                      try {
                        if (
                          neededEvents_1_1 &&
                          !neededEvents_1_1.done &&
                          (_b = neededEvents_1.return)
                        )
                          _b.call(neededEvents_1);
                      } finally {
                        if (e_2) throw e_2.error;
                      }
                    }
                    emitter.emit(
                      _types_js__WEBPACK_IMPORTED_MODULE_1__['ReplayerEvents']
                        .Flush
                    );
                    timer.addActions(actions);
                    timer.start();
                  },
                  pause: function (ctx) {
                    ctx.timer.clear();
                  },
                  resetLastPlayedEvent: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )(function (ctx) {
                    return Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__assign'
                      ]
                    )(
                      Object(
                        _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                          '__assign'
                        ]
                      )({}, ctx),
                      { lastPlayedEvent: null }
                    );
                  }),
                  startLive: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )({
                    baselineTime: function (ctx, event) {
                      ctx.timer.toggleLiveMode(true);
                      ctx.timer.start();
                      if (
                        event.type === 'TO_LIVE' &&
                        event.payload.baselineTime
                      ) {
                        return event.payload.baselineTime;
                      }
                      return Date.now();
                    },
                  }),
                  addEvent: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )(function (ctx, machineEvent) {
                    var baselineTime = ctx.baselineTime,
                      timer = ctx.timer,
                      events = ctx.events;
                    if (machineEvent.type === 'ADD_EVENT') {
                      var event_1 = machineEvent.payload.event;
                      Object(
                        _timer_js__WEBPACK_IMPORTED_MODULE_3__['addDelay']
                      )(event_1, baselineTime);
                      events.push(event_1);
                      var isSync = event_1.timestamp < baselineTime;
                      var castFn_1 = getCastFn(event_1, isSync);
                      if (isSync) {
                        castFn_1();
                      } else {
                        timer.addAction({
                          doAction: function () {
                            castFn_1();
                            emitter.emit(
                              _types_js__WEBPACK_IMPORTED_MODULE_1__[
                                'ReplayerEvents'
                              ].EventCast,
                              event_1
                            );
                          },
                          delay: event_1.delay,
                        });
                      }
                    }
                    return Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__assign'
                      ]
                    )(
                      Object(
                        _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                          '__assign'
                        ]
                      )({}, ctx),
                      { events: events }
                    );
                  }),
                },
              }
            );
            return Object(
              _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'interpret'
              ]
            )(playerMachine);
          }
          function createSpeedService(context) {
            var speedMachine = Object(
              _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'createMachine'
              ]
            )(
              {
                id: 'speed',
                context: context,
                initial: 'normal',
                states: {
                  normal: {
                    on: {
                      FAST_FORWARD: {
                        target: 'skipping',
                        actions: ['recordSpeed', 'setSpeed'],
                      },
                      SET_SPEED: {
                        target: 'normal',
                        actions: ['setSpeed'],
                      },
                    },
                  },
                  skipping: {
                    on: {
                      BACK_TO_NORMAL: {
                        target: 'normal',
                        actions: ['restoreSpeed'],
                      },
                      SET_SPEED: {
                        target: 'normal',
                        actions: ['setSpeed'],
                      },
                    },
                  },
                },
              },
              {
                actions: {
                  setSpeed: function (ctx, event) {
                    if ('payload' in event) {
                      ctx.timer.setSpeed(event.payload.speed);
                    }
                  },
                  recordSpeed: Object(
                    _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                      'assign'
                    ]
                  )({
                    normalSpeed: function (ctx) {
                      return ctx.timer.speed;
                    },
                  }),
                  restoreSpeed: function (ctx) {
                    ctx.timer.setSpeed(ctx.normalSpeed);
                  },
                },
              }
            );
            return Object(
              _node_modules_xstate_fsm_es_index_js__WEBPACK_IMPORTED_MODULE_4__[
                'interpret'
              ]
            )(speedMachine);
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/replay/styles/inject-style.js':
        /*!***********************************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/replay/styles/inject-style.js ***!
  \***********************************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          var rules = function (blockClass) {
            return [
              'iframe, .' + blockClass + ' { background: #ccc }',
              'noscript { display: none !important; }',
            ];
          };

          /* harmony default export */ __webpack_exports__['default'] = rules;

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/replay/timer.js':
        /*!*********************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/replay/timer.js ***!
  \*********************************************************/
        /*! exports provided: Timer, addDelay */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Timer',
            function () {
              return Timer;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'addDelay',
            function () {
              return addDelay;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ../types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );

          var Timer = (function () {
            function Timer(actions, speed) {
              if (actions === void 0) {
                actions = [];
              }
              this.timeOffset = 0;
              this.actions = actions;
              this.speed = speed;
            }
            Timer.prototype.addAction = function (action) {
              var index = this.findActionIndex(action);
              this.actions.splice(index, 0, action);
            };
            Timer.prototype.addActions = function (actions) {
              var _a;
              (_a = this.actions).push.apply(
                _a,
                Object(
                  _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                    '__spread'
                  ]
                )(actions)
              );
            };
            Timer.prototype.start = function () {
              this.actions.sort(function (a1, a2) {
                return a1.delay - a2.delay;
              });
              this.timeOffset = 0;
              var lastTimestamp = performance.now();
              var actions = this.actions;
              var self = this;
              function check(time) {
                self.timeOffset += (time - lastTimestamp) * self.speed;
                lastTimestamp = time;
                while (actions.length) {
                  var action = actions[0];
                  if (self.timeOffset >= action.delay) {
                    actions.shift();
                    action.doAction();
                  } else {
                    break;
                  }
                }
                if (actions.length > 0 || self.liveMode) {
                  self.raf = requestAnimationFrame(check);
                }
              }
              this.raf = requestAnimationFrame(check);
            };
            Timer.prototype.clear = function () {
              if (this.raf) {
                cancelAnimationFrame(this.raf);
              }
              this.actions.length = 0;
            };
            Timer.prototype.setSpeed = function (speed) {
              this.speed = speed;
            };
            Timer.prototype.toggleLiveMode = function (mode) {
              this.liveMode = mode;
            };
            Timer.prototype.findActionIndex = function (action) {
              var start = 0;
              var end = this.actions.length - 1;
              while (start <= end) {
                var mid = Math.floor((start + end) / 2);
                if (this.actions[mid].delay < action.delay) {
                  start = mid + 1;
                } else if (this.actions[mid].delay > action.delay) {
                  end = mid - 1;
                } else {
                  return mid;
                }
              }
              return start;
            };
            return Timer;
          })();
          function addDelay(event, baselineTime) {
            if (
              event.type ===
                _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType']
                  .IncrementalSnapshot &&
              event.data.source ===
                _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                  .MouseMove
            ) {
              var firstOffset = event.data.positions[0].timeOffset;
              var firstTimestamp = event.timestamp + firstOffset;
              event.delay = firstTimestamp - baselineTime;
              return firstTimestamp - baselineTime;
            }
            event.delay = event.timestamp - baselineTime;
            return event.delay;
          }

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/types.js':
        /*!**************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/types.js ***!
  \**************************************************/
        /*! exports provided: EventType, IncrementalSource, MediaInteractions, MouseInteractions, ReplayerEvents */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'EventType',
            function () {
              return EventType;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'IncrementalSource',
            function () {
              return IncrementalSource;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'MediaInteractions',
            function () {
              return MediaInteractions;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'MouseInteractions',
            function () {
              return MouseInteractions;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ReplayerEvents',
            function () {
              return ReplayerEvents;
            }
          );
          var EventType;
          (function (EventType) {
            EventType[(EventType['DomContentLoaded'] = 0)] = 'DomContentLoaded';
            EventType[(EventType['Load'] = 1)] = 'Load';
            EventType[(EventType['FullSnapshot'] = 2)] = 'FullSnapshot';
            EventType[(EventType['IncrementalSnapshot'] = 3)] =
              'IncrementalSnapshot';
            EventType[(EventType['Meta'] = 4)] = 'Meta';
            EventType[(EventType['Custom'] = 5)] = 'Custom';
          })(EventType || (EventType = {}));
          var IncrementalSource;
          (function (IncrementalSource) {
            IncrementalSource[(IncrementalSource['Mutation'] = 0)] = 'Mutation';
            IncrementalSource[(IncrementalSource['MouseMove'] = 1)] =
              'MouseMove';
            IncrementalSource[(IncrementalSource['MouseInteraction'] = 2)] =
              'MouseInteraction';
            IncrementalSource[(IncrementalSource['Scroll'] = 3)] = 'Scroll';
            IncrementalSource[(IncrementalSource['ViewportResize'] = 4)] =
              'ViewportResize';
            IncrementalSource[(IncrementalSource['Input'] = 5)] = 'Input';
            IncrementalSource[(IncrementalSource['TouchMove'] = 6)] =
              'TouchMove';
            IncrementalSource[(IncrementalSource['MediaInteraction'] = 7)] =
              'MediaInteraction';
            IncrementalSource[(IncrementalSource['StyleSheetRule'] = 8)] =
              'StyleSheetRule';
          })(IncrementalSource || (IncrementalSource = {}));
          var MouseInteractions;
          (function (MouseInteractions) {
            MouseInteractions[(MouseInteractions['MouseUp'] = 0)] = 'MouseUp';
            MouseInteractions[(MouseInteractions['MouseDown'] = 1)] =
              'MouseDown';
            MouseInteractions[(MouseInteractions['Click'] = 2)] = 'Click';
            MouseInteractions[(MouseInteractions['ContextMenu'] = 3)] =
              'ContextMenu';
            MouseInteractions[(MouseInteractions['DblClick'] = 4)] = 'DblClick';
            MouseInteractions[(MouseInteractions['Focus'] = 5)] = 'Focus';
            MouseInteractions[(MouseInteractions['Blur'] = 6)] = 'Blur';
            MouseInteractions[(MouseInteractions['TouchStart'] = 7)] =
              'TouchStart';
            MouseInteractions[(MouseInteractions['TouchMove_Departed'] = 8)] =
              'TouchMove_Departed';
            MouseInteractions[(MouseInteractions['TouchEnd'] = 9)] = 'TouchEnd';
          })(MouseInteractions || (MouseInteractions = {}));
          var MediaInteractions;
          (function (MediaInteractions) {
            MediaInteractions[(MediaInteractions['Play'] = 0)] = 'Play';
            MediaInteractions[(MediaInteractions['Pause'] = 1)] = 'Pause';
          })(MediaInteractions || (MediaInteractions = {}));
          var ReplayerEvents;
          (function (ReplayerEvents) {
            ReplayerEvents['Start'] = 'start';
            ReplayerEvents['Pause'] = 'pause';
            ReplayerEvents['Resume'] = 'resume';
            ReplayerEvents['Resize'] = 'resize';
            ReplayerEvents['Finish'] = 'finish';
            ReplayerEvents['FullsnapshotRebuilded'] = 'fullsnapshot-rebuilded';
            ReplayerEvents['LoadStylesheetStart'] = 'load-stylesheet-start';
            ReplayerEvents['LoadStylesheetEnd'] = 'load-stylesheet-end';
            ReplayerEvents['SkipStart'] = 'skip-start';
            ReplayerEvents['SkipEnd'] = 'skip-end';
            ReplayerEvents['MouseInteraction'] = 'mouse-interaction';
            ReplayerEvents['EventCast'] = 'event-cast';
            ReplayerEvents['CustomEvent'] = 'custom-event';
            ReplayerEvents['Flush'] = 'flush';
            ReplayerEvents['StateChange'] = 'state-change';
          })(ReplayerEvents || (ReplayerEvents = {}));

          /***/
        },

      /***/ './node_modules/rrweb/es/rrweb/src/utils.js':
        /*!**************************************************!*\
  !*** ./node_modules/rrweb/es/rrweb/src/utils.js ***!
  \**************************************************/
        /*! exports provided: TreeIndex, getWindowHeight, getWindowWidth, hookSetter, isAncestorRemoved, isBlocked, isTouchEvent, mirror, needCastInSyncMode, on, patch, polyfill, throttle */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'TreeIndex',
            function () {
              return TreeIndex;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getWindowHeight',
            function () {
              return getWindowHeight;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getWindowWidth',
            function () {
              return getWindowWidth;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hookSetter',
            function () {
              return hookSetter;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isAncestorRemoved',
            function () {
              return isAncestorRemoved;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isBlocked',
            function () {
              return isBlocked;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isTouchEvent',
            function () {
              return isTouchEvent;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'mirror',
            function () {
              return mirror;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'needCastInSyncMode',
            function () {
              return needCastInSyncMode;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'on',
            function () {
              return on;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'patch',
            function () {
              return patch;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'polyfill',
            function () {
              return polyfill;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'throttle',
            function () {
              return throttle;
            }
          );
          /* harmony import */ var _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! ../node_modules/tslib/tslib.es6.js */ './node_modules/rrweb/es/rrweb/node_modules/tslib/tslib.es6.js'
          );
          /* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! ./types.js */ './node_modules/rrweb/es/rrweb/src/types.js'
          );

          function on(type, fn, target) {
            if (target === void 0) {
              target = document;
            }
            var options = { capture: true, passive: true };
            target.addEventListener(type, fn, options);
            return function () {
              return target.removeEventListener(type, fn, options);
            };
          }
          var mirror = {
            map: {},
            getId: function (n) {
              if (!n.__sn) {
                return -1;
              }
              return n.__sn.id;
            },
            getNode: function (id) {
              return mirror.map[id] || null;
            },
            removeNodeFromMap: function (n) {
              var id = n.__sn && n.__sn.id;
              delete mirror.map[id];
              if (n.childNodes) {
                n.childNodes.forEach(function (child) {
                  return mirror.removeNodeFromMap(child);
                });
              }
            },
            has: function (id) {
              return mirror.map.hasOwnProperty(id);
            },
          };
          function throttle(func, wait, options) {
            if (options === void 0) {
              options = {};
            }
            var timeout = null;
            var previous = 0;
            return function (arg) {
              var now = Date.now();
              if (!previous && options.leading === false) {
                previous = now;
              }
              var remaining = wait - (now - previous);
              var context = this;
              var args = arguments;
              if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                  window.clearTimeout(timeout);
                  timeout = null;
                }
                previous = now;
                func.apply(context, args);
              } else if (!timeout && options.trailing !== false) {
                timeout = window.setTimeout(function () {
                  previous = options.leading === false ? 0 : Date.now();
                  timeout = null;
                  func.apply(context, args);
                }, remaining);
              }
            };
          }
          function hookSetter(target, key, d, isRevoked, win) {
            if (win === void 0) {
              win = window;
            }
            var original = win.Object.getOwnPropertyDescriptor(target, key);
            win.Object.defineProperty(
              target,
              key,
              isRevoked
                ? d
                : {
                    set: function (value) {
                      var _this = this;
                      setTimeout(function () {
                        d.set.call(_this, value);
                      }, 0);
                      if (original && original.set) {
                        original.set.call(this, value);
                      }
                    },
                  }
            );
            return function () {
              return hookSetter(target, key, original || {}, true);
            };
          }
          function patch(source, name, replacement) {
            if (!(name in source)) {
              return function () {};
            }
            var original = source[name];
            var wrapped = replacement(original);
            if (typeof wrapped === 'function') {
              try {
                wrapped.prototype = wrapped.prototype || {};
                Object.defineProperties(wrapped, {
                  __rrweb_original__: {
                    enumerable: false,
                    value: original,
                  },
                });
              } catch (_a) {}
            }
            source[name] = wrapped;
            return function () {
              source[name] = original;
            };
          }
          function getWindowHeight() {
            return (
              window.innerHeight ||
              (document.documentElement &&
                document.documentElement.clientHeight) ||
              (document.body && document.body.clientHeight)
            );
          }
          function getWindowWidth() {
            return (
              window.innerWidth ||
              (document.documentElement &&
                document.documentElement.clientWidth) ||
              (document.body && document.body.clientWidth)
            );
          }
          function isBlocked(node, blockClass) {
            if (!node) {
              return false;
            }
            if (node.nodeType === node.ELEMENT_NODE) {
              var needBlock_1 = false;
              if (typeof blockClass === 'string') {
                needBlock_1 = node.classList.contains(blockClass);
              } else {
                node.classList.forEach(function (className) {
                  if (blockClass.test(className)) {
                    needBlock_1 = true;
                  }
                });
              }
              return needBlock_1 || isBlocked(node.parentNode, blockClass);
            }
            if (node.nodeType === node.TEXT_NODE) {
              return isBlocked(node.parentNode, blockClass);
            }
            return isBlocked(node.parentNode, blockClass);
          }
          function isAncestorRemoved(target) {
            var id = mirror.getId(target);
            if (!mirror.has(id)) {
              return true;
            }
            if (
              target.parentNode &&
              target.parentNode.nodeType === target.DOCUMENT_NODE
            ) {
              return false;
            }
            if (!target.parentNode) {
              return true;
            }
            return isAncestorRemoved(target.parentNode);
          }
          function isTouchEvent(event) {
            return Boolean(event.changedTouches);
          }
          function polyfill() {
            if ('NodeList' in window && !NodeList.prototype.forEach) {
              NodeList.prototype.forEach = Array.prototype.forEach;
            }
          }
          function needCastInSyncMode(event) {
            switch (event.type) {
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType']
                .DomContentLoaded:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType'].Load:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType'].Custom:
                return false;
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType']
                .FullSnapshot:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['EventType'].Meta:
                return true;
            }
            switch (event.data.source) {
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .MouseMove:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .MouseInteraction:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .TouchMove:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .MediaInteraction:
                return false;
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .ViewportResize:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .StyleSheetRule:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .Scroll:
              case _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                .Input:
                return true;
            }
            return true;
          }
          var TreeIndex = (function () {
            function TreeIndex() {
              this.reset();
            }
            TreeIndex.prototype.add = function (mutation) {
              var parentTreeNode = this.indexes.get(mutation.parentId);
              var treeNode = {
                id: mutation.node.id,
                mutation: mutation,
                children: [],
                texts: [],
                attributes: [],
              };
              if (!parentTreeNode) {
                this.tree[treeNode.id] = treeNode;
              } else {
                treeNode.parent = parentTreeNode;
                parentTreeNode.children[treeNode.id] = treeNode;
              }
              this.indexes.set(treeNode.id, treeNode);
            };
            TreeIndex.prototype.remove = function (mutation) {
              var _this = this;
              var parentTreeNode = this.indexes.get(mutation.parentId);
              var treeNode = this.indexes.get(mutation.id);
              var deepRemoveFromMirror = function (id) {
                _this.removeIdSet.add(id);
                var node = mirror.getNode(id);
                node === null || node === void 0
                  ? void 0
                  : node.childNodes.forEach(function (childNode) {
                      return deepRemoveFromMirror(childNode.__sn.id);
                    });
              };
              var deepRemoveFromTreeIndex = function (node) {
                _this.removeIdSet.add(node.id);
                Object.values(node.children).forEach(function (n) {
                  return deepRemoveFromTreeIndex(n);
                });
                var _treeNode = _this.indexes.get(node.id);
                if (_treeNode) {
                  var _parentTreeNode = _treeNode.parent;
                  if (_parentTreeNode) {
                    delete _treeNode.parent;
                    delete _parentTreeNode.children[_treeNode.id];
                    _this.indexes.delete(mutation.id);
                  }
                }
              };
              if (!treeNode) {
                this.removeNodeMutations.push(mutation);
                deepRemoveFromMirror(mutation.id);
              } else if (!parentTreeNode) {
                delete this.tree[treeNode.id];
                this.indexes.delete(treeNode.id);
                deepRemoveFromTreeIndex(treeNode);
              } else {
                delete treeNode.parent;
                delete parentTreeNode.children[treeNode.id];
                this.indexes.delete(mutation.id);
                deepRemoveFromTreeIndex(treeNode);
              }
            };
            TreeIndex.prototype.text = function (mutation) {
              var treeNode = this.indexes.get(mutation.id);
              if (treeNode) {
                treeNode.texts.push(mutation);
              } else {
                this.textMutations.push(mutation);
              }
            };
            TreeIndex.prototype.attribute = function (mutation) {
              var treeNode = this.indexes.get(mutation.id);
              if (treeNode) {
                treeNode.attributes.push(mutation);
              } else {
                this.attributeMutations.push(mutation);
              }
            };
            TreeIndex.prototype.scroll = function (d) {
              this.scrollMap.set(d.id, d);
            };
            TreeIndex.prototype.input = function (d) {
              this.inputMap.set(d.id, d);
            };
            TreeIndex.prototype.flush = function () {
              var e_1, _a, e_2, _b;
              var _this = this;
              var _c = this,
                tree = _c.tree,
                removeNodeMutations = _c.removeNodeMutations,
                textMutations = _c.textMutations,
                attributeMutations = _c.attributeMutations;
              var batchMutationData = {
                source:
                  _types_js__WEBPACK_IMPORTED_MODULE_1__['IncrementalSource']
                    .Mutation,
                removes: removeNodeMutations,
                texts: textMutations,
                attributes: attributeMutations,
                adds: [],
              };
              var walk = function (treeNode, removed) {
                if (removed) {
                  _this.removeIdSet.add(treeNode.id);
                }
                batchMutationData.texts = batchMutationData.texts
                  .concat(removed ? [] : treeNode.texts)
                  .filter(function (m) {
                    return !_this.removeIdSet.has(m.id);
                  });
                batchMutationData.attributes = batchMutationData.attributes
                  .concat(removed ? [] : treeNode.attributes)
                  .filter(function (m) {
                    return !_this.removeIdSet.has(m.id);
                  });
                if (
                  !_this.removeIdSet.has(treeNode.id) &&
                  !_this.removeIdSet.has(treeNode.mutation.parentId) &&
                  !removed
                ) {
                  batchMutationData.adds.push(treeNode.mutation);
                  if (treeNode.children) {
                    Object.values(treeNode.children).forEach(function (n) {
                      return walk(n, false);
                    });
                  }
                } else {
                  Object.values(treeNode.children).forEach(function (n) {
                    return walk(n, true);
                  });
                }
              };
              Object.values(tree).forEach(function (n) {
                return walk(n, false);
              });
              try {
                for (
                  var _d = Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__values'
                      ]
                    )(this.scrollMap.keys()),
                    _e = _d.next();
                  !_e.done;
                  _e = _d.next()
                ) {
                  var id = _e.value;
                  if (this.removeIdSet.has(id)) {
                    this.scrollMap.delete(id);
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
              try {
                for (
                  var _f = Object(
                      _node_modules_tslib_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__[
                        '__values'
                      ]
                    )(this.inputMap.keys()),
                    _g = _f.next();
                  !_g.done;
                  _g = _f.next()
                ) {
                  var id = _g.value;
                  if (this.removeIdSet.has(id)) {
                    this.inputMap.delete(id);
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
              var scrollMap = new Map(this.scrollMap);
              var inputMap = new Map(this.inputMap);
              this.reset();
              return {
                mutationData: batchMutationData,
                scrollMap: scrollMap,
                inputMap: inputMap,
              };
            };
            TreeIndex.prototype.reset = function () {
              this.tree = [];
              this.indexes = new Map();
              this.removeNodeMutations = [];
              this.textMutations = [];
              this.attributeMutations = [];
              this.removeIdSet = new Set();
              this.scrollMap = new Map();
              this.inputMap = new Map();
            };
            return TreeIndex;
          })();

          /***/
        },

      /***/ './node_modules/symbol-observable/es/index.js':
        /*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* WEBPACK VAR INJECTION */ (function (global, module) {
            /* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./ponyfill.js */ './node_modules/symbol-observable/es/ponyfill.js'
            );
            /* global window */

            var root;

            if (typeof self !== 'undefined') {
              root = self;
            } else if (typeof window !== 'undefined') {
              root = window;
            } else if (typeof global !== 'undefined') {
              root = global;
            } else if (true) {
              root = module;
            } else {
            }

            var result = Object(
              _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__['default']
            )(root);
            /* harmony default export */ __webpack_exports__[
              'default'
            ] = result;

            /* WEBPACK VAR INJECTION */
          }.call(
            this,
            __webpack_require__(
              /*! ./../../webpack/buildin/global.js */ './node_modules/webpack/buildin/global.js'
            ),
            __webpack_require__(
              /*! ./../../webpack/buildin/harmony-module.js */ './node_modules/webpack/buildin/harmony-module.js'
            )(module)
          ));

          /***/
        },

      /***/ './node_modules/symbol-observable/es/ponyfill.js':
        /*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
        /*! exports provided: default */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'default',
            function () {
              return symbolObservablePonyfill;
            }
          );
          function symbolObservablePonyfill(root) {
            var result;
            var Symbol = root.Symbol;

            if (typeof Symbol === 'function') {
              if (Symbol.observable) {
                result = Symbol.observable;
              } else {
                result = Symbol('observable');
                Symbol.observable = result;
              }
            } else {
              result = '@@observable';
            }

            return result;
          }

          /***/
        },

      /***/ './node_modules/ts-invariant/lib/invariant.esm.js':
        /*!********************************************************!*\
  !*** ./node_modules/ts-invariant/lib/invariant.esm.js ***!
  \********************************************************/
        /*! exports provided: default, InvariantError, invariant, process */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* WEBPACK VAR INJECTION */ (function (process) {
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'InvariantError',
              function () {
                return InvariantError;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'invariant',
              function () {
                return invariant;
              }
            );
            /* harmony export (binding) */ __webpack_require__.d(
              __webpack_exports__,
              'process',
              function () {
                return processStub;
              }
            );
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! tslib */ './node_modules/tslib/tslib.es6.js'
            );

            var genericMessage = 'Invariant Violation';
            var _a = Object.setPrototypeOf,
              setPrototypeOf =
                _a === void 0
                  ? function (obj, proto) {
                      obj.__proto__ = proto;
                      return obj;
                    }
                  : _a;
            var InvariantError = /** @class */ (function (_super) {
              Object(tslib__WEBPACK_IMPORTED_MODULE_0__['__extends'])(
                InvariantError,
                _super
              );
              function InvariantError(message) {
                if (message === void 0) {
                  message = genericMessage;
                }
                var _this =
                  _super.call(
                    this,
                    typeof message === 'number'
                      ? genericMessage +
                          ': ' +
                          message +
                          ' (see https://github.com/apollographql/invariant-packages)'
                      : message
                  ) || this;
                _this.framesToPop = 1;
                _this.name = genericMessage;
                setPrototypeOf(_this, InvariantError.prototype);
                return _this;
              }
              return InvariantError;
            })(Error);
            function invariant(condition, message) {
              if (!condition) {
                throw new InvariantError(message);
              }
            }
            function wrapConsoleMethod(method) {
              return function () {
                return console[method].apply(console, arguments);
              };
            }
            (function (invariant) {
              invariant.warn = wrapConsoleMethod('warn');
              invariant.error = wrapConsoleMethod('error');
            })(invariant || (invariant = {}));
            // Code that uses ts-invariant with rollup-plugin-invariant may want to
            // import this process stub to avoid errors evaluating process.env.NODE_ENV.
            // However, because most ESM-to-CJS compilers will rewrite the process import
            // as tsInvariant.process, which prevents proper replacement by minifiers, we
            // also attempt to define the stub globally when it is not already defined.
            var processStub = { env: {} };
            if (typeof process === 'object') {
              processStub = process;
            } else
              try {
                // Using Function to evaluate this assignment in global scope also escapes
                // the strict mode of the current module, thereby allowing the assignment.
                // Inspired by https://github.com/facebook/regenerator/pull/369.
                Function('stub', 'process = stub')(processStub);
              } catch (atLeastWeTried) {
                // The assignment can fail if a Content Security Policy heavy-handedly
                // forbids Function usage. In those environments, developers should take
                // extra care to replace process.env.NODE_ENV in their production builds,
                // or define an appropriate global.process polyfill.
              }
            var invariant$1 = invariant;

            /* harmony default export */ __webpack_exports__[
              'default'
            ] = invariant$1;

            //# sourceMappingURL=invariant.esm.js.map

            /* WEBPACK VAR INJECTION */
          }.call(
            this,
            __webpack_require__(
              /*! ./../../process/browser.js */ './node_modules/process/browser.js'
            )
          ));

          /***/
        },

      /***/ './node_modules/tslib/tslib.es6.js':
        /*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
        /*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__extends',
            function () {
              return __extends;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__assign',
            function () {
              return __assign;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__rest',
            function () {
              return __rest;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__decorate',
            function () {
              return __decorate;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__param',
            function () {
              return __param;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__metadata',
            function () {
              return __metadata;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__awaiter',
            function () {
              return __awaiter;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__generator',
            function () {
              return __generator;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__createBinding',
            function () {
              return __createBinding;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__exportStar',
            function () {
              return __exportStar;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__values',
            function () {
              return __values;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__read',
            function () {
              return __read;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__spread',
            function () {
              return __spread;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__spreadArrays',
            function () {
              return __spreadArrays;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__await',
            function () {
              return __await;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__asyncGenerator',
            function () {
              return __asyncGenerator;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__asyncDelegator',
            function () {
              return __asyncDelegator;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__asyncValues',
            function () {
              return __asyncValues;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__makeTemplateObject',
            function () {
              return __makeTemplateObject;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__importStar',
            function () {
              return __importStar;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__importDefault',
            function () {
              return __importDefault;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__classPrivateFieldGet',
            function () {
              return __classPrivateFieldGet;
            }
          );
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            '__classPrivateFieldSet',
            function () {
              return __classPrivateFieldSet;
            }
          );
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
          /* global Reflect, Promise */

          var extendStatics = function (d, b) {
            extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b;
                }) ||
              function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
              };
            return extendStatics(d, b);
          };

          function __extends(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __());
          }

          var __assign = function () {
            __assign =
              Object.assign ||
              function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
              };
            return __assign.apply(this, arguments);
          };

          function __rest(s, e) {
            var t = {};
            for (var p in s)
              if (
                Object.prototype.hasOwnProperty.call(s, p) &&
                e.indexOf(p) < 0
              )
                t[p] = s[p];
            if (s != null && typeof Object.getOwnPropertySymbols === 'function')
              for (
                var i = 0, p = Object.getOwnPropertySymbols(s);
                i < p.length;
                i++
              ) {
                if (
                  e.indexOf(p[i]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(s, p[i])
                )
                  t[p[i]] = s[p[i]];
              }
            return t;
          }

          function __decorate(decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.decorate === 'function'
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          }

          function __param(paramIndex, decorator) {
            return function (target, key) {
              decorator(target, key, paramIndex);
            };
          }

          function __metadata(metadataKey, metadataValue) {
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.metadata === 'function'
            )
              return Reflect.metadata(metadataKey, metadataValue);
          }

          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P
                ? value
                : new P(function (resolve) {
                    resolve(value);
                  });
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator['throw'](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done
                  ? resolve(result.value)
                  : adopt(result.value).then(fulfilled, rejected);
              }
              step(
                (generator = generator.apply(thisArg, _arguments || [])).next()
              );
            });
          }

          function __generator(thisArg, body) {
            var _ = {
                label: 0,
                sent: function () {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: [],
              },
              f,
              y,
              t,
              g;
            return (
              (g = { next: verb(0), throw: verb(1), return: verb(2) }),
              typeof Symbol === 'function' &&
                (g[Symbol.iterator] = function () {
                  return this;
                }),
              g
            );
            function verb(n) {
              return function (v) {
                return step([n, v]);
              };
            }
            function step(op) {
              if (f) throw new TypeError('Generator is already executing.');
              while (_)
                try {
                  if (
                    ((f = 1),
                    y &&
                      (t =
                        op[0] & 2
                          ? y['return']
                          : op[0]
                          ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                          : y.next) &&
                      !(t = t.call(y, op[1])).done)
                  )
                    return t;
                  if (((y = 0), t)) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;
                    case 4:
                      _.label++;
                      return { value: op[1], done: false };
                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;
                    case 7:
                      op = _.ops.pop();
                      _.trys.pop();
                      continue;
                    default:
                      if (
                        !((t = _.trys),
                        (t = t.length > 0 && t[t.length - 1])) &&
                        (op[0] === 6 || op[0] === 2)
                      ) {
                        _ = 0;
                        continue;
                      }
                      if (
                        op[0] === 3 &&
                        (!t || (op[1] > t[0] && op[1] < t[3]))
                      ) {
                        _.label = op[1];
                        break;
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                      }
                      if (t[2]) _.ops.pop();
                      _.trys.pop();
                      continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
              if (op[0] & 5) throw op[1];
              return { value: op[0] ? op[1] : void 0, done: true };
            }
          }

          function __createBinding(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          }

          function __exportStar(m, exports) {
            for (var p in m)
              if (p !== 'default' && !exports.hasOwnProperty(p))
                exports[p] = m[p];
          }

          function __values(o) {
            var s = typeof Symbol === 'function' && Symbol.iterator,
              m = s && o[s],
              i = 0;
            if (m) return m.call(o);
            if (o && typeof o.length === 'number')
              return {
                next: function () {
                  if (o && i >= o.length) o = void 0;
                  return { value: o && o[i++], done: !o };
                },
              };
            throw new TypeError(
              s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
            );
          }

          function __read(o, n) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o),
              r,
              ar = [],
              e;
            try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
            } catch (error) {
              e = { error: error };
            } finally {
              try {
                if (r && !r.done && (m = i['return'])) m.call(i);
              } finally {
                if (e) throw e.error;
              }
            }
            return ar;
          }

          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]));
            return ar;
          }

          function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++)
              s += arguments[i].length;
            for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
            return r;
          }

          function __await(v) {
            return this instanceof __await
              ? ((this.v = v), this)
              : new __await(v);
          }

          function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.');
            var g = generator.apply(thisArg, _arguments || []),
              i,
              q = [];
            return (
              (i = {}),
              verb('next'),
              verb('throw'),
              verb('return'),
              (i[Symbol.asyncIterator] = function () {
                return this;
              }),
              i
            );
            function verb(n) {
              if (g[n])
                i[n] = function (v) {
                  return new Promise(function (a, b) {
                    q.push([n, v, a, b]) > 1 || resume(n, v);
                  });
                };
            }
            function resume(n, v) {
              try {
                step(g[n](v));
              } catch (e) {
                settle(q[0][3], e);
              }
            }
            function step(r) {
              r.value instanceof __await
                ? Promise.resolve(r.value.v).then(fulfill, reject)
                : settle(q[0][2], r);
            }
            function fulfill(value) {
              resume('next', value);
            }
            function reject(value) {
              resume('throw', value);
            }
            function settle(f, v) {
              if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
            }
          }

          function __asyncDelegator(o) {
            var i, p;
            return (
              (i = {}),
              verb('next'),
              verb('throw', function (e) {
                throw e;
              }),
              verb('return'),
              (i[Symbol.iterator] = function () {
                return this;
              }),
              i
            );
            function verb(n, f) {
              i[n] = o[n]
                ? function (v) {
                    return (p = !p)
                      ? { value: __await(o[n](v)), done: n === 'return' }
                      : f
                      ? f(v)
                      : v;
                  }
                : f;
            }
          }

          function __asyncValues(o) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.');
            var m = o[Symbol.asyncIterator],
              i;
            return m
              ? m.call(o)
              : ((o =
                  typeof __values === 'function'
                    ? __values(o)
                    : o[Symbol.iterator]()),
                (i = {}),
                verb('next'),
                verb('throw'),
                verb('return'),
                (i[Symbol.asyncIterator] = function () {
                  return this;
                }),
                i);
            function verb(n) {
              i[n] =
                o[n] &&
                function (v) {
                  return new Promise(function (resolve, reject) {
                    (v = o[n](v)), settle(resolve, reject, v.done, v.value);
                  });
                };
            }
            function settle(resolve, reject, d, v) {
              Promise.resolve(v).then(function (v) {
                resolve({ value: v, done: d });
              }, reject);
            }
          }

          function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
              Object.defineProperty(cooked, 'raw', { value: raw });
            } else {
              cooked.raw = raw;
            }
            return cooked;
          }

          function __importStar(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
            result.default = mod;
            return result;
          }

          function __importDefault(mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          }

          function __classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to get private field on non-instance'
              );
            }
            return privateMap.get(receiver);
          }

          function __classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to set private field on non-instance'
              );
            }
            privateMap.set(receiver, value);
            return value;
          }

          /***/
        },

      /***/ './node_modules/webpack/buildin/global.js':
        /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          var g;

          // This works in non-strict mode
          g = (function () {
            return this;
          })();

          try {
            // This works if eval is allowed (see CSP)
            g = g || new Function('return this')();
          } catch (e) {
            // This works if the window reference is available
            if (typeof window === 'object') g = window;
          }

          // g can still be undefined, but nothing to do about it...
          // We return undefined, instead of nothing here, so it's
          // easier to handle this case. if(!global) { ...}

          module.exports = g;

          /***/
        },

      /***/ './node_modules/webpack/buildin/harmony-module.js':
        /*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
        /*! no static exports found */
        /***/ function (module, exports) {
          module.exports = function (originalModule) {
            if (!originalModule.webpackPolyfill) {
              var module = Object.create(originalModule);
              // module.parent = undefined by default
              if (!module.children) module.children = [];
              Object.defineProperty(module, 'loaded', {
                enumerable: true,
                get: function () {
                  return module.l;
                },
              });
              Object.defineProperty(module, 'id', {
                enumerable: true,
                get: function () {
                  return module.i;
                },
              });
              Object.defineProperty(module, 'exports', {
                enumerable: true,
              });
              module.webpackPolyfill = 1;
            }
            return module;
          };

          /***/
        },

      /***/ './node_modules/zen-observable/index.js':
        /*!**********************************************!*\
  !*** ./node_modules/zen-observable/index.js ***!
  \**********************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          module.exports = __webpack_require__(
            /*! ./lib/Observable.js */ './node_modules/zen-observable/lib/Observable.js'
          ).Observable;

          /***/
        },

      /***/ './node_modules/zen-observable/lib/Observable.js':
        /*!*******************************************************!*\
  !*** ./node_modules/zen-observable/lib/Observable.js ***!
  \*******************************************************/
        /*! no static exports found */
        /***/ function (module, exports, __webpack_require__) {
          'use strict';

          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.Observable = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          // === Symbol Support ===
          var hasSymbols = function () {
            return typeof Symbol === 'function';
          };

          var hasSymbol = function (name) {
            return hasSymbols() && Boolean(Symbol[name]);
          };

          var getSymbol = function (name) {
            return hasSymbol(name) ? Symbol[name] : '@@' + name;
          };

          if (hasSymbols() && !hasSymbol('observable')) {
            Symbol.observable = Symbol('observable');
          }

          var SymbolIterator = getSymbol('iterator');
          var SymbolObservable = getSymbol('observable');
          var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

          function getMethod(obj, key) {
            var value = obj[key];
            if (value == null) return undefined;
            if (typeof value !== 'function')
              throw new TypeError(value + ' is not a function');
            return value;
          }

          function getSpecies(obj) {
            var ctor = obj.constructor;

            if (ctor !== undefined) {
              ctor = ctor[SymbolSpecies];

              if (ctor === null) {
                ctor = undefined;
              }
            }

            return ctor !== undefined ? ctor : Observable;
          }

          function isObservable(x) {
            return x instanceof Observable; // SPEC: Brand check
          }

          function hostReportError(e) {
            if (hostReportError.log) {
              hostReportError.log(e);
            } else {
              setTimeout(function () {
                throw e;
              });
            }
          }

          function enqueue(fn) {
            Promise.resolve().then(function () {
              try {
                fn();
              } catch (e) {
                hostReportError(e);
              }
            });
          }

          function cleanupSubscription(subscription) {
            var cleanup = subscription._cleanup;
            if (cleanup === undefined) return;
            subscription._cleanup = undefined;

            if (!cleanup) {
              return;
            }

            try {
              if (typeof cleanup === 'function') {
                cleanup();
              } else {
                var unsubscribe = getMethod(cleanup, 'unsubscribe');

                if (unsubscribe) {
                  unsubscribe.call(cleanup);
                }
              }
            } catch (e) {
              hostReportError(e);
            }
          }

          function closeSubscription(subscription) {
            subscription._observer = undefined;
            subscription._queue = undefined;
            subscription._state = 'closed';
          }

          function flushSubscription(subscription) {
            var queue = subscription._queue;

            if (!queue) {
              return;
            }

            subscription._queue = undefined;
            subscription._state = 'ready';

            for (var i = 0; i < queue.length; ++i) {
              notifySubscription(subscription, queue[i].type, queue[i].value);
              if (subscription._state === 'closed') break;
            }
          }

          function notifySubscription(subscription, type, value) {
            subscription._state = 'running';
            var observer = subscription._observer;

            try {
              var m = getMethod(observer, type);

              switch (type) {
                case 'next':
                  if (m) m.call(observer, value);
                  break;

                case 'error':
                  closeSubscription(subscription);
                  if (m) m.call(observer, value);
                  else throw value;
                  break;

                case 'complete':
                  closeSubscription(subscription);
                  if (m) m.call(observer);
                  break;
              }
            } catch (e) {
              hostReportError(e);
            }

            if (subscription._state === 'closed')
              cleanupSubscription(subscription);
            else if (subscription._state === 'running')
              subscription._state = 'ready';
          }

          function onNotify(subscription, type, value) {
            if (subscription._state === 'closed') return;

            if (subscription._state === 'buffering') {
              subscription._queue.push({
                type: type,
                value: value,
              });

              return;
            }

            if (subscription._state !== 'ready') {
              subscription._state = 'buffering';
              subscription._queue = [
                {
                  type: type,
                  value: value,
                },
              ];
              enqueue(function () {
                return flushSubscription(subscription);
              });
              return;
            }

            notifySubscription(subscription, type, value);
          }

          var Subscription =
            /*#__PURE__*/
            (function () {
              function Subscription(observer, subscriber) {
                _classCallCheck(this, Subscription);

                // ASSERT: observer is an object
                // ASSERT: subscriber is callable
                this._cleanup = undefined;
                this._observer = observer;
                this._queue = undefined;
                this._state = 'initializing';
                var subscriptionObserver = new SubscriptionObserver(this);

                try {
                  this._cleanup = subscriber.call(
                    undefined,
                    subscriptionObserver
                  );
                } catch (e) {
                  subscriptionObserver.error(e);
                }

                if (this._state === 'initializing') this._state = 'ready';
              }

              _createClass(Subscription, [
                {
                  key: 'unsubscribe',
                  value: function unsubscribe() {
                    if (this._state !== 'closed') {
                      closeSubscription(this);
                      cleanupSubscription(this);
                    }
                  },
                },
                {
                  key: 'closed',
                  get: function () {
                    return this._state === 'closed';
                  },
                },
              ]);

              return Subscription;
            })();

          var SubscriptionObserver =
            /*#__PURE__*/
            (function () {
              function SubscriptionObserver(subscription) {
                _classCallCheck(this, SubscriptionObserver);

                this._subscription = subscription;
              }

              _createClass(SubscriptionObserver, [
                {
                  key: 'next',
                  value: function next(value) {
                    onNotify(this._subscription, 'next', value);
                  },
                },
                {
                  key: 'error',
                  value: function error(value) {
                    onNotify(this._subscription, 'error', value);
                  },
                },
                {
                  key: 'complete',
                  value: function complete() {
                    onNotify(this._subscription, 'complete');
                  },
                },
                {
                  key: 'closed',
                  get: function () {
                    return this._subscription._state === 'closed';
                  },
                },
              ]);

              return SubscriptionObserver;
            })();

          var Observable =
            /*#__PURE__*/
            (function () {
              function Observable(subscriber) {
                _classCallCheck(this, Observable);

                if (!(this instanceof Observable))
                  throw new TypeError(
                    'Observable cannot be called as a function'
                  );
                if (typeof subscriber !== 'function')
                  throw new TypeError(
                    'Observable initializer must be a function'
                  );
                this._subscriber = subscriber;
              }

              _createClass(
                Observable,
                [
                  {
                    key: 'subscribe',
                    value: function subscribe(observer) {
                      if (typeof observer !== 'object' || observer === null) {
                        observer = {
                          next: observer,
                          error: arguments[1],
                          complete: arguments[2],
                        };
                      }

                      return new Subscription(observer, this._subscriber);
                    },
                  },
                  {
                    key: 'forEach',
                    value: function forEach(fn) {
                      var _this = this;

                      return new Promise(function (resolve, reject) {
                        if (typeof fn !== 'function') {
                          reject(new TypeError(fn + ' is not a function'));
                          return;
                        }

                        function done() {
                          subscription.unsubscribe();
                          resolve();
                        }

                        var subscription = _this.subscribe({
                          next: function (value) {
                            try {
                              fn(value, done);
                            } catch (e) {
                              reject(e);
                              subscription.unsubscribe();
                            }
                          },
                          error: reject,
                          complete: resolve,
                        });
                      });
                    },
                  },
                  {
                    key: 'map',
                    value: function map(fn) {
                      var _this2 = this;

                      if (typeof fn !== 'function')
                        throw new TypeError(fn + ' is not a function');
                      var C = getSpecies(this);
                      return new C(function (observer) {
                        return _this2.subscribe({
                          next: function (value) {
                            try {
                              value = fn(value);
                            } catch (e) {
                              return observer.error(e);
                            }

                            observer.next(value);
                          },
                          error: function (e) {
                            observer.error(e);
                          },
                          complete: function () {
                            observer.complete();
                          },
                        });
                      });
                    },
                  },
                  {
                    key: 'filter',
                    value: function filter(fn) {
                      var _this3 = this;

                      if (typeof fn !== 'function')
                        throw new TypeError(fn + ' is not a function');
                      var C = getSpecies(this);
                      return new C(function (observer) {
                        return _this3.subscribe({
                          next: function (value) {
                            try {
                              if (!fn(value)) return;
                            } catch (e) {
                              return observer.error(e);
                            }

                            observer.next(value);
                          },
                          error: function (e) {
                            observer.error(e);
                          },
                          complete: function () {
                            observer.complete();
                          },
                        });
                      });
                    },
                  },
                  {
                    key: 'reduce',
                    value: function reduce(fn) {
                      var _this4 = this;

                      if (typeof fn !== 'function')
                        throw new TypeError(fn + ' is not a function');
                      var C = getSpecies(this);
                      var hasSeed = arguments.length > 1;
                      var hasValue = false;
                      var seed = arguments[1];
                      var acc = seed;
                      return new C(function (observer) {
                        return _this4.subscribe({
                          next: function (value) {
                            var first = !hasValue;
                            hasValue = true;

                            if (!first || hasSeed) {
                              try {
                                acc = fn(acc, value);
                              } catch (e) {
                                return observer.error(e);
                              }
                            } else {
                              acc = value;
                            }
                          },
                          error: function (e) {
                            observer.error(e);
                          },
                          complete: function () {
                            if (!hasValue && !hasSeed)
                              return observer.error(
                                new TypeError('Cannot reduce an empty sequence')
                              );
                            observer.next(acc);
                            observer.complete();
                          },
                        });
                      });
                    },
                  },
                  {
                    key: 'concat',
                    value: function concat() {
                      var _this5 = this;

                      for (
                        var _len = arguments.length,
                          sources = new Array(_len),
                          _key = 0;
                        _key < _len;
                        _key++
                      ) {
                        sources[_key] = arguments[_key];
                      }

                      var C = getSpecies(this);
                      return new C(function (observer) {
                        var subscription;
                        var index = 0;

                        function startNext(next) {
                          subscription = next.subscribe({
                            next: function (v) {
                              observer.next(v);
                            },
                            error: function (e) {
                              observer.error(e);
                            },
                            complete: function () {
                              if (index === sources.length) {
                                subscription = undefined;
                                observer.complete();
                              } else {
                                startNext(C.from(sources[index++]));
                              }
                            },
                          });
                        }

                        startNext(_this5);
                        return function () {
                          if (subscription) {
                            subscription.unsubscribe();
                            subscription = undefined;
                          }
                        };
                      });
                    },
                  },
                  {
                    key: 'flatMap',
                    value: function flatMap(fn) {
                      var _this6 = this;

                      if (typeof fn !== 'function')
                        throw new TypeError(fn + ' is not a function');
                      var C = getSpecies(this);
                      return new C(function (observer) {
                        var subscriptions = [];

                        var outer = _this6.subscribe({
                          next: function (value) {
                            if (fn) {
                              try {
                                value = fn(value);
                              } catch (e) {
                                return observer.error(e);
                              }
                            }

                            var inner = C.from(value).subscribe({
                              next: function (value) {
                                observer.next(value);
                              },
                              error: function (e) {
                                observer.error(e);
                              },
                              complete: function () {
                                var i = subscriptions.indexOf(inner);
                                if (i >= 0) subscriptions.splice(i, 1);
                                completeIfDone();
                              },
                            });
                            subscriptions.push(inner);
                          },
                          error: function (e) {
                            observer.error(e);
                          },
                          complete: function () {
                            completeIfDone();
                          },
                        });

                        function completeIfDone() {
                          if (outer.closed && subscriptions.length === 0)
                            observer.complete();
                        }

                        return function () {
                          subscriptions.forEach(function (s) {
                            return s.unsubscribe();
                          });
                          outer.unsubscribe();
                        };
                      });
                    },
                  },
                  {
                    key: SymbolObservable,
                    value: function () {
                      return this;
                    },
                  },
                ],
                [
                  {
                    key: 'from',
                    value: function from(x) {
                      var C = typeof this === 'function' ? this : Observable;
                      if (x == null)
                        throw new TypeError(x + ' is not an object');
                      var method = getMethod(x, SymbolObservable);

                      if (method) {
                        var observable = method.call(x);
                        if (Object(observable) !== observable)
                          throw new TypeError(observable + ' is not an object');
                        if (
                          isObservable(observable) &&
                          observable.constructor === C
                        )
                          return observable;
                        return new C(function (observer) {
                          return observable.subscribe(observer);
                        });
                      }

                      if (hasSymbol('iterator')) {
                        method = getMethod(x, SymbolIterator);

                        if (method) {
                          return new C(function (observer) {
                            enqueue(function () {
                              if (observer.closed) return;
                              var _iteratorNormalCompletion = true;
                              var _didIteratorError = false;
                              var _iteratorError = undefined;

                              try {
                                for (
                                  var _iterator = method
                                      .call(x)
                                      [Symbol.iterator](),
                                    _step;
                                  !(_iteratorNormalCompletion = (_step = _iterator.next())
                                    .done);
                                  _iteratorNormalCompletion = true
                                ) {
                                  var _item = _step.value;
                                  observer.next(_item);
                                  if (observer.closed) return;
                                }
                              } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                              } finally {
                                try {
                                  if (
                                    !_iteratorNormalCompletion &&
                                    _iterator.return != null
                                  ) {
                                    _iterator.return();
                                  }
                                } finally {
                                  if (_didIteratorError) {
                                    throw _iteratorError;
                                  }
                                }
                              }

                              observer.complete();
                            });
                          });
                        }
                      }

                      if (Array.isArray(x)) {
                        return new C(function (observer) {
                          enqueue(function () {
                            if (observer.closed) return;

                            for (var i = 0; i < x.length; ++i) {
                              observer.next(x[i]);
                              if (observer.closed) return;
                            }

                            observer.complete();
                          });
                        });
                      }

                      throw new TypeError(x + ' is not observable');
                    },
                  },
                  {
                    key: 'of',
                    value: function of() {
                      for (
                        var _len2 = arguments.length,
                          items = new Array(_len2),
                          _key2 = 0;
                        _key2 < _len2;
                        _key2++
                      ) {
                        items[_key2] = arguments[_key2];
                      }

                      var C = typeof this === 'function' ? this : Observable;
                      return new C(function (observer) {
                        enqueue(function () {
                          if (observer.closed) return;

                          for (var i = 0; i < items.length; ++i) {
                            observer.next(items[i]);
                            if (observer.closed) return;
                          }

                          observer.complete();
                        });
                      });
                    },
                  },
                  {
                    key: SymbolSpecies,
                    get: function () {
                      return this;
                    },
                  },
                ]
              );

              return Observable;
            })();

          exports.Observable = Observable;

          if (hasSymbols()) {
            Object.defineProperty(Observable, Symbol('extensions'), {
              value: {
                symbol: SymbolObservable,
                hostReportError: hostReportError,
              },
              configurable: true,
            });
          }

          /***/
        },

      /***/ './src/index.tsx':
        /*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
        /*! no exports provided */
        /***/ function (module, __webpack_exports__, __webpack_require__) {
          'use strict';
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var rrweb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! rrweb */ './node_modules/rrweb/es/rrweb/src/entries/all.js'
          );
          /* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! detect-browser */ './node_modules/detect-browser/es/index.js'
          );
          /* harmony import */ var _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
            /*! @apollo/client/core */ './node_modules/@apollo/client/core/index.js'
          );
          var __makeTemplateObject =
            (undefined && undefined.__makeTemplateObject) ||
            function (cooked, raw) {
              if (Object.defineProperty) {
                Object.defineProperty(cooked, 'raw', { value: raw });
              } else {
                cooked.raw = raw;
              }
              return cooked;
            };
          var __assign =
            (undefined && undefined.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                      if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          var __awaiter =
            (undefined && undefined.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P
                  ? value
                  : new P(function (resolve) {
                      resolve(value);
                    });
              }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator['throw'](value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected);
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                );
              });
            };
          var __generator =
            (undefined && undefined.__generator) ||
            function (thisArg, body) {
              var _ = {
                  label: 0,
                  sent: function () {
                    if (t[0] & 1) throw t[1];
                    return t[1];
                  },
                  trys: [],
                  ops: [],
                },
                f,
                y,
                t,
                g;
              return (
                (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                typeof Symbol === 'function' &&
                  (g[Symbol.iterator] = function () {
                    return this;
                  }),
                g
              );
              function verb(n) {
                return function (v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f) throw new TypeError('Generator is already executing.');
                while (_)
                  try {
                    if (
                      ((f = 1),
                      y &&
                        (t =
                          op[0] & 2
                            ? y['return']
                            : op[0]
                            ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                            : y.next) &&
                        !(t = t.call(y, op[1])).done)
                    )
                      return t;
                    if (((y = 0), t)) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (
                          !((t = _.trys),
                          (t = t.length > 0 && t[t.length - 1])) &&
                          (op[0] === 6 || op[0] === 2)
                        ) {
                          _ = 0;
                          continue;
                        }
                        if (
                          op[0] === 3 &&
                          (!t || (op[1] > t[0] && op[1] < t[3]))
                        ) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };

          window.Highlight = /** @class */ (function () {
            function Highlight(debug) {
              // If debug is set to false, disable all console
              this.ready = false;
              if (!debug) {
                console.log = function () {};
              }
              this.client = new _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__[
                'ApolloClient'
              ]({
                uri: 'http://localhost:8082' + '/client',
                cache: new _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__[
                  'InMemoryCache'
                ](),
                credentials: 'include',
              });
              this.organizationID = 0;
              this.sessionID = 0;
              this.events = [];
            }
            Highlight.prototype.identify = function (
              user_identifier,
              user_object
            ) {
              if (user_object === void 0) {
                user_object = {};
              }
              return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [
                        4 /*yield*/,
                        this.client.mutate({
                          mutation: Object(
                            _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__[
                              'gql'
                            ]
                          )(
                            templateObject_1 ||
                              (templateObject_1 = __makeTemplateObject(
                                [
                                  '\n        mutation identifySession(\n          $session_id: ID!\n          $user_identifier: String!\n          $user_object: Any\n        ) {\n          identifySession(\n            session_id: $session_id\n            user_identifier: $user_identifier\n            user_object: $user_object\n          )\n        }\n      ',
                                ],
                                [
                                  '\n        mutation identifySession(\n          $session_id: ID!\n          $user_identifier: String!\n          $user_object: Any\n        ) {\n          identifySession(\n            session_id: $session_id\n            user_identifier: $user_identifier\n            user_object: $user_object\n          )\n        }\n      ',
                                ]
                              ))
                          ),
                          variables: {
                            session_id: this.sessionID,
                            user_identifier: user_identifier,
                            user_object: user_object,
                          },
                        }),
                      ];
                    case 1:
                      _a.sent();
                      console.log(
                        'Identify (' +
                          user_identifier +
                          ') w/ obj: ' +
                          JSON.stringify(user_object) +
                          ' @ ' +
                          'http://localhost:8082'
                      );
                      return [2 /*return*/];
                  }
                });
              });
            };
            Highlight.prototype.initialize = function (organizationID) {
              return __awaiter(this, void 0, void 0, function () {
                var browser, response, data, details, gr, emit;
                var _this = this;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      browser = Object(
                        detect_browser__WEBPACK_IMPORTED_MODULE_1__['detect']
                      )();
                      if (!organizationID) {
                        console.error('empty organization_id!');
                        return [2 /*return*/];
                      }
                      this.organizationID = organizationID;
                      return [
                        4 /*yield*/,
                        fetch('https://geolocation-db.com/json/'),
                      ];
                    case 1:
                      response = _a.sent();
                      return [4 /*yield*/, response.json()];
                    case 2:
                      data = _a.sent();
                      details = JSON.stringify(
                        __assign(__assign({}, data), { browser: browser })
                      );
                      return [
                        4 /*yield*/,
                        this.client.mutate({
                          mutation: Object(
                            _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__[
                              'gql'
                            ]
                          )(
                            templateObject_2 ||
                              (templateObject_2 = __makeTemplateObject(
                                [
                                  '\n        mutation initializeSession($organization_id: ID!, $details: String!) {\n          initializeSession(\n            organization_id: $organization_id\n            details: $details\n          ) {\n            id\n            user_id\n            organization_id\n            details\n          }\n        }\n      ',
                                ],
                                [
                                  '\n        mutation initializeSession($organization_id: ID!, $details: String!) {\n          initializeSession(\n            organization_id: $organization_id\n            details: $details\n          ) {\n            id\n            user_id\n            organization_id\n            details\n          }\n        }\n      ',
                                ]
                              ))
                          ),
                          variables: {
                            organization_id: this.organizationID,
                            details: details,
                          },
                        }),
                      ];
                    case 3:
                      gr = _a.sent();
                      this.sessionID = gr.data.initializeSession.id;
                      console.log(
                        'Loaded Highlight\nRemote: ' +
                          'http://localhost:8082' +
                          '\nOrg:: ' +
                          this.organizationID +
                          '\nSession Data: \n',
                        gr.data
                      );
                      setInterval(function () {
                        _this._save();
                      }, 5 * 1000);
                      emit = function (event) {
                        _this.events.push(event);
                      };
                      emit.bind(this);
                      Object(rrweb__WEBPACK_IMPORTED_MODULE_0__['record'])({
                        emit: emit,
                      });
                      this.ready = true;
                      return [2 /*return*/];
                  }
                });
              });
            };
            // Reset the events array and push to a backend.
            Highlight.prototype._save = function () {
              return __awaiter(this, void 0, void 0, function () {
                var eventsString, gr;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if (!this.sessionID) {
                        return [2 /*return*/];
                      }
                      eventsString = JSON.stringify({ events: this.events });
                      console.log(
                        'Send (' +
                          this.events.length +
                          ') @ ' +
                          'http://localhost:8082' +
                          ', org: ' +
                          this.organizationID
                      );
                      this.events = [];
                      return [
                        4 /*yield*/,
                        this.client.mutate({
                          mutation: Object(
                            _apollo_client_core__WEBPACK_IMPORTED_MODULE_2__[
                              'gql'
                            ]
                          )(
                            templateObject_3 ||
                              (templateObject_3 = __makeTemplateObject(
                                [
                                  '\n        mutation AddEvents($session_id: ID!, $events: String!) {\n          addEvents(session_id: $session_id, events: $events)\n        }\n      ',
                                ],
                                [
                                  '\n        mutation AddEvents($session_id: ID!, $events: String!) {\n          addEvents(session_id: $session_id, events: $events)\n        }\n      ',
                                ]
                              ))
                          ),
                          variables: {
                            session_id: this.sessionID,
                            events: eventsString,
                          },
                        }),
                      ];
                    case 1:
                      gr = _a.sent();
                      return [2 /*return*/];
                  }
                });
              });
            };
            return Highlight;
          })();
          var templateObject_1, templateObject_2, templateObject_3;

          /***/
        },

      /******/
    }
  );
});
